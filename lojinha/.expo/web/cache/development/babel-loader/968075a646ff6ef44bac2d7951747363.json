{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport invariant from 'fbjs/lib/invariant';\n\nvar EventHolder = function () {\n  function EventHolder() {\n    _classCallCheck(this, EventHolder);\n\n    this._heldEvents = {};\n    this._currentEventKey = null;\n  }\n\n  _createClass(EventHolder, [{\n    key: \"holdEvent\",\n    value: function holdEvent(eventType) {\n      this._heldEvents[eventType] = this._heldEvents[eventType] || [];\n      var eventsOfType = this._heldEvents[eventType];\n      var key = {\n        eventType: eventType,\n        index: eventsOfType.length\n      };\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      eventsOfType.push(args);\n      return key;\n    }\n  }, {\n    key: \"emitToListener\",\n    value: function emitToListener(eventType, listener, context) {\n      var _this = this;\n\n      var eventsOfType = this._heldEvents[eventType];\n\n      if (!eventsOfType) {\n        return;\n      }\n\n      var origEventKey = this._currentEventKey;\n      eventsOfType.forEach(function (eventHeld, index) {\n        if (!eventHeld) {\n          return;\n        }\n\n        _this._currentEventKey = {\n          eventType: eventType,\n          index: index\n        };\n        listener.apply(context, eventHeld);\n      });\n      this._currentEventKey = origEventKey;\n    }\n  }, {\n    key: \"releaseCurrentEvent\",\n    value: function releaseCurrentEvent() {\n      invariant(this._currentEventKey !== null, 'Not in an emitting cycle; there is no current event');\n      this._currentEventKey && this.releaseEvent(this._currentEventKey);\n    }\n  }, {\n    key: \"releaseEvent\",\n    value: function releaseEvent(token) {\n      delete this._heldEvents[token.eventType][token.index];\n    }\n  }, {\n    key: \"releaseEventType\",\n    value: function releaseEventType(type) {\n      this._heldEvents[type] = [];\n    }\n  }]);\n\n  return EventHolder;\n}();\n\nexport default EventHolder;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/src/vendor/react-native/emitter/EventHolder.js"],"names":["invariant","EventHolder","_heldEvents","_currentEventKey","eventType","eventsOfType","key","index","length","args","push","listener","context","origEventKey","forEach","eventHeld","apply","releaseEvent","token","type"],"mappings":"AAUA;;;;AAEA,OAAOA,SAAP,MAAsB,oBAAtB;;IAEMC,W;AAIJ,yBAAc;AAAA;;AACZ,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACD;;;;WAuBD,mBAAUC,SAAV,EAA2C;AACzC,WAAKF,WAAL,CAAiBE,SAAjB,IAA8B,KAAKF,WAAL,CAAiBE,SAAjB,KAA+B,EAA7D;AACA,UAAMC,YAAY,GAAG,KAAKH,WAAL,CAAiBE,SAAjB,CAArB;AACA,UAAME,GAAG,GAAG;AACVF,QAAAA,SAAS,EAAEA,SADD;AAEVG,QAAAA,KAAK,EAAEF,YAAY,CAACG;AAFV,OAAZ;;AAHyC,wCAAXC,IAAW;AAAXA,QAAAA,IAAW;AAAA;;AAOzCJ,MAAAA,YAAY,CAACK,IAAb,CAAkBD,IAAlB;AACA,aAAOH,GAAP;AACD;;;WAUD,wBAAeF,SAAf,EAAmCO,QAAnC,EAAuDC,OAAvD,EAAyE;AAAA;;AACvE,UAAMP,YAAY,GAAG,KAAKH,WAAL,CAAiBE,SAAjB,CAArB;;AACA,UAAI,CAACC,YAAL,EAAmB;AACjB;AACD;;AACD,UAAMQ,YAAY,GAAG,KAAKV,gBAA1B;AACAE,MAAAA,YAAY,CAACS,OAAb,CAAqB,UAAYC,SAAZ,EAAkCR,KAAlC,EAA4C;AAC/D,YAAI,CAACQ,SAAL,EAAgB;AACd;AACD;;AACD,QAAA,KAAI,CAACZ,gBAAL,GAAwB;AACtBC,UAAAA,SAAS,EAAEA,SADW;AAEtBG,UAAAA,KAAK,EAAEA;AAFe,SAAxB;AAIAI,QAAAA,QAAQ,CAACK,KAAT,CAAeJ,OAAf,EAAwBG,SAAxB;AACD,OATD;AAUA,WAAKZ,gBAAL,GAAwBU,YAAxB;AACD;;;WAUD,+BAAsB;AACpBb,MAAAA,SAAS,CACP,KAAKG,gBAAL,KAA0B,IADnB,EAEP,qDAFO,CAAT;AAIA,WAAKA,gBAAL,IAAyB,KAAKc,YAAL,CAAkB,KAAKd,gBAAvB,CAAzB;AACD;;;WAQD,sBAAae,KAAb,EAA4B;AAC1B,aAAO,KAAKhB,WAAL,CAAiBgB,KAAK,CAACd,SAAvB,EAAkCc,KAAK,CAACX,KAAxC,CAAP;AACD;;;WAOD,0BAAiBY,IAAjB,EAA+B;AAC7B,WAAKjB,WAAL,CAAiBiB,IAAjB,IAAyB,EAAzB;AACD;;;;;;AAGH,eAAelB,WAAf","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\n\nclass EventHolder {\n  _heldEvents: Object;\n  _currentEventKey: ?Object;\n\n  constructor() {\n    this._heldEvents = {};\n    this._currentEventKey = null;\n  }\n\n  /**\n   * Holds a given event for processing later.\n   *\n   * TODO: Annotate return type better. The structural type of the return here\n   *       is pretty obvious.\n   *\n   * @param {string} eventType - Name of the event to hold and later emit\n   * @param {...*} Arbitrary arguments to be passed to each registered listener\n   * @return {object} Token that can be used to release the held event\n   *\n   * @example\n   *\n   *   holder.holdEvent({someEvent: 'abc'});\n   *\n   *   holder.emitToHandler({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *     }\n   *   }); //logs 'abc'\n   *\n   */\n  holdEvent(eventType: string, ...args: any) {\n    this._heldEvents[eventType] = this._heldEvents[eventType] || [];\n    const eventsOfType = this._heldEvents[eventType];\n    const key = {\n      eventType: eventType,\n      index: eventsOfType.length,\n    };\n    eventsOfType.push(args);\n    return key;\n  }\n\n  /**\n   * Emits the held events of the specified type to the given listener.\n   *\n   * @param {?string} eventType - Optional name of the events to replay\n   * @param {function} listener - The listener to which to dispatch the event\n   * @param {?object} context - Optional context object to use when invoking\n   *   the listener\n   */\n  emitToListener(eventType: ?string, listener: Function, context: ?Object) {\n    const eventsOfType = this._heldEvents[eventType];\n    if (!eventsOfType) {\n      return;\n    }\n    const origEventKey = this._currentEventKey;\n    eventsOfType.forEach((/*?array*/ eventHeld, /*number*/ index) => {\n      if (!eventHeld) {\n        return;\n      }\n      this._currentEventKey = {\n        eventType: eventType,\n        index: index,\n      };\n      listener.apply(context, eventHeld);\n    });\n    this._currentEventKey = origEventKey;\n  }\n\n  /**\n   * Provides an API that can be called during an eventing cycle to release\n   * the last event that was invoked, so that it is no longer \"held\".\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   */\n  releaseCurrentEvent() {\n    invariant(\n      this._currentEventKey !== null,\n      'Not in an emitting cycle; there is no current event',\n    );\n    this._currentEventKey && this.releaseEvent(this._currentEventKey);\n  }\n\n  /**\n   * Releases the event corresponding to the handle that was returned when the\n   * event was first held.\n   *\n   * @param {object} token - The token returned from holdEvent\n   */\n  releaseEvent(token: Object) {\n    delete this._heldEvents[token.eventType][token.index];\n  }\n\n  /**\n   * Releases all events of a certain type.\n   *\n   * @param {string} type\n   */\n  releaseEventType(type: string) {\n    this._heldEvents[type] = [];\n  }\n}\n\nexport default EventHolder;\n"]},"metadata":{},"sourceType":"module"}