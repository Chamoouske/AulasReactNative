{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nvar os_1 = require(\"os\");\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar xml2js_1 = require(\"xml2js\");\n\nfunction logXMLString(doc) {\n  var builder = new xml2js_1.Builder();\n  var xmlInput = builder.buildObject(doc);\n  console.log(xmlInput);\n}\n\nexports.logXMLString = logXMLString;\n\nfunction writeXMLAsync(options) {\n  var xml;\n  return _regeneratorRuntime.async(function writeXMLAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          xml = new xml2js_1.Builder().buildObject(options.xml);\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.ensureDir(path_1.default.dirname(options.path)));\n\n        case 3:\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.writeFile(options.path, xml));\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.writeXMLAsync = writeXMLAsync;\n\nfunction removeFileIfExists(filePath) {\n  return _regeneratorRuntime.async(function removeFileIfExists$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.pathExists(filePath));\n\n        case 2:\n          if (!_context2.sent) {\n            _context2.next = 5;\n            break;\n          }\n\n          _context2.next = 5;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.unlink(filePath));\n\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction hasResources(xml) {\n  return Array.isArray(xml.resources) && !!xml.resources.length;\n}\n\nfunction writeXMLOrRemoveFileUponNoResourcesAsync(filePath, xml) {\n  var _ref,\n      disregardComments,\n      _args3 = arguments;\n\n  return _regeneratorRuntime.async(function writeXMLOrRemoveFileUponNoResourcesAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _ref = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {}, disregardComments = _ref.disregardComments;\n\n          if (!hasResources(xml)) {\n            _context3.next = 6;\n            break;\n          }\n\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(writeXMLAsync({\n            path: filePath,\n            xml: xml\n          }));\n\n        case 4:\n          _context3.next = 8;\n          break;\n\n        case 6:\n          _context3.next = 8;\n          return _regeneratorRuntime.awrap(removeFileIfExists(filePath));\n\n        case 8:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.writeXMLOrRemoveFileUponNoResourcesAsync = writeXMLOrRemoveFileUponNoResourcesAsync;\n\nfunction readXMLAsync(options) {\n  var contents, parser, manifest;\n  return _regeneratorRuntime.async(function readXMLAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          contents = '';\n          _context4.prev = 1;\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.readFile(options.path, {\n            encoding: 'utf8',\n            flag: 'r'\n          }));\n\n        case 4:\n          contents = _context4.sent;\n          _context4.next = 9;\n          break;\n\n        case 7:\n          _context4.prev = 7;\n          _context4.t0 = _context4[\"catch\"](1);\n\n        case 9:\n          parser = new xml2js_1.Parser();\n          _context4.next = 12;\n          return _regeneratorRuntime.awrap(parser.parseStringPromise(contents || options.fallback || ''));\n\n        case 12:\n          manifest = _context4.sent;\n          return _context4.abrupt(\"return\", manifest);\n\n        case 14:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 7]], Promise);\n}\n\nexports.readXMLAsync = readXMLAsync;\n\nvar stringTimesN = function stringTimesN(n, char) {\n  return Array(n + 1).join(char);\n};\n\nfunction format(manifest) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$indentLevel = _ref2.indentLevel,\n      indentLevel = _ref2$indentLevel === void 0 ? 2 : _ref2$indentLevel,\n      _ref2$newline = _ref2.newline,\n      newline = _ref2$newline === void 0 ? os_1.EOL : _ref2$newline;\n\n  var xmlInput;\n\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    var builder = new xml2js_1.Builder({\n      headless: true\n    });\n    xmlInput = builder.buildObject(manifest);\n    return xmlInput;\n  } else {\n    throw new Error(\"Invalid XML value passed in: \" + manifest);\n  }\n\n  var indentString = stringTimesN(indentLevel, ' ');\n  var formatted = '';\n  var regex = /(>)(<)(\\/*)/g;\n  var xml = xmlInput.replace(regex, \"$1\" + newline + \"$2$3\");\n  var pad = 0;\n  xml.split(/\\r?\\n/).map(function (line) {\n    return line.trim();\n  }).forEach(function (line) {\n    var indent = 0;\n\n    if (line.match(/.+<\\/\\w[^>]*>$/)) {\n      indent = 0;\n    } else if (line.match(/^<\\/\\w/)) {\n      if (pad !== 0) {\n        pad -= 1;\n      }\n    } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n      indent = 1;\n    } else {\n      indent = 0;\n    }\n\n    var padding = stringTimesN(pad, indentString);\n    formatted += padding + line + newline;\n    pad += indent;\n  });\n  return formatted.trim();\n}\n\nexports.format = format;","map":{"version":3,"sources":["../../src/utils/XML.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport { EOL } from 'os';\nimport path from 'path';\nimport { Builder, Parser } from 'xml2js';\n\nexport type XMLValue = boolean | number | string | null | XMLArray | XMLObject;\n\nexport interface XMLArray extends Array<XMLValue> {}\n\nexport interface XMLObject {\n  [key: string]: XMLValue | undefined;\n}\n\nexport function logXMLString(doc: XMLObject) {\n  const builder = new Builder();\n  const xmlInput = builder.buildObject(doc);\n  console.log(xmlInput);\n}\n\nexport async function writeXMLAsync(options: { path: string; xml: any }): Promise<void> {\n  const xml = new Builder().buildObject(options.xml);\n  await fs.ensureDir(path.dirname(options.path));\n  await fs.writeFile(options.path, xml);\n}\n\nasync function removeFileIfExists(filePath: string) {\n  if (await fs.pathExists(filePath)) {\n    await fs.unlink(filePath);\n  }\n}\n\nfunction hasResources(xml: XMLObject): boolean {\n  return Array.isArray(xml.resources) && !!xml.resources.length;\n}\n\nexport async function writeXMLOrRemoveFileUponNoResourcesAsync(\n  filePath: string,\n  xml: XMLObject,\n  { disregardComments }: { disregardComments?: boolean } = {}\n) {\n  if (hasResources(xml)) {\n    await writeXMLAsync({ path: filePath, xml });\n  } else {\n    await removeFileIfExists(filePath);\n  }\n}\n\nexport async function readXMLAsync(options: {\n  path: string;\n  fallback?: string | null;\n}): Promise<XMLObject> {\n  let contents: string = '';\n  try {\n    contents = await fs.readFile(options.path, { encoding: 'utf8', flag: 'r' });\n  } catch {\n    // catch and use fallback\n  }\n  const parser = new Parser();\n  const manifest = await parser.parseStringPromise(contents || options.fallback || '');\n  return manifest;\n}\n\nconst stringTimesN = (n: number, char: string) => Array(n + 1).join(char);\n\nexport function format(manifest: any, { indentLevel = 2, newline = EOL } = {}): string {\n  let xmlInput: string;\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    const builder = new Builder({ headless: true });\n    xmlInput = builder.buildObject(manifest);\n    return xmlInput;\n  } else {\n    throw new Error(`Invalid XML value passed in: ${manifest}`);\n  }\n  const indentString = stringTimesN(indentLevel, ' ');\n\n  let formatted = '';\n  const regex = /(>)(<)(\\/*)/g;\n  const xml = xmlInput.replace(regex, `$1${newline}$2$3`);\n  let pad = 0;\n  xml\n    .split(/\\r?\\n/)\n    .map((line: string) => line.trim())\n    .forEach((line: string) => {\n      let indent = 0;\n      if (line.match(/.+<\\/\\w[^>]*>$/)) {\n        indent = 0;\n      } else if (line.match(/^<\\/\\w/)) {\n        // Somehow istanbul doesn't see the else case as covered, although it is. Skip it.\n        /* istanbul ignore else  */\n        if (pad !== 0) {\n          pad -= 1;\n        }\n      } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n        indent = 1;\n      } else {\n        indent = 0;\n      }\n\n      const padding = stringTimesN(pad, indentString);\n      formatted += padding + line + newline; // eslint-disable-line prefer-template\n      pad += indent;\n    });\n\n  return formatted.trim();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}