{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar XML_1 = require(\"../utils/XML\");\n\nvar Paths_1 = require(\"./Paths\");\n\nfunction getSchemesFromXcodeproj(projectRoot) {\n  return Paths_1.findSchemeNames(projectRoot);\n}\n\nexports.getSchemesFromXcodeproj = getSchemesFromXcodeproj;\n\nfunction getApplicationTargetForSchemeAsync(projectRoot, scheme) {\n  var _a, _b, _c, _d, _e, allSchemePaths, re, schemePath, schemeXML, buildActionEntry, targetName, schemeRelativePath;\n\n  return _regeneratorRuntime.async(function getApplicationTargetForSchemeAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          allSchemePaths = Paths_1.findSchemePaths(projectRoot);\n          re = new RegExp(\"/\" + scheme + \".xcscheme\");\n          schemePath = allSchemePaths.find(function (i) {\n            return re.exec(i);\n          });\n\n          if (schemePath) {\n            _context.next = 5;\n            break;\n          }\n\n          throw new Error(\"scheme '\" + scheme + \"' does not exist\");\n\n        case 5:\n          _context.next = 7;\n          return _regeneratorRuntime.awrap(XML_1.readXMLAsync({\n            path: schemePath\n          }));\n\n        case 7:\n          schemeXML = _context.sent;\n          buildActionEntry = (_e = (_d = (_c = (_b = (_a = schemeXML.Scheme) === null || _a === void 0 ? void 0 : _a.BuildAction) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.BuildActionEntries) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.BuildActionEntry;\n          targetName = (buildActionEntry === null || buildActionEntry === void 0 ? void 0 : buildActionEntry.length) === 1 ? getBlueprintName(buildActionEntry[0]) : getBlueprintName(buildActionEntry === null || buildActionEntry === void 0 ? void 0 : buildActionEntry.find(function (entry) {\n            var _a, _b, _c, _d;\n\n            return (_d = (_c = (_b = (_a = entry.BuildableReference) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b['$']) === null || _c === void 0 ? void 0 : _c.BuildableName) === null || _d === void 0 ? void 0 : _d.endsWith('.app');\n          }));\n\n          if (targetName) {\n            _context.next = 13;\n            break;\n          }\n\n          schemeRelativePath = path_1.default.relative(projectRoot, schemePath);\n          throw new Error(schemeRelativePath + \" seems to be corrupted\");\n\n        case 13:\n          return _context.abrupt(\"return\", targetName);\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.getApplicationTargetForSchemeAsync = getApplicationTargetForSchemeAsync;\n\nfunction getBlueprintName(entry) {\n  var _a, _b, _c;\n\n  return (_c = (_b = (_a = entry === null || entry === void 0 ? void 0 : entry.BuildableReference) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b['$']) === null || _c === void 0 ? void 0 : _c.BlueprintName;\n}","map":{"version":3,"sources":["../../src/ios/BuildScheme.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;AAEA,IAAA,KAAA,GAAA,OAAA,gBAAA;;AACA,IAAA,OAAA,GAAA,OAAA,WAAA;;AAqBA,SAAgB,uBAAhB,CAAwC,WAAxC,EAA2D;AACzD,SAAO,OAAA,CAAA,eAAA,CAAgB,WAAhB,CAAP;AACD;;AAFD,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAIO,SAAe,kCAAf,CACL,WADK,EAEL,MAFK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIC,UAAA,cAJD,GAIkB,OAAA,CAAA,eAAA,CAAgB,WAAhB,CAJlB;AAKC,UAAA,EALD,GAKM,IAAI,MAAJ,OAAe,MAAf,eALN;AAMC,UAAA,UAND,GAMc,cAAc,CAAC,IAAf,CAAoB,UAAA,CAAC;AAAA,mBAAI,EAAE,CAAC,IAAH,CAAQ,CAAR,CAAJ;AAAA,WAArB,CANd;;AAAA,cAOA,UAPA;AAAA;AAAA;AAAA;;AAAA,gBAQG,IAAI,KAAJ,cAAqB,MAArB,sBARH;;AAAA;AAAA;AAAA,2CAWqB,KAAA,CAAA,YAAA,CAAa;AAAE,YAAA,IAAI,EAAE;AAAR,WAAb,CAXrB;;AAAA;AAWC,UAAA,SAXD;AAYC,UAAA,gBAZD,GAYiB,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GACpB,SAAS,CAAC,MADU,MACJ,IADI,IACJ,EAAA,KAAA,KAAA,CADI,GACJ,KAAA,CADI,GACJ,EAAA,CAAE,WADE,MACS,IADT,IACS,EAAA,KAAA,KAAA,CADT,GACS,KAAA,CADT,GACS,EAAA,CAAG,CAAH,CADT,MACa,IADb,IACa,EAAA,KAAA,KAAA,CADb,GACa,KAAA,CADb,GACa,EAAA,CAAG,kBADhB,MACkC,IADlC,IACkC,EAAA,KAAA,KAAA,CADlC,GACkC,KAAA,CADlC,GACkC,EAAA,CAAG,CAAH,CADlC,MACsC,IADtC,IACsC,EAAA,KAAA,KAAA,CADtC,GACsC,KAAA,CADtC,GACsC,EAAA,CAAG,gBAb1D;AAcC,UAAA,UAdD,GAeH,CAAA,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,MAAlB,MAA6B,CAA7B,GACI,gBAAgB,CAAC,gBAAgB,CAAC,CAAD,CAAjB,CADpB,GAEI,gBAAgB,CACd,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,IAAlB,CAAuB,UAAA,KAAK,EAAG;;;AAC7B,mBAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAO,KAAK,CAAC,kBAAb,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,KAAA,CAA/B,GAA+B,EAAA,CAAG,CAAH,CAA/B,MAAmC,IAAnC,IAAmC,EAAA,KAAA,KAAA,CAAnC,GAAmC,KAAA,CAAnC,GAAmC,EAAA,CAAI,GAAJ,CAAnC,MAA0C,IAA1C,IAA0C,EAAA,KAAA,KAAA,CAA1C,GAA0C,KAAA,CAA1C,GAA0C,EAAA,CAAG,aAA7C,MAA0D,IAA1D,IAA0D,EAAA,KAAA,KAAA,CAA1D,GAA0D,KAAA,CAA1D,GAA0D,EAAA,CAAE,QAAF,CAAW,MAAX,CAA1D;AACD,WAFD,CADc,CAjBjB;;AAAA,cAsBA,UAtBA;AAAA;AAAA;AAAA;;AAuBG,UAAA,kBAvBH,GAuBwB,MAAA,CAAA,OAAA,CAAK,QAAL,CAAc,WAAd,EAA2B,UAA3B,CAvBxB;AAAA,gBAwBG,IAAI,KAAJ,CAAa,kBAAb,4BAxBH;;AAAA;AAAA,2CA0BE,UA1BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAP,OAAA,CAAA,kCAAA,GAAA,kCAAA;;AA6BA,SAAS,gBAAT,CAA0B,KAA1B,EAAsD;;;AACpD,SAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAO,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,kBAAd,MAAgC,IAAhC,IAAgC,EAAA,KAAA,KAAA,CAAhC,GAAgC,KAAA,CAAhC,GAAgC,EAAA,CAAG,CAAH,CAAhC,MAAoC,IAApC,IAAoC,EAAA,KAAA,KAAA,CAApC,GAAoC,KAAA,CAApC,GAAoC,EAAA,CAAI,GAAJ,CAApC,MAA2C,IAA3C,IAA2C,EAAA,KAAA,KAAA,CAA3C,GAA2C,KAAA,CAA3C,GAA2C,EAAA,CAAG,aAA9C;AACD","sourcesContent":["import path from 'path';\n\nimport { readXMLAsync } from '../utils/XML';\nimport { findSchemeNames, findSchemePaths } from './Paths';\n\ninterface SchemeXML {\n  Scheme?: {\n    BuildAction?: {\n      BuildActionEntries?: {\n        BuildActionEntry?: BuildActionEntryType[];\n      }[];\n    }[];\n  };\n}\n\ninterface BuildActionEntryType {\n  BuildableReference?: {\n    $?: {\n      BlueprintName?: string;\n      BuildableName?: string;\n    };\n  }[];\n}\n\nexport function getSchemesFromXcodeproj(projectRoot: string): string[] {\n  return findSchemeNames(projectRoot);\n}\n\nexport async function getApplicationTargetForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const allSchemePaths = findSchemePaths(projectRoot);\n  const re = new RegExp(`/${scheme}.xcscheme`);\n  const schemePath = allSchemePaths.find(i => re.exec(i));\n  if (!schemePath) {\n    throw new Error(`scheme '${scheme}' does not exist`);\n  }\n\n  const schemeXML = ((await readXMLAsync({ path: schemePath })) as unknown) as SchemeXML;\n  const buildActionEntry =\n    schemeXML.Scheme?.BuildAction?.[0]?.BuildActionEntries?.[0]?.BuildActionEntry;\n  const targetName =\n    buildActionEntry?.length === 1\n      ? getBlueprintName(buildActionEntry[0])\n      : getBlueprintName(\n          buildActionEntry?.find(entry => {\n            return entry.BuildableReference?.[0]?.['$']?.BuildableName?.endsWith('.app');\n          })\n        );\n  if (!targetName) {\n    const schemeRelativePath = path.relative(projectRoot, schemePath);\n    throw new Error(`${schemeRelativePath} seems to be corrupted`);\n  }\n  return targetName;\n}\n\nfunction getBlueprintName(entry?: BuildActionEntryType): string | undefined {\n  return entry?.BuildableReference?.[0]?.['$']?.BlueprintName;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}