{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Writable } from 'stream';\nimport { GeneratedHeader } from \"./GeneratedHeader\";\nimport { Property } from \"./Property\";\nimport { PropsType, Type } from \"./Type\";\nimport { Command } from \"./Command\";\nimport { Event } from \"./Event\";\nimport { toCppNamespace } from \"./Converters\";\nexport var HeaderWriter = function () {\n  function HeaderWriter(stream, types, commands, events) {\n    _classCallCheck(this, HeaderWriter);\n\n    this.stream = stream;\n    this.types = types;\n    this.commands = commands;\n    this.events = events;\n  }\n\n  _createClass(HeaderWriter, [{\n    key: \"write\",\n    value: function write() {\n      this.writePrologue();\n      this.writeForwardDecls();\n      this.writeRequestHandlerDecls();\n      this.writeTypeDecls();\n      this.writeRequestDecls();\n      this.writeResponseDecls();\n      this.writeNotificationDecls();\n      this.writeEpilogue();\n    }\n  }, {\n    key: \"writePrologue\",\n    value: function writePrologue() {\n      this.stream.write(GeneratedHeader + \"\\n\\n      #pragma once\\n\\n      #include <hermes/inspector/chrome/MessageInterfaces.h>\\n\\n      #include <vector>\\n\\n      #include <folly/Optional.h>\\n\\n      namespace facebook {\\n      namespace hermes {\\n      namespace inspector {\\n      namespace chrome {\\n      namespace message {\\n\\n    \");\n    }\n  }, {\n    key: \"writeForwardDecls\",\n    value: function writeForwardDecls() {\n      this.stream.write('struct UnknownRequest;\\n\\n');\n      var namespaceMap = new Map();\n\n      var addToMap = function addToMap(type) {\n        var domain = type.domain;\n        var types = namespaceMap.get(domain);\n\n        if (!types) {\n          types = [];\n          namespaceMap.set(domain, types);\n        }\n\n        types.push(type);\n      };\n\n      this.types.forEach(addToMap);\n      this.commands.forEach(addToMap);\n      this.events.forEach(addToMap);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(namespaceMap), _step; !(_step = _iterator()).done;) {\n        var _ref = _step.value;\n\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var domain = _ref2[0];\n        var types = _ref2[1];\n        types.sort(function (a, b) {\n          var nameA = a.getForwardDeclSortKey();\n          var nameB = b.getForwardDeclSortKey();\n          return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;\n        });\n        var ns = toCppNamespace(domain);\n        this.stream.write(\"namespace \" + ns + \" {\\n\");\n\n        for (var _iterator2 = _createForOfIteratorHelperLoose(types), _step2; !(_step2 = _iterator2()).done;) {\n          var type = _step2.value;\n\n          for (var _iterator3 = _createForOfIteratorHelperLoose(type.getForwardDecls()), _step3; !(_step3 = _iterator3()).done;) {\n            var decl = _step3.value;\n            this.stream.write(decl + \"\\n\");\n          }\n        }\n\n        this.stream.write(\"} // namespace \" + ns + \"\\n\\n\");\n      }\n    }\n  }, {\n    key: \"writeRequestHandlerDecls\",\n    value: function writeRequestHandlerDecls() {\n      this.stream.write('\\n/// RequestHandler handles requests via the visitor pattern.\\n');\n      emitRequestHandlerDecl(this.stream, this.commands);\n      this.stream.write('\\n/// NoopRequestHandler can be subclassed to only handle some requests.\\n');\n      emitNoopRequestHandlerDecl(this.stream, this.commands);\n    }\n  }, {\n    key: \"writeTypeDecls\",\n    value: function writeTypeDecls() {\n      this.stream.write('\\n/// Types\\n');\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(this.types), _step4; !(_step4 = _iterator4()).done;) {\n        var type = _step4.value;\n\n        if (type instanceof PropsType) {\n          emitTypeDecl(this.stream, type);\n        }\n      }\n    }\n  }, {\n    key: \"writeRequestDecls\",\n    value: function writeRequestDecls() {\n      this.stream.write('\\n/// Requests\\n');\n      emitUnknownRequestDecl(this.stream);\n\n      for (var _iterator5 = _createForOfIteratorHelperLoose(this.commands), _step5; !(_step5 = _iterator5()).done;) {\n        var command = _step5.value;\n        emitRequestDecl(this.stream, command);\n      }\n    }\n  }, {\n    key: \"writeResponseDecls\",\n    value: function writeResponseDecls() {\n      this.stream.write('\\n/// Responses\\n');\n      emitErrorResponseDecl(this.stream);\n      emitOkResponseDecl(this.stream);\n\n      for (var _iterator6 = _createForOfIteratorHelperLoose(this.commands), _step6; !(_step6 = _iterator6()).done;) {\n        var command = _step6.value;\n        emitResponseDecl(this.stream, command);\n      }\n    }\n  }, {\n    key: \"writeNotificationDecls\",\n    value: function writeNotificationDecls() {\n      this.stream.write('\\n/// Notifications\\n');\n\n      for (var _iterator7 = _createForOfIteratorHelperLoose(this.events), _step7; !(_step7 = _iterator7()).done;) {\n        var event = _step7.value;\n        emitNotificationDecl(this.stream, event);\n      }\n    }\n  }, {\n    key: \"writeEpilogue\",\n    value: function writeEpilogue() {\n      this.stream.write(\"\\n        } // namespace message\\n        } // namespace chrome\\n        } // namespace inspector\\n        } // namespace hermes\\n        } // namespace facebook\\n    \");\n    }\n  }]);\n\n  return HeaderWriter;\n}();\n\nfunction emitRequestHandlerDecl(stream, commands) {\n  stream.write(\"struct RequestHandler {\\n    virtual ~RequestHandler() = default;\\n\\n    virtual void handle(const UnknownRequest &req) = 0;\\n  \");\n\n  for (var _iterator8 = _createForOfIteratorHelperLoose(commands), _step8; !(_step8 = _iterator8()).done;) {\n    var command = _step8.value;\n    var cppNs = command.getCppNamespace();\n    var cppType = command.getRequestCppType();\n    stream.write(\"virtual void handle(const \" + cppNs + \"::\" + cppType + \" &req) = 0;\");\n  }\n\n  stream.write('};\\n');\n}\n\nfunction emitNoopRequestHandlerDecl(stream, commands) {\n  stream.write(\"struct NoopRequestHandler : public RequestHandler {\\n    void handle(const UnknownRequest &req) override {}\\n  \");\n\n  for (var _iterator9 = _createForOfIteratorHelperLoose(commands), _step9; !(_step9 = _iterator9()).done;) {\n    var command = _step9.value;\n    var cppNs = command.getCppNamespace();\n    var cppType = command.getRequestCppType();\n    stream.write(\"void handle(const \" + cppNs + \"::\" + cppType + \" &req) override {}\");\n  }\n\n  stream.write('};\\n');\n}\n\nfunction emitProps(stream, props) {\n  if (!props || props.length === 0) {\n    return;\n  }\n\n  stream.write('\\n');\n\n  for (var _iterator10 = _createForOfIteratorHelperLoose(props), _step10; !(_step10 = _iterator10()).done;) {\n    var prop = _step10.value;\n    var fullCppType = prop.getFullCppType();\n    var cppId = prop.getCppIdentifier();\n    var init = prop.getInitializer();\n    stream.write(\"  \" + fullCppType + \" \" + cppId + init + \";\\n\");\n  }\n}\n\nexport function emitTypeDecl(stream, type) {\n  var cppNs = type.getCppNamespace();\n  var cppType = type.getCppType();\n  stream.write(\"struct \" + cppNs + \"::\" + cppType + \" : public Serializable {\\n    \" + cppType + \"() = default;\\n    explicit \" + cppType + \"(const folly::dynamic &obj);\\n    folly::dynamic toDynamic() const override;\\n  \");\n\n  if (type instanceof PropsType) {\n    emitProps(stream, type.properties);\n  }\n\n  stream.write('};\\n\\n');\n}\n\nfunction emitUnknownRequestDecl(stream) {\n  stream.write(\"struct UnknownRequest : public Request {\\n    UnknownRequest();\\n    explicit UnknownRequest(const folly::dynamic &obj);\\n\\n    folly::dynamic toDynamic() const override;\\n    void accept(RequestHandler &handler) const override;\\n\\n    folly::Optional<folly::dynamic> params;\\n  };\\n\\n  \");\n}\n\nexport function emitRequestDecl(stream, command) {\n  var cppNs = command.getCppNamespace();\n  var cppType = command.getRequestCppType();\n  stream.write(\"struct \" + cppNs + \"::\" + cppType + \" : public Request {\\n    \" + cppType + \"();\\n    explicit \" + cppType + \"(const folly::dynamic &obj);\\n\\n    folly::dynamic toDynamic() const override;\\n    void accept(RequestHandler &handler) const override;\\n  \");\n  emitProps(stream, command.parameters);\n  stream.write('};\\n\\n');\n}\n\nfunction emitErrorResponseDecl(stream) {\n  stream.write(\"struct ErrorResponse : public Response {\\n    ErrorResponse() = default;\\n    explicit ErrorResponse(const folly::dynamic &obj);\\n    folly::dynamic toDynamic() const override;\\n\\n    int code;\\n    std::string message;\\n    folly::Optional<folly::dynamic> data;\\n  };\\n\\n  \");\n}\n\nfunction emitOkResponseDecl(stream) {\n  stream.write(\"struct OkResponse : public Response {\\n    OkResponse() = default;\\n    explicit OkResponse(const folly::dynamic &obj);\\n    folly::dynamic toDynamic() const override;\\n  };\\n\\n  \");\n}\n\nexport function emitResponseDecl(stream, command) {\n  var cppNs = command.getCppNamespace();\n  var cppType = command.getResponseCppType();\n\n  if (!cppType) {\n    return;\n  }\n\n  stream.write(\"struct \" + cppNs + \"::\" + cppType + \" : public Response {\\n    \" + cppType + \"() = default;\\n    explicit \" + cppType + \"(const folly::dynamic &obj);\\n    folly::dynamic toDynamic() const override;\\n  \");\n  emitProps(stream, command.returns);\n  stream.write('};\\n\\n');\n}\nexport function emitNotificationDecl(stream, event) {\n  var cppNs = event.getCppNamespace();\n  var cppType = event.getCppType();\n  stream.write(\"struct \" + cppNs + \"::\" + cppType + \" : public Notification {\\n    \" + cppType + \"();\\n    explicit \" + cppType + \"(const folly::dynamic &obj);\\n    folly::dynamic toDynamic() const override;\\n  \");\n  emitProps(stream, event.parameters);\n  stream.write('};\\n\\n');\n}","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/ReactCommon/hermes/inspector/tools/msggen/src/HeaderWriter.js"],"names":["Writable","GeneratedHeader","Property","PropsType","Type","Command","Event","toCppNamespace","HeaderWriter","stream","types","commands","events","writePrologue","writeForwardDecls","writeRequestHandlerDecls","writeTypeDecls","writeRequestDecls","writeResponseDecls","writeNotificationDecls","writeEpilogue","write","namespaceMap","Map","addToMap","type","domain","get","set","push","forEach","sort","a","b","nameA","getForwardDeclSortKey","nameB","ns","getForwardDecls","decl","emitRequestHandlerDecl","emitNoopRequestHandlerDecl","emitTypeDecl","emitUnknownRequestDecl","command","emitRequestDecl","emitErrorResponseDecl","emitOkResponseDecl","emitResponseDecl","event","emitNotificationDecl","cppNs","getCppNamespace","cppType","getRequestCppType","emitProps","props","length","prop","fullCppType","getFullCppType","cppId","getCppIdentifier","init","getInitializer","getCppType","properties","parameters","getResponseCppType","returns"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport {Writable} from 'stream';\n\nimport {GeneratedHeader} from './GeneratedHeader';\nimport {Property} from './Property';\nimport {PropsType, Type} from './Type';\nimport {Command} from './Command';\nimport {Event} from './Event';\nimport {toCppNamespace} from './Converters';\n\nexport class HeaderWriter {\n  stream: Writable;\n  types: Array<Type>;\n  commands: Array<Command>;\n  events: Array<Event>;\n\n  constructor(\n    stream: Writable,\n    types: Array<Type>,\n    commands: Array<Command>,\n    events: Array<Event>,\n  ) {\n    this.stream = stream;\n    this.types = types;\n    this.commands = commands;\n    this.events = events;\n  }\n\n  write() {\n    this.writePrologue();\n    this.writeForwardDecls();\n    this.writeRequestHandlerDecls();\n    this.writeTypeDecls();\n    this.writeRequestDecls();\n    this.writeResponseDecls();\n    this.writeNotificationDecls();\n    this.writeEpilogue();\n  }\n\n  writePrologue() {\n    this.stream.write(`${GeneratedHeader}\n\n      #pragma once\n\n      #include <hermes/inspector/chrome/MessageInterfaces.h>\n\n      #include <vector>\n\n      #include <folly/Optional.h>\n\n      namespace facebook {\n      namespace hermes {\n      namespace inspector {\n      namespace chrome {\n      namespace message {\n\n    `);\n  }\n\n  writeForwardDecls() {\n    this.stream.write('struct UnknownRequest;\\n\\n');\n\n    const namespaceMap: Map<string, Array<Type | Command | Event>> = new Map();\n    const addToMap = function(type) {\n      const domain = type.domain;\n      let types = namespaceMap.get(domain);\n      if (!types) {\n        types = [];\n        namespaceMap.set(domain, types);\n      }\n      types.push(type);\n    };\n\n    this.types.forEach(addToMap);\n    this.commands.forEach(addToMap);\n    this.events.forEach(addToMap);\n\n    for (const [domain, types] of namespaceMap) {\n      types.sort((a, b) => {\n        const nameA = a.getForwardDeclSortKey();\n        const nameB = b.getForwardDeclSortKey();\n        return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;\n      });\n\n      const ns = toCppNamespace(domain);\n      this.stream.write(`namespace ${ns} {\\n`);\n\n      for (const type of types) {\n        for (const decl of type.getForwardDecls()) {\n          this.stream.write(`${decl}\\n`);\n        }\n      }\n\n      this.stream.write(`} // namespace ${ns}\\n\\n`);\n    }\n  }\n\n  writeRequestHandlerDecls() {\n    this.stream.write(\n      '\\n/// RequestHandler handles requests via the visitor pattern.\\n',\n    );\n    emitRequestHandlerDecl(this.stream, this.commands);\n\n    this.stream.write(\n      '\\n/// NoopRequestHandler can be subclassed to only handle some requests.\\n',\n    );\n    emitNoopRequestHandlerDecl(this.stream, this.commands);\n  }\n\n  writeTypeDecls() {\n    this.stream.write('\\n/// Types\\n');\n\n    for (const type of this.types) {\n      if (type instanceof PropsType) {\n        emitTypeDecl(this.stream, type);\n      }\n    }\n  }\n\n  writeRequestDecls() {\n    this.stream.write('\\n/// Requests\\n');\n\n    emitUnknownRequestDecl(this.stream);\n\n    for (const command of this.commands) {\n      emitRequestDecl(this.stream, command);\n    }\n  }\n\n  writeResponseDecls() {\n    this.stream.write('\\n/// Responses\\n');\n\n    emitErrorResponseDecl(this.stream);\n    emitOkResponseDecl(this.stream);\n\n    for (const command of this.commands) {\n      emitResponseDecl(this.stream, command);\n    }\n  }\n\n  writeNotificationDecls() {\n    this.stream.write('\\n/// Notifications\\n');\n\n    for (const event of this.events) {\n      emitNotificationDecl(this.stream, event);\n    }\n  }\n\n  writeEpilogue() {\n    this.stream.write(`\n        } // namespace message\n        } // namespace chrome\n        } // namespace inspector\n        } // namespace hermes\n        } // namespace facebook\n    `);\n  }\n}\n\nfunction emitRequestHandlerDecl(stream: Writable, commands: Array<Command>) {\n  stream.write(`struct RequestHandler {\n    virtual ~RequestHandler() = default;\n\n    virtual void handle(const UnknownRequest &req) = 0;\n  `);\n\n  for (const command of commands) {\n    const cppNs = command.getCppNamespace();\n    const cppType = command.getRequestCppType();\n\n    stream.write(`virtual void handle(const ${cppNs}::${cppType} &req) = 0;`);\n  }\n\n  stream.write('};\\n');\n}\n\nfunction emitNoopRequestHandlerDecl(\n  stream: Writable,\n  commands: Array<Command>,\n) {\n  stream.write(`struct NoopRequestHandler : public RequestHandler {\n    void handle(const UnknownRequest &req) override {}\n  `);\n\n  for (const command of commands) {\n    const cppNs = command.getCppNamespace();\n    const cppType = command.getRequestCppType();\n\n    stream.write(`void handle(const ${cppNs}::${cppType} &req) override {}`);\n  }\n\n  stream.write('};\\n');\n}\n\nfunction emitProps(stream: Writable, props: ?Array<Property>) {\n  if (!props || props.length === 0) {\n    return;\n  }\n\n  stream.write('\\n');\n\n  for (const prop of props) {\n    const fullCppType = prop.getFullCppType();\n    const cppId = prop.getCppIdentifier();\n    const init = prop.getInitializer();\n\n    stream.write(`  ${fullCppType} ${cppId}${init};\\n`);\n  }\n}\n\nexport function emitTypeDecl(stream: Writable, type: PropsType) {\n  const cppNs = type.getCppNamespace();\n  const cppType = type.getCppType();\n\n  stream.write(`struct ${cppNs}::${cppType} : public Serializable {\n    ${cppType}() = default;\n    explicit ${cppType}(const folly::dynamic &obj);\n    folly::dynamic toDynamic() const override;\n  `);\n\n  if (type instanceof PropsType) {\n    emitProps(stream, type.properties);\n  }\n\n  stream.write('};\\n\\n');\n}\n\nfunction emitUnknownRequestDecl(stream: Writable) {\n  stream.write(`struct UnknownRequest : public Request {\n    UnknownRequest();\n    explicit UnknownRequest(const folly::dynamic &obj);\n\n    folly::dynamic toDynamic() const override;\n    void accept(RequestHandler &handler) const override;\n\n    folly::Optional<folly::dynamic> params;\n  };\n\n  `);\n}\n\nexport function emitRequestDecl(stream: Writable, command: Command) {\n  const cppNs = command.getCppNamespace();\n  const cppType = command.getRequestCppType();\n\n  stream.write(`struct ${cppNs}::${cppType} : public Request {\n    ${cppType}();\n    explicit ${cppType}(const folly::dynamic &obj);\n\n    folly::dynamic toDynamic() const override;\n    void accept(RequestHandler &handler) const override;\n  `);\n\n  emitProps(stream, command.parameters);\n\n  stream.write('};\\n\\n');\n}\n\nfunction emitErrorResponseDecl(stream: Writable) {\n  stream.write(`struct ErrorResponse : public Response {\n    ErrorResponse() = default;\n    explicit ErrorResponse(const folly::dynamic &obj);\n    folly::dynamic toDynamic() const override;\n\n    int code;\n    std::string message;\n    folly::Optional<folly::dynamic> data;\n  };\n\n  `);\n}\n\nfunction emitOkResponseDecl(stream: Writable) {\n  stream.write(`struct OkResponse : public Response {\n    OkResponse() = default;\n    explicit OkResponse(const folly::dynamic &obj);\n    folly::dynamic toDynamic() const override;\n  };\n\n  `);\n}\n\nexport function emitResponseDecl(stream: Writable, command: Command) {\n  const cppNs = command.getCppNamespace();\n  const cppType = command.getResponseCppType();\n  if (!cppType) {\n    return;\n  }\n\n  stream.write(`struct ${cppNs}::${cppType} : public Response {\n    ${cppType}() = default;\n    explicit ${cppType}(const folly::dynamic &obj);\n    folly::dynamic toDynamic() const override;\n  `);\n\n  emitProps(stream, command.returns);\n\n  stream.write('};\\n\\n');\n}\n\nexport function emitNotificationDecl(stream: Writable, event: Event) {\n  const cppNs = event.getCppNamespace();\n  const cppType = event.getCppType();\n\n  stream.write(`struct ${cppNs}::${cppType} : public Notification {\n    ${cppType}();\n    explicit ${cppType}(const folly::dynamic &obj);\n    folly::dynamic toDynamic() const override;\n  `);\n\n  emitProps(stream, event.parameters);\n\n  stream.write('};\\n\\n');\n}\n"]},"metadata":{},"sourceType":"module"}