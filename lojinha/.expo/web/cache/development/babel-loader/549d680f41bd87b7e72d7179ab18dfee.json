{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar chalk_1 = __importDefault(require(\"chalk\"));\n\nvar getenv_1 = require(\"getenv\");\n\nvar errors_1 = require(\"../utils/errors\");\n\nvar history_1 = require(\"../utils/history\");\n\nvar static_plugins_1 = require(\"./static-plugins\");\n\nvar EXPO_DEBUG = getenv_1.boolish('EXPO_DEBUG', false);\n\nexports.withPlugins = function (config, plugins) {\n  errors_1.assert(Array.isArray(plugins), 'withPlugins expected a valid array of plugins or plugin module paths');\n  return plugins.reduce(function (prev, plugin) {\n    return static_plugins_1.withStaticPlugin(prev, {\n      plugin: plugin\n    });\n  }, config);\n};\n\nexports.withRunOnce = function (config, _ref) {\n  var plugin = _ref.plugin,\n      name = _ref.name,\n      version = _ref.version;\n\n  if (history_1.getHistoryItem(config, name)) {\n    return config;\n  }\n\n  config = history_1.addHistoryItem(config, {\n    name: name,\n    version: version\n  });\n  return plugin(config);\n};\n\nfunction createRunOncePlugin(_plugin, name, version) {\n  return function (config, props) {\n    return exports.withRunOnce(config, {\n      plugin: function plugin(config) {\n        return _plugin(config, props);\n      },\n      name: name,\n      version: version\n    });\n  };\n}\n\nexports.createRunOncePlugin = createRunOncePlugin;\n\nexports.withDangerousMod = function (config, _ref2) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n      platform = _ref3[0],\n      action = _ref3[1];\n\n  return withExtendedMod(config, {\n    platform: platform,\n    mod: 'dangerous',\n    action: action\n  });\n};\n\nfunction withExtendedMod(config, _ref4) {\n  var platform = _ref4.platform,\n      mod = _ref4.mod,\n      _action = _ref4.action;\n  return withInterceptedMod(config, {\n    platform: platform,\n    mod: mod,\n    action: function action(_a) {\n      var _b, nextMod, modRequest, modResults, config, results;\n\n      return _regeneratorRuntime.async(function action$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _b = _a.modRequest, nextMod = _b.nextMod, modRequest = __rest(_b, [\"nextMod\"]), modResults = _a.modResults, config = __rest(_a, [\"modRequest\", \"modResults\"]);\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(_action(_extends({\n                modRequest: modRequest,\n                modResults: modResults\n              }, config)));\n\n            case 3:\n              results = _context.sent;\n              return _context.abrupt(\"return\", nextMod(results));\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  });\n}\n\nexports.withExtendedMod = withExtendedMod;\n\nfunction withInterceptedMod(config, _ref5) {\n  var platform = _ref5.platform,\n      mod = _ref5.mod,\n      action = _ref5.action,\n      skipEmptyMod = _ref5.skipEmptyMod;\n\n  var _a, _b;\n\n  if (!config.mods) {\n    config.mods = {};\n  }\n\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  var interceptedMod = config.mods[platform][mod];\n\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      return config;\n    }\n\n    var noopMod = function noopMod(config) {\n      return config;\n    };\n\n    interceptedMod = noopMod;\n  }\n\n  var debugTrace = '';\n  var isDebug = (_b = (_a = config._internal) === null || _a === void 0 ? void 0 : _a.isDebug) !== null && _b !== void 0 ? _b : EXPO_DEBUG;\n\n  if (isDebug) {\n    var stack = new Error().stack;\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n    var modStack = chalk_1.default.bold(platform + \".\" + mod);\n    debugTrace = modStack + \": \" + debugTrace;\n  }\n\n  function interceptingMod(_a) {\n    var modRequest, config;\n    return _regeneratorRuntime.async(function interceptingMod$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            modRequest = _a.modRequest, config = __rest(_a, [\"modRequest\"]);\n\n            if (isDebug) {\n              console.log(debugTrace);\n            }\n\n            return _context2.abrupt(\"return\", action(_extends(_extends({}, config), {\n              modRequest: _extends(_extends({}, modRequest), {\n                nextMod: interceptedMod\n              })\n            })));\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n\n  config.mods[platform][mod] = interceptingMod;\n  return config;\n}\n\nexports.withInterceptedMod = withInterceptedMod;\n\nfunction getDebugPluginStackFromStackTrace(stacktrace) {\n  if (!stacktrace) {\n    return '';\n  }\n\n  var treeStackLines = [];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(stacktrace.split('\\n')), _step; !(_step = _iterator()).done;) {\n    var line = _step.value;\n\n    var _line$trim$split = line.trim().split(' '),\n        _line$trim$split2 = _slicedToArray(_line$trim$split, 2),\n        first = _line$trim$split2[0],\n        second = _line$trim$split2[1];\n\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  var plugins = treeStackLines.map(function (first) {\n    var match = first === null || first === void 0 ? void 0 : first.match(/(\\bwith[A-Z].*?\\b)/g);\n\n    if (match === null || match === void 0 ? void 0 : match.length) {\n      return match[0];\n    }\n\n    return null;\n  }).filter(Boolean);\n\n  if (plugins[0] === 'withInterceptedMod') {\n    plugins.shift();\n  }\n\n  var commonPlugins = ['withPlugins', 'withExtendedMod'];\n  return plugins.reverse().map(function (pluginName, index) {\n    if (pluginName.includes('BaseMod')) {\n      pluginName = chalk_1.default.bold(pluginName);\n    }\n\n    if (pluginName.toLowerCase().includes('danger')) {\n      pluginName = chalk_1.default.red(pluginName);\n    }\n\n    if (index === 0) {\n      return chalk_1.default.blue(pluginName);\n    } else if (commonPlugins.includes(pluginName)) {\n      return chalk_1.default.dim(pluginName);\n    }\n\n    return pluginName;\n  }).join(' ➜ ');\n}","map":{"version":3,"sources":["../../src/plugins/core-plugins.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport { boolish } from 'getenv';\n\nimport {\n  ConfigPlugin,\n  ExportedConfig,\n  ExportedConfigWithProps,\n  Mod,\n  ModPlatform,\n  StaticPlugin,\n} from '../Plugin.types';\nimport { assert } from '../utils/errors';\nimport { addHistoryItem, getHistoryItem, PluginHistoryItem } from '../utils/history';\nimport { withStaticPlugin } from './static-plugins';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\n/**\n * Resolves a list of plugins.\n *\n * @param config exported config\n * @param plugins list of config config plugins to apply to the exported config\n */\nexport const withPlugins: ConfigPlugin<(StaticPlugin | ConfigPlugin | string)[]> = (\n  config,\n  plugins\n) => {\n  assert(\n    Array.isArray(plugins),\n    'withPlugins expected a valid array of plugins or plugin module paths'\n  );\n  return plugins.reduce((prev, plugin) => {\n    return withStaticPlugin(prev, { plugin });\n  }, config);\n};\n\n/**\n * Prevents the same plugin from being run twice.\n * Used for migrating from unversioned expo config plugins to versioned plugins.\n *\n * @param config\n * @param name\n */\nexport const withRunOnce: ConfigPlugin<{\n  plugin: ConfigPlugin<void>;\n  name: PluginHistoryItem['name'];\n  version?: PluginHistoryItem['version'];\n}> = (config, { plugin, name, version }) => {\n  // Detect if a plugin has already been run on this config.\n  if (getHistoryItem(config, name)) {\n    return config;\n  }\n\n  // Push the history item so duplicates cannot be run.\n  config = addHistoryItem(config, { name, version });\n\n  return plugin(config);\n};\n\n/**\n * Helper method for creating mods from existing config functions.\n *\n * @param action\n */\nexport function createRunOncePlugin<T>(\n  plugin: ConfigPlugin<T>,\n  name: string,\n  version?: string\n): ConfigPlugin<T> {\n  return (config, props) => {\n    return withRunOnce(config, { plugin: config => plugin(config, props), name, version });\n  };\n}\n\n/**\n * Mods that don't modify any data, all unresolved functionality is performed inside a dangerous mod.\n * All dangerous mods run first before other mods.\n *\n * @param config\n * @param platform\n * @param action\n */\nexport const withDangerousMod: ConfigPlugin<[ModPlatform, Mod<unknown>]> = (\n  config,\n  [platform, action]\n) => {\n  return withExtendedMod(config, {\n    platform,\n    mod: 'dangerous',\n    action,\n  });\n};\n\n/**\n * Plugin to extend a mod function in the plugins config.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to extend\n * @param action method to run on the mod when the config is compiled\n */\nexport function withExtendedMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n  }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n  }\n): ExportedConfig {\n  return withInterceptedMod(config, {\n    platform,\n    mod,\n    async action({ modRequest: { nextMod, ...modRequest }, modResults, ...config }) {\n      const results = await action({ modRequest, modResults: modResults as T, ...config });\n      return nextMod!(results as any);\n    },\n  });\n}\n\n/**\n * Plugin to intercept execution of a given `mod` with the given `action`.\n * If an action was already set on the given `config` config for `mod`, then it\n * will be provided to the `action` as `nextMod` when it's evaluated, otherwise\n * `nextMod` will be an identity function.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to intercept\n * @param skipEmptyMod should skip running the action if there is no existing mod to intercept\n * @param action method to run on the mod when the config is compiled\n */\nexport function withInterceptedMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n    skipEmptyMod,\n  }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n    skipEmptyMod?: boolean;\n  }\n): ExportedConfig {\n  if (!config.mods) {\n    config.mods = {};\n  }\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  let interceptedMod: Mod<T> = (config.mods[platform] as Record<string, any>)[mod];\n\n  // No existing mod to intercept\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      // Skip running the action\n      return config;\n    }\n    // Use a noop mod and continue\n    const noopMod: Mod<T> = config => config;\n    interceptedMod = noopMod;\n  }\n\n  // Create a stack trace for debugging ahead of time\n  let debugTrace: string = '';\n  // Use the possibly user defined value. Otherwise fallback to the env variable.\n  // We support the env variable because user mods won't have _internal defined in time.\n  const isDebug = config._internal?.isDebug ?? EXPO_DEBUG;\n  if (isDebug) {\n    // Get a stack trace via the Error API\n    const stack = new Error().stack;\n    // Format the stack trace to create the debug log\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n    const modStack = chalk.bold(`${platform}.${mod}`);\n\n    debugTrace = `${modStack}: ${debugTrace}`;\n  }\n\n  async function interceptingMod({ modRequest, ...config }: ExportedConfigWithProps<T>) {\n    if (isDebug) {\n      // In debug mod, log the plugin stack in the order which they were invoked\n      console.log(debugTrace);\n    }\n    return action({ ...config, modRequest: { ...modRequest, nextMod: interceptedMod } });\n  }\n\n  (config.mods[platform] as any)[mod] = interceptingMod;\n\n  return config;\n}\n\nfunction getDebugPluginStackFromStackTrace(stacktrace?: string): string {\n  if (!stacktrace) {\n    return '';\n  }\n\n  const treeStackLines: string[] = [];\n  for (const line of stacktrace.split('\\n')) {\n    const [first, second] = line.trim().split(' ');\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  const plugins = treeStackLines\n    .map(first => {\n      // Match the first part of the stack trace against the plugin naming convention\n      // \"with\" followed by a capital letter.\n      const match = first?.match(/(\\bwith[A-Z].*?\\b)/g);\n      if (match?.length) {\n        // Return the plugin name\n        return match[0];\n      }\n      return null;\n    })\n    .filter(Boolean);\n\n  // redundant as all debug logs are captured in withInterceptedMod\n  if (plugins[0] === 'withInterceptedMod') {\n    plugins.shift();\n  }\n\n  const commonPlugins = ['withPlugins', 'withExtendedMod'];\n\n  return (\n    (plugins as string[])\n      .reverse()\n      .map((pluginName, index) => {\n        // Base mods indicate a logical section.\n        if (pluginName.includes('BaseMod')) {\n          pluginName = chalk.bold(pluginName);\n        }\n        // highlight dangerous mods\n        if (pluginName.toLowerCase().includes('danger')) {\n          pluginName = chalk.red(pluginName);\n        }\n\n        if (index === 0) {\n          return chalk.blue(pluginName);\n        } else if (commonPlugins.includes(pluginName)) {\n          // Common mod names often clutter up the logs, dim them out\n          return chalk.dim(pluginName);\n        }\n        return pluginName;\n      })\n      // Join the results:\n      // withExpoAndroidPlugins ➜ withPlugins ➜ withIcons ➜ withDangerousMod ➜ withExtendedMod\n      .join(' ➜ ')\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}