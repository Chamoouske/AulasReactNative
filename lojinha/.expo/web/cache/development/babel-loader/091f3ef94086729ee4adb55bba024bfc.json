{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar plist_1 = __importDefault(require(\"@expo/plist\"));\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nvar xcode_1 = __importDefault(require(\"xcode\"));\n\nvar core_plugins_1 = require(\"../plugins/core-plugins\");\n\nvar Paths_1 = require(\"./Paths\");\n\nvar Xcodeproj_1 = require(\"./utils/Xcodeproj\");\n\nexports.withBundleIdentifier = function (config, _ref) {\n  var bundleIdentifier = _ref.bundleIdentifier;\n  return core_plugins_1.withDangerousMod(config, ['ios', function _callee(config) {\n    var _a, bundleId;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            bundleId = bundleIdentifier !== null && bundleIdentifier !== void 0 ? bundleIdentifier : (_a = config.ios) === null || _a === void 0 ? void 0 : _a.bundleIdentifier;\n            assert_1.default(bundleId, '`bundleIdentifier` must be defined in the app config (`expo.ios.bundleIdentifier`) or passed to the plugin `withBundleIdentifier`.');\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(setBundleIdentifierForPbxproj(config.modRequest.projectRoot, bundleId));\n\n          case 4:\n            return _context.abrupt(\"return\", config);\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }]);\n};\n\nfunction getBundleIdentifier(config) {\n  var _a, _b;\n\n  return (_b = (_a = config.ios) === null || _a === void 0 ? void 0 : _a.bundleIdentifier) !== null && _b !== void 0 ? _b : null;\n}\n\nexports.getBundleIdentifier = getBundleIdentifier;\n\nfunction setBundleIdentifier(config, infoPlist) {\n  var bundleIdentifier = getBundleIdentifier(config);\n\n  if (!bundleIdentifier) {\n    return infoPlist;\n  }\n\n  return _extends(_extends({}, infoPlist), {\n    CFBundleIdentifier: bundleIdentifier\n  });\n}\n\nexports.setBundleIdentifier = setBundleIdentifier;\n\nfunction getBundleIdentifierFromPbxproj(projectRoot) {\n  var pbxprojPath;\n\n  try {\n    pbxprojPath = Paths_1.getPBXProjectPath(projectRoot);\n  } catch (_a) {\n    return null;\n  }\n\n  var project = xcode_1.default.project(pbxprojPath);\n  project.parseSync();\n\n  var _Xcodeproj_1$findFirs = Xcodeproj_1.findFirstNativeTarget(project),\n      _Xcodeproj_1$findFirs2 = _slicedToArray(_Xcodeproj_1$findFirs, 2),\n      nativeTarget = _Xcodeproj_1$findFirs2[1];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(Xcodeproj_1.getBuildConfigurationForId(project, nativeTarget.buildConfigurationList)), _step; !(_step = _iterator()).done;) {\n    var _ref2 = _step.value;\n\n    var _ref3 = _slicedToArray(_ref2, 2);\n\n    var item = _ref3[1];\n    var bundleIdentifierRaw = item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER;\n\n    if (bundleIdentifierRaw) {\n      var bundleIdentifier = bundleIdentifierRaw[0] === '\"' ? bundleIdentifierRaw.slice(1, -1) : bundleIdentifierRaw;\n      var bundleIdentifierParts = bundleIdentifier.split('.');\n\n      if (bundleIdentifierParts[bundleIdentifierParts.length - 1] === '$(PRODUCT_NAME:rfc1034identifier)' && item.buildSettings.PRODUCT_NAME) {\n        bundleIdentifierParts[bundleIdentifierParts.length - 1] = item.buildSettings.PRODUCT_NAME.replace(/[^a-zA-Z0-9]/g, '-');\n      }\n\n      return bundleIdentifierParts.join('.');\n    }\n  }\n\n  return null;\n}\n\nexports.getBundleIdentifierFromPbxproj = getBundleIdentifierFromPbxproj;\n\nfunction updateBundleIdentifierForPbxproj(pbxprojPath, bundleIdentifier) {\n  var updateProductName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var project = xcode_1.default.project(pbxprojPath);\n  project.parseSync();\n\n  var _Xcodeproj_1$findFirs3 = Xcodeproj_1.findFirstNativeTarget(project),\n      _Xcodeproj_1$findFirs4 = _slicedToArray(_Xcodeproj_1$findFirs3, 2),\n      nativeTarget = _Xcodeproj_1$findFirs4[1];\n\n  Xcodeproj_1.getBuildConfigurationForId(project, nativeTarget.buildConfigurationList).forEach(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        item = _ref5[1];\n\n    if (item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER === bundleIdentifier) {\n      return;\n    }\n\n    item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER = \"\\\"\" + bundleIdentifier + \"\\\"\";\n\n    if (updateProductName) {\n      var productName = bundleIdentifier.split('.').pop();\n\n      if (!(productName === null || productName === void 0 ? void 0 : productName.includes('$'))) {\n        item.buildSettings.PRODUCT_NAME = productName;\n      }\n    }\n  });\n  fs_extra_1.default.writeFileSync(pbxprojPath, project.writeSync());\n}\n\nexports.updateBundleIdentifierForPbxproj = updateBundleIdentifierForPbxproj;\n\nfunction setBundleIdentifierForPbxproj(projectRoot, bundleIdentifier) {\n  var updateProductName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var pbxprojPaths = [];\n\n  try {\n    pbxprojPaths = Paths_1.getAllPBXProjectPaths(projectRoot);\n  } catch (_a) {}\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(pbxprojPaths), _step2; !(_step2 = _iterator2()).done;) {\n    var pbxprojPath = _step2.value;\n    updateBundleIdentifierForPbxproj(pbxprojPath, bundleIdentifier, updateProductName);\n  }\n}\n\nexports.setBundleIdentifierForPbxproj = setBundleIdentifierForPbxproj;\nvar defaultBundleId = '$(PRODUCT_BUNDLE_IDENTIFIER)';\n\nfunction resetAllPlistBundleIdentifiers(projectRoot) {\n  var infoPlistPaths = Paths_1.getAllInfoPlistPaths(projectRoot);\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(infoPlistPaths), _step3; !(_step3 = _iterator3()).done;) {\n    var plistPath = _step3.value;\n    resetPlistBundleIdentifier(plistPath);\n  }\n}\n\nexports.resetAllPlistBundleIdentifiers = resetAllPlistBundleIdentifiers;\n\nfunction resetPlistBundleIdentifier(plistPath) {\n  var rawPlist = fs_extra_1.default.readFileSync(plistPath, 'utf8');\n  var plistObject = plist_1.default.parse(rawPlist);\n\n  if (plistObject.CFBundleIdentifier) {\n    if (plistObject.CFBundleIdentifier === defaultBundleId) return;\n    var format = {\n      pretty: true,\n      indent: \"\\t\"\n    };\n    var xml = plist_1.default.build(_extends(_extends({}, plistObject), {\n      CFBundleIdentifier: defaultBundleId\n    }), format);\n\n    if (xml !== rawPlist) {\n      fs_extra_1.default.writeFileSync(plistPath, xml);\n    }\n  }\n}\n\nexports.resetPlistBundleIdentifier = resetPlistBundleIdentifier;","map":{"version":3,"sources":["../../src/ios/BundleIdentifier.ts"],"names":[],"mappings":"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","sourcesContent":["import { ExpoConfig } from '@expo/config-types';\nimport plist, { PlistObject } from '@expo/plist';\nimport assert from 'assert';\nimport fs from 'fs-extra';\nimport xcode from 'xcode';\n\nimport { ConfigPlugin } from '../Plugin.types';\nimport { withDangerousMod } from '../plugins/core-plugins';\nimport { InfoPlist } from './IosConfig.types';\nimport { getAllInfoPlistPaths, getAllPBXProjectPaths, getPBXProjectPath } from './Paths';\nimport {\n  ConfigurationSectionEntry,\n  findFirstNativeTarget,\n  getBuildConfigurationForId,\n} from './utils/Xcodeproj';\n\nexport const withBundleIdentifier: ConfigPlugin<{ bundleIdentifier?: string }> = (\n  config,\n  { bundleIdentifier }\n) => {\n  return withDangerousMod(config, [\n    'ios',\n    async config => {\n      const bundleId = bundleIdentifier ?? config.ios?.bundleIdentifier;\n      assert(\n        bundleId,\n        '`bundleIdentifier` must be defined in the app config (`expo.ios.bundleIdentifier`) or passed to the plugin `withBundleIdentifier`.'\n      );\n      await setBundleIdentifierForPbxproj(config.modRequest.projectRoot, bundleId!);\n      return config;\n    },\n  ]);\n};\n\nfunction getBundleIdentifier(config: ExpoConfig): string | null {\n  return config.ios?.bundleIdentifier ?? null;\n}\n\n/**\n * In Turtle v1 we set the bundleIdentifier directly on Info.plist rather\n * than in pbxproj\n */\nfunction setBundleIdentifier(config: ExpoConfig, infoPlist: InfoPlist): InfoPlist {\n  const bundleIdentifier = getBundleIdentifier(config);\n\n  if (!bundleIdentifier) {\n    return infoPlist;\n  }\n\n  return {\n    ...infoPlist,\n    CFBundleIdentifier: bundleIdentifier,\n  };\n}\n\n/**\n * Gets the bundle identifier of the Xcode project found in the project directory.\n * If either the Xcode project doesn't exist or the project is not configured\n * this function returns null.\n *\n * @param {string} projectRoot Path to project root containing the ios directory\n * @returns {string | null} bundle identifier of the Xcode project or null if the project is not configured\n */\nfunction getBundleIdentifierFromPbxproj(projectRoot: string): string | null {\n  let pbxprojPath: string;\n  try {\n    pbxprojPath = getPBXProjectPath(projectRoot);\n  } catch {\n    return null;\n  }\n  const project = xcode.project(pbxprojPath);\n  project.parseSync();\n\n  const [, nativeTarget] = findFirstNativeTarget(project);\n  for (const [, item] of getBuildConfigurationForId(project, nativeTarget.buildConfigurationList)) {\n    const bundleIdentifierRaw = item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER;\n    if (bundleIdentifierRaw) {\n      const bundleIdentifier =\n        bundleIdentifierRaw[0] === '\"' ? bundleIdentifierRaw.slice(1, -1) : bundleIdentifierRaw;\n      // it's possible to use interpolation for the bundle identifier\n      // the most common case is when the last part of the id is set to `$(PRODUCT_NAME:rfc1034identifier)`\n      // in this case, PRODUCT_NAME should be replaced with its value\n      // the `rfc1034identifier` modifier replaces all non-alphanumeric characters with dashes\n      const bundleIdentifierParts = bundleIdentifier.split('.');\n      if (\n        bundleIdentifierParts[bundleIdentifierParts.length - 1] ===\n          '$(PRODUCT_NAME:rfc1034identifier)' &&\n        item.buildSettings.PRODUCT_NAME\n      ) {\n        bundleIdentifierParts[\n          bundleIdentifierParts.length - 1\n        ] = item.buildSettings.PRODUCT_NAME.replace(/[^a-zA-Z0-9]/g, '-');\n      }\n      return bundleIdentifierParts.join('.');\n    }\n  }\n  return null;\n}\n\n/**\n * Updates the bundle identifier for a given pbxproj\n *\n * @param {string} pbxprojPath Path to pbxproj file\n * @param {string} bundleIdentifier Bundle identifier to set in the pbxproj\n * @param {boolean} [updateProductName=true]  Whether to update PRODUCT_NAME\n */\nfunction updateBundleIdentifierForPbxproj(\n  pbxprojPath: string,\n  bundleIdentifier: string,\n  updateProductName: boolean = true\n): void {\n  const project = xcode.project(pbxprojPath);\n  project.parseSync();\n\n  const [, nativeTarget] = findFirstNativeTarget(project);\n\n  getBuildConfigurationForId(project, nativeTarget.buildConfigurationList).forEach(\n    ([, item]: ConfigurationSectionEntry) => {\n      if (item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER === bundleIdentifier) {\n        return;\n      }\n\n      item.buildSettings.PRODUCT_BUNDLE_IDENTIFIER = `\"${bundleIdentifier}\"`;\n\n      if (updateProductName) {\n        const productName = bundleIdentifier.split('.').pop();\n        if (!productName?.includes('$')) {\n          item.buildSettings.PRODUCT_NAME = productName;\n        }\n      }\n    }\n  );\n  fs.writeFileSync(pbxprojPath, project.writeSync());\n}\n\n/**\n * Updates the bundle identifier for pbx projects inside the ios directory of the given project root\n *\n * @param {string} projectRoot Path to project root containing the ios directory\n * @param {string} bundleIdentifier Desired bundle identifier\n * @param {boolean} [updateProductName=true]  Whether to update PRODUCT_NAME\n */\nfunction setBundleIdentifierForPbxproj(\n  projectRoot: string,\n  bundleIdentifier: string,\n  updateProductName: boolean = true\n): void {\n  // Get all pbx projects in the ${projectRoot}/ios directory\n  let pbxprojPaths: string[] = [];\n  try {\n    pbxprojPaths = getAllPBXProjectPaths(projectRoot);\n  } catch {}\n\n  for (const pbxprojPath of pbxprojPaths) {\n    updateBundleIdentifierForPbxproj(pbxprojPath, bundleIdentifier, updateProductName);\n  }\n}\n\n/**\n * Reset bundle identifier field in Info.plist to use PRODUCT_BUNDLE_IDENTIFIER, as recommended by Apple.\n */\n\nconst defaultBundleId = '$(PRODUCT_BUNDLE_IDENTIFIER)';\n\nfunction resetAllPlistBundleIdentifiers(projectRoot: string): void {\n  const infoPlistPaths = getAllInfoPlistPaths(projectRoot);\n\n  for (const plistPath of infoPlistPaths) {\n    resetPlistBundleIdentifier(plistPath);\n  }\n}\n\nfunction resetPlistBundleIdentifier(plistPath: string): void {\n  const rawPlist = fs.readFileSync(plistPath, 'utf8');\n  const plistObject = plist.parse(rawPlist) as PlistObject;\n\n  if (plistObject.CFBundleIdentifier) {\n    if (plistObject.CFBundleIdentifier === defaultBundleId) return;\n\n    // attempt to match default Info.plist format\n    const format = { pretty: true, indent: `\\t` };\n\n    const xml = plist.build(\n      {\n        ...plistObject,\n        CFBundleIdentifier: defaultBundleId,\n      },\n      format\n    );\n\n    if (xml !== rawPlist) {\n      fs.writeFileSync(plistPath, xml);\n    }\n  }\n}\n\nexport {\n  getBundleIdentifier,\n  setBundleIdentifier,\n  getBundleIdentifierFromPbxproj,\n  updateBundleIdentifierForPbxproj,\n  setBundleIdentifierForPbxproj,\n  resetAllPlistBundleIdentifiers,\n  resetPlistBundleIdentifier,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}