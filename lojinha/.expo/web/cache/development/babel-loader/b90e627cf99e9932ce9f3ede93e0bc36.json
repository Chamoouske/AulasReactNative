{"ast":null,"code":"'use strict';\n\nimport { Command } from \"../src/Command.js\";\ntest('parses simple command', function () {\n  var obj = {\n    'name': 'setBreakpointsActive',\n    'parameters': [{\n      'name': 'active',\n      'type': 'boolean',\n      'description': 'New value for breakpoints active state.'\n    }],\n    'description': 'Activates / deactivates all breakpoints on the page.'\n  };\n  var command = Command.create('Debugger', obj, false);\n  expect(command.domain).toBe('Debugger');\n  expect(command.name).toBe('setBreakpointsActive');\n  expect(command.description).toBe('Activates / deactivates all breakpoints on the page.');\n  expect(command.parameters.map(function (p) {\n    return p.name;\n  })).toEqual(['active']);\n  expect(command.returns.length).toBe(0);\n  expect(command.getDebuggerName()).toBe('Debugger.setBreakpointsActive');\n  expect(command.getCppNamespace()).toBe('debugger');\n  expect(command.getRequestCppType()).toBe('SetBreakpointsActiveRequest');\n  expect(command.getResponseCppType()).toBeUndefined();\n  expect(command.getForwardDecls()).toEqual(['struct SetBreakpointsActiveRequest;']);\n});\ntest('parses command with return', function () {\n  var obj = {\n    'name': 'setBreakpoint',\n    'parameters': [{\n      'name': 'location',\n      '$ref': 'Location',\n      'description': 'Location to set breakpoint in.'\n    }, {\n      'name': 'condition',\n      'type': 'string',\n      'optional': true,\n      'description': 'Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.'\n    }],\n    'returns': [{\n      'name': 'breakpointId',\n      '$ref': 'BreakpointId',\n      'description': 'Id of the created breakpoint for further reference.'\n    }, {\n      'name': 'actualLocation',\n      '$ref': 'Location',\n      'description': 'Location this breakpoint resolved into.'\n    }],\n    'description': 'Sets JavaScript breakpoint at a given location.'\n  };\n  var command = Command.create('Debugger', obj, false);\n  expect(command.domain).toBe('Debugger');\n  expect(command.name).toBe('setBreakpoint');\n  expect(command.description).toBe('Sets JavaScript breakpoint at a given location.');\n  expect(command.parameters.map(function (p) {\n    return p.name;\n  })).toEqual(['location', 'condition']);\n  expect(command.returns.map(function (p) {\n    return p.name;\n  })).toEqual(['breakpointId', 'actualLocation']);\n  expect(command.getDebuggerName()).toBe('Debugger.setBreakpoint');\n  expect(command.getCppNamespace()).toBe('debugger');\n  expect(command.getRequestCppType()).toBe('SetBreakpointRequest');\n  expect(command.getResponseCppType()).toBe('SetBreakpointResponse');\n  expect(command.getForwardDecls()).toEqual(['struct SetBreakpointRequest;', 'struct SetBreakpointResponse;']);\n});","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/ReactCommon/hermes/inspector/tools/msggen/__tests__/CommandTest.js"],"names":["Command","test","obj","command","create","expect","domain","toBe","name","description","parameters","map","p","toEqual","returns","length","getDebuggerName","getCppNamespace","getRequestCppType","getResponseCppType","toBeUndefined","getForwardDecls"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nimport { Command } from '../src/Command.js';\n\ntest('parses simple command', () => {\n  let obj = {\n    'name': 'setBreakpointsActive',\n    'parameters': [\n      { 'name': 'active', 'type': 'boolean', 'description': 'New value for breakpoints active state.' },\n    ],\n    'description': 'Activates / deactivates all breakpoints on the page.',\n  };\n  let command = Command.create('Debugger', obj, false);\n\n  expect(command.domain).toBe('Debugger');\n  expect(command.name).toBe('setBreakpointsActive');\n  expect(command.description).toBe('Activates / deactivates all breakpoints on the page.');\n  expect(command.parameters.map(p => p.name)).toEqual(['active']);\n  expect(command.returns.length).toBe(0);\n\n  expect(command.getDebuggerName()).toBe('Debugger.setBreakpointsActive');\n  expect(command.getCppNamespace()).toBe('debugger');\n  expect(command.getRequestCppType()).toBe('SetBreakpointsActiveRequest');\n  expect(command.getResponseCppType()).toBeUndefined();\n  expect(command.getForwardDecls()).toEqual(['struct SetBreakpointsActiveRequest;']);\n});\n\ntest('parses command with return', () => {\n  let obj = {\n    'name': 'setBreakpoint',\n    'parameters': [\n      { 'name': 'location', '$ref': 'Location', 'description': 'Location to set breakpoint in.' },\n      { 'name': 'condition', 'type': 'string', 'optional': true, 'description': 'Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.' },\n    ],\n    'returns': [\n      { 'name': 'breakpointId', '$ref': 'BreakpointId', 'description': 'Id of the created breakpoint for further reference.' },\n      { 'name': 'actualLocation', '$ref': 'Location', 'description': 'Location this breakpoint resolved into.' },\n    ],\n    'description': 'Sets JavaScript breakpoint at a given location.',\n  };\n  let command = Command.create('Debugger', obj, false);\n\n  expect(command.domain).toBe('Debugger');\n  expect(command.name).toBe('setBreakpoint');\n  expect(command.description).toBe('Sets JavaScript breakpoint at a given location.');\n  expect(command.parameters.map(p => p.name)).toEqual(['location', 'condition']);\n  expect(command.returns.map(p => p.name)).toEqual(['breakpointId', 'actualLocation']);\n\n  expect(command.getDebuggerName()).toBe('Debugger.setBreakpoint');\n  expect(command.getCppNamespace()).toBe('debugger');\n  expect(command.getRequestCppType()).toBe('SetBreakpointRequest');\n  expect(command.getResponseCppType()).toBe('SetBreakpointResponse');\n  expect(command.getForwardDecls()).toEqual([\n    'struct SetBreakpointRequest;',\n    'struct SetBreakpointResponse;',\n  ]);\n});\n"]},"metadata":{},"sourceType":"module"}