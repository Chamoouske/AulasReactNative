{"ast":null,"code":"'use strict';\n\nimport InteractionManager from \"../InteractionManager\";\nimport TouchHistoryMath from \"../../vendor/react-native/TouchHistoryMath\";\nvar currentCentroidX = TouchHistoryMath.currentCentroidX,\n    currentCentroidY = TouchHistoryMath.currentCentroidY,\n    currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter,\n    currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter,\n    previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter,\n    previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;\nvar PanResponder = {\n  _initializeGestureState: function _initializeGestureState(gestureState) {\n    gestureState.x = 0;\n    gestureState.y = 0;\n    gestureState.initialX = 0;\n    gestureState.initialY = 0;\n    gestureState.deltaX = 0;\n    gestureState.deltaY = 0;\n    gestureState.velocityX = 0;\n    gestureState.velocityY = 0;\n    gestureState.numberActiveTouches = 0;\n    gestureState._accountsForMovesUpTo = 0;\n  },\n  _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {\n    var movedAfter = gestureState._accountsForMovesUpTo;\n    var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    var prevDeltaX = gestureState.deltaX;\n    var prevDeltaY = gestureState.deltaY;\n    var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    var deltaX = prevDeltaX + (x - prevX);\n    var deltaY = prevDeltaY + (y - prevY);\n    var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;\n    gestureState.deltaX = deltaX;\n    gestureState.deltaY = deltaY;\n    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n    gestureState.velocityX = (deltaX - prevDeltaX) / dt;\n    gestureState.velocityY = (deltaY - prevDeltaY) / dt;\n    gestureState.x = x;\n    gestureState.y = y;\n    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n  },\n  create: function create(config) {\n    var interactionState = {\n      handle: null\n    };\n    var gestureState = {\n      stateID: Math.random(),\n      x: 0,\n      y: 0,\n      initialX: 0,\n      initialY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      numberActiveTouches: 0,\n      _accountsForMovesUpTo: 0\n    };\n    var _onStartShouldSetResponder = config.onStartShouldSetResponder,\n        _onStartShouldSetResponderCapture = config.onStartShouldSetResponderCapture,\n        _onMoveShouldSetResponder = config.onMoveShouldSetResponder,\n        _onMoveShouldSetResponderCapture = config.onMoveShouldSetResponderCapture,\n        onPanGrant = config.onPanGrant,\n        onPanStart = config.onPanStart,\n        onPanMove = config.onPanMove,\n        onPanEnd = config.onPanEnd,\n        onPanRelease = config.onPanRelease,\n        onPanReject = config.onPanReject,\n        onPanTerminate = config.onPanTerminate,\n        onPanTerminationRequest = config.onPanTerminationRequest;\n    var panHandlers = {\n      onStartShouldSetResponder: function onStartShouldSetResponder(event) {\n        return _onStartShouldSetResponder != null ? _onStartShouldSetResponder(event, gestureState) : false;\n      },\n      onMoveShouldSetResponder: function onMoveShouldSetResponder(event) {\n        return _onMoveShouldSetResponder != null ? _onMoveShouldSetResponder(event, gestureState) : false;\n      },\n      onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(event) {\n        if (event.nativeEvent.touches.length === 1) {\n          PanResponder._initializeGestureState(gestureState);\n        }\n\n        gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;\n        return _onStartShouldSetResponderCapture != null ? _onStartShouldSetResponderCapture(event, gestureState) : false;\n      },\n      onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(event) {\n        var touchHistory = event.touchHistory;\n\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n        return _onMoveShouldSetResponderCapture != null ? _onMoveShouldSetResponderCapture(event, gestureState) : false;\n      },\n      onResponderGrant: function onResponderGrant(event) {\n        if (!interactionState.handle) {\n          interactionState.handle = InteractionManager.createInteractionHandle();\n        }\n\n        gestureState.initialX = currentCentroidX(event.touchHistory);\n        gestureState.initialY = currentCentroidY(event.touchHistory);\n        gestureState.deltaX = 0;\n        gestureState.deltaY = 0;\n\n        if (onPanGrant != null) {\n          onPanGrant(event, gestureState);\n        }\n      },\n      onResponderReject: function onResponderReject(event) {\n        clearInteractionHandle(interactionState, onPanReject, event, gestureState);\n      },\n      onResponderStart: function onResponderStart(event) {\n        var numberActiveTouches = event.touchHistory.numberActiveTouches;\n        gestureState.numberActiveTouches = numberActiveTouches;\n\n        if (onPanStart != null) {\n          onPanStart(event, gestureState);\n        }\n      },\n      onResponderMove: function onResponderMove(event) {\n        var touchHistory = event.touchHistory;\n\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n          return;\n        }\n\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n        if (onPanMove != null) {\n          onPanMove(event, gestureState);\n        }\n      },\n      onResponderEnd: function onResponderEnd(event) {\n        var numberActiveTouches = event.touchHistory.numberActiveTouches;\n        gestureState.numberActiveTouches = numberActiveTouches;\n        clearInteractionHandle(interactionState, onPanEnd, event, gestureState);\n      },\n      onResponderRelease: function onResponderRelease(event) {\n        clearInteractionHandle(interactionState, onPanRelease, event, gestureState);\n\n        PanResponder._initializeGestureState(gestureState);\n      },\n      onResponderTerminate: function onResponderTerminate(event) {\n        clearInteractionHandle(interactionState, onPanTerminate, event, gestureState);\n\n        PanResponder._initializeGestureState(gestureState);\n      },\n      onResponderTerminationRequest: function onResponderTerminationRequest(event) {\n        return onPanTerminationRequest != null ? onPanTerminationRequest(event, gestureState) : true;\n      }\n    };\n    return {\n      panHandlers: panHandlers,\n      getInteractionHandle: function getInteractionHandle() {\n        return interactionState.handle;\n      }\n    };\n  }\n};\n\nfunction clearInteractionHandle(interactionState, callback, event, gestureState) {\n  if (interactionState.handle) {\n    InteractionManager.clearInteractionHandle(interactionState.handle);\n    interactionState.handle = null;\n  }\n\n  if (callback) {\n    callback(event, gestureState);\n  }\n}\n\nexport default PanResponder;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/src/exports/PanResponder/Alternative.js"],"names":["InteractionManager","TouchHistoryMath","currentCentroidX","currentCentroidY","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","PanResponder","_initializeGestureState","gestureState","x","y","initialX","initialY","deltaX","deltaY","velocityX","velocityY","numberActiveTouches","_accountsForMovesUpTo","_updateGestureStateOnMove","touchHistory","movedAfter","prevX","prevY","prevDeltaX","prevDeltaY","dt","mostRecentTimeStamp","create","config","interactionState","handle","stateID","Math","random","onStartShouldSetResponder","onStartShouldSetResponderCapture","onMoveShouldSetResponder","onMoveShouldSetResponderCapture","onPanGrant","onPanStart","onPanMove","onPanEnd","onPanRelease","onPanReject","onPanTerminate","onPanTerminationRequest","panHandlers","event","nativeEvent","touches","length","onResponderGrant","createInteractionHandle","onResponderReject","clearInteractionHandle","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","getInteractionHandle","callback"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n/**\n * PAN RESPONDER\n *\n * `PanResponder` uses the Responder System to reconcile several touches into\n * a single gesture. It makes single-touch gestures resilient to extra touches,\n * and can be used to recognize simple multi-touch gestures. For each handler,\n * it provides a `gestureState` object alongside the ResponderEvent object.\n *\n * By default, `PanResponder` holds an `InteractionManager` handle to block\n * long-running JS events from interrupting active gestures.\n *\n * A graphical explanation of the touch data flow:\n *\n * +----------------------------+             +--------------------------------+\n * | ResponderTouchHistoryStore |             |TouchHistoryMath                |\n * +----------------------------+             +----------+---------------------+\n * |Global store of touchHistory|             |Allocation-less math util       |\n * |including activeness, start |             |on touch history (centroids     |\n * |position, prev/cur position.|             |and multitouch movement etc)    |\n * |                            |             |                                |\n * +----^-----------------------+             +----^---------------------------+\n *      |                                          |\n *      | (records relevant history                |\n *      |  of touches relevant for                 |\n *      |  implementing higher level               |\n *      |  gestures)                               |\n *      |                                          |\n * +----+-----------------------+             +----|---------------------------+\n * | ResponderEventPlugin       |             |    |   Your App/Component      |\n * +----------------------------+             +----|---------------------------+\n * |Negotiates which view gets  | Low level   |    |             High level    |\n * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |\n * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |\n * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|\n * +----------------------------+ attached to |  |         |     distance and  |\n *                                 each event |  +---------+     velocity.     |\n *                                            |                                |\n *                                            |                                |\n *                                            +--------------------------------+\n */\n\n'use strict';\n\nimport type { PressEvent } from '../../vendor/react-native/Types/CoreEventTypes';\n\nimport InteractionManager from '../InteractionManager';\nimport TouchHistoryMath from '../../vendor/react-native/TouchHistoryMath';\n\nexport type GestureState = {|\n  // ID of the gestureState; persisted as long as there's a pointer on screen\n  stateID: number,\n  // The latest screen coordinates of the gesture\n  x: number,\n  // The latest screen coordinates of the gesture\n  y: number,\n  // The screen coordinates of the responder grant\n  initialX: number,\n  // The screen coordinates of the responder grant\n  initialY: number,\n  // Accumulated distance of the gesture since it started\n  deltaX: number,\n  // Accumulated distance of the gesture since it started\n  deltaY: number,\n  // Current velocity of the gesture\n  velocityX: number,\n  // Current velocity of the gesture\n  velocityY: number,\n  // Number of touches currently on screen\n  numberActiveTouches: number,\n  _accountsForMovesUpTo: number\n|};\n\ntype ActiveCallback = (event: PressEvent, gestureState: GestureState) => boolean;\ntype PassiveCallback = (event: PressEvent, gestureState: GestureState) => void;\n\ntype PanResponderConfig = $ReadOnly<{|\n  // Negotiate for the responder\n  onMoveShouldSetResponder?: ?ActiveCallback,\n  onMoveShouldSetResponderCapture?: ?ActiveCallback,\n  onStartShouldSetResponder?: ?ActiveCallback,\n  onStartShouldSetResponderCapture?: ?ActiveCallback,\n  onPanTerminationRequest?: ?ActiveCallback,\n  // Gesture started\n  onPanGrant?: ?PassiveCallback,\n  // Gesture rejected\n  onPanReject?: ?PassiveCallback,\n  // A pointer touched the screen\n  onPanStart?: ?PassiveCallback,\n  // A pointer moved\n  onPanMove?: ?PassiveCallback,\n  // A pointer was removed from the screen\n  onPanEnd?: ?PassiveCallback,\n  // All pointers removed, gesture successful\n  onPanRelease?: ?PassiveCallback,\n  // Gesture cancelled\n  onPanTerminate?: ?PassiveCallback\n|}>;\n\nconst {\n  currentCentroidX,\n  currentCentroidY,\n  currentCentroidXOfTouchesChangedAfter,\n  currentCentroidYOfTouchesChangedAfter,\n  previousCentroidXOfTouchesChangedAfter,\n  previousCentroidYOfTouchesChangedAfter\n} = TouchHistoryMath;\n\nconst PanResponder = {\n  _initializeGestureState(gestureState: GestureState) {\n    gestureState.x = 0;\n    gestureState.y = 0;\n    gestureState.initialX = 0;\n    gestureState.initialY = 0;\n    gestureState.deltaX = 0;\n    gestureState.deltaY = 0;\n    gestureState.velocityX = 0;\n    gestureState.velocityY = 0;\n    gestureState.numberActiveTouches = 0;\n    // All `gestureState` accounts for timeStamps up until:\n    gestureState._accountsForMovesUpTo = 0;\n  },\n\n  /**\n   * Take all recently moved touches, calculate how the centroid has changed just for those\n   * recently moved touches, and append that change to an accumulator. This is\n   * to (at least) handle the case where the user is moving three fingers, and\n   * then one of the fingers stops but the other two continue.\n   *\n   * This is very different than taking all of the recently moved touches and\n   * storing their centroid as `dx/dy`. For correctness, we must *accumulate\n   * changes* in the centroid of recently moved touches.\n   *\n   * There is also some nuance with how we handle multiple moved touches in a\n   * single event. Multiple touches generate two 'move' events, each of\n   * them triggering `onResponderMove`. But with the way `PanResponder` works,\n   * all of the gesture inference is performed on the first dispatch, since it\n   * looks at all of the touches. Therefore, `PanResponder` does not call\n   * `onResponderMove` passed the first dispatch. This diverges from the\n   * typical responder callback pattern (without using `PanResponder`), but\n   * avoids more dispatches than necessary.\n   *\n   * When moving two touches in opposite directions, the cumulative\n   * distance is zero in each dimension. When two touches move in parallel five\n   * pixels in the same direction, the cumulative distance is five, not ten. If\n   * two touches start, one moves five in a direction, then stops and the other\n   * touch moves fives in the same direction, the cumulative distance is ten.\n   *\n   * This logic requires a kind of processing of time \"clusters\" of touch events\n   * so that two touch moves that essentially occur in parallel but move every\n   * other frame respectively, are considered part of the same movement.\n   *\n   * x/y: If a move event has been observed, `(x, y)` is the centroid of the most\n   * recently moved \"cluster\" of active touches.\n   * deltaX/deltaY: Cumulative touch distance. Accounts for touch moves that are\n   * clustered together in time, moving the same direction. Only valid when\n   * currently responder (otherwise, it only represents the drag distance below\n   * the threshold).\n   */\n  _updateGestureStateOnMove(\n    gestureState: GestureState,\n    touchHistory: $PropertyType<PressEvent, 'touchHistory'>\n  ) {\n    const movedAfter = gestureState._accountsForMovesUpTo;\n    const prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    const prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    const prevDeltaX = gestureState.deltaX;\n    const prevDeltaY = gestureState.deltaY;\n\n    const x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    const y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    const deltaX = prevDeltaX + (x - prevX);\n    const deltaY = prevDeltaY + (y - prevY);\n    // TODO: This must be filtered intelligently.\n    const dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;\n\n    gestureState.deltaX = deltaX;\n    gestureState.deltaY = deltaY;\n    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n    gestureState.velocityX = (deltaX - prevDeltaX) / dt;\n    gestureState.velocityY = (deltaY - prevDeltaY) / dt;\n    gestureState.x = x;\n    gestureState.y = y;\n    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n  },\n\n  /**\n   * Enhanced versions of all of the responder callbacks that provide not only\n   * the `ResponderEvent`, but also the `PanResponder` gesture state.\n   *\n   * In general, for events that have capture equivalents, we update the\n   * gestureState once in the capture phase and can use it in the bubble phase\n   * as well.\n   */\n  create(config: PanResponderConfig) {\n    const interactionState = {\n      handle: (null: ?number)\n    };\n    const gestureState: GestureState = {\n      // Useful for debugging\n      stateID: Math.random(),\n      x: 0,\n      y: 0,\n      initialX: 0,\n      initialY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      numberActiveTouches: 0,\n      _accountsForMovesUpTo: 0\n    };\n\n    const {\n      onStartShouldSetResponder,\n      onStartShouldSetResponderCapture,\n      onMoveShouldSetResponder,\n      onMoveShouldSetResponderCapture,\n      onPanGrant,\n      onPanStart,\n      onPanMove,\n      onPanEnd,\n      onPanRelease,\n      onPanReject,\n      onPanTerminate,\n      onPanTerminationRequest\n    } = config;\n\n    const panHandlers = {\n      onStartShouldSetResponder(event: PressEvent): boolean {\n        return onStartShouldSetResponder != null\n          ? onStartShouldSetResponder(event, gestureState)\n          : false;\n      },\n      onMoveShouldSetResponder(event: PressEvent): boolean {\n        return onMoveShouldSetResponder != null\n          ? onMoveShouldSetResponder(event, gestureState)\n          : false;\n      },\n      onStartShouldSetResponderCapture(event: PressEvent): boolean {\n        // TODO: Actually, we should reinitialize the state any time\n        // touches.length increases from 0 active to > 0 active.\n        if (event.nativeEvent.touches.length === 1) {\n          PanResponder._initializeGestureState(gestureState);\n        }\n        gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;\n        return onStartShouldSetResponderCapture != null\n          ? onStartShouldSetResponderCapture(event, gestureState)\n          : false;\n      },\n\n      onMoveShouldSetResponderCapture(event: PressEvent): boolean {\n        const touchHistory = event.touchHistory;\n        // Responder system incorrectly dispatches should* to current responder\n        // Filter out any touch moves past the first one - we would have\n        // already processed multi-touch geometry during the first event.\n        // NOTE: commented out because new responder system should get it right.\n        //if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        //  return false;\n        //}\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n        return onMoveShouldSetResponderCapture != null\n          ? onMoveShouldSetResponderCapture(event, gestureState)\n          : false;\n      },\n\n      onResponderGrant(event: PressEvent): void {\n        if (!interactionState.handle) {\n          interactionState.handle = InteractionManager.createInteractionHandle();\n        }\n        gestureState.initialX = currentCentroidX(event.touchHistory);\n        gestureState.initialY = currentCentroidY(event.touchHistory);\n        gestureState.deltaX = 0;\n        gestureState.deltaY = 0;\n        if (onPanGrant != null) {\n          onPanGrant(event, gestureState);\n        }\n      },\n\n      onResponderReject(event: PressEvent): void {\n        clearInteractionHandle(interactionState, onPanReject, event, gestureState);\n      },\n\n      onResponderStart(event: PressEvent): void {\n        const { numberActiveTouches } = event.touchHistory;\n        gestureState.numberActiveTouches = numberActiveTouches;\n        if (onPanStart != null) {\n          onPanStart(event, gestureState);\n        }\n      },\n\n      onResponderMove(event: PressEvent): void {\n        const touchHistory = event.touchHistory;\n        // Guard against the dispatch of two touch moves when there are two\n        // simultaneously changed touches.\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n          return;\n        }\n        // Filter out any touch moves past the first one - we would have\n        // already processed multi-touch geometry during the first event.\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n        if (onPanMove != null) {\n          onPanMove(event, gestureState);\n        }\n      },\n\n      onResponderEnd(event: PressEvent): void {\n        const { numberActiveTouches } = event.touchHistory;\n        gestureState.numberActiveTouches = numberActiveTouches;\n        clearInteractionHandle(interactionState, onPanEnd, event, gestureState);\n      },\n\n      onResponderRelease(event: PressEvent): void {\n        clearInteractionHandle(interactionState, onPanRelease, event, gestureState);\n        PanResponder._initializeGestureState(gestureState);\n      },\n\n      onResponderTerminate(event: PressEvent): void {\n        clearInteractionHandle(interactionState, onPanTerminate, event, gestureState);\n        PanResponder._initializeGestureState(gestureState);\n      },\n\n      onResponderTerminationRequest(event: PressEvent): boolean {\n        return onPanTerminationRequest != null\n          ? onPanTerminationRequest(event, gestureState)\n          : true;\n      }\n    };\n    return {\n      panHandlers,\n      getInteractionHandle(): ?number {\n        return interactionState.handle;\n      }\n    };\n  }\n};\n\nfunction clearInteractionHandle(\n  interactionState: { handle: ?number },\n  callback: ?(ActiveCallback | PassiveCallback),\n  event: PressEvent,\n  gestureState: GestureState\n) {\n  if (interactionState.handle) {\n    InteractionManager.clearInteractionHandle(interactionState.handle);\n    interactionState.handle = null;\n  }\n  if (callback) {\n    callback(event, gestureState);\n  }\n}\n\nexport default PanResponder;\n"]},"metadata":{},"sourceType":"module"}