{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _InteractionManager = _interopRequireDefault(require(\"../InteractionManager\"));\n\nvar _TouchHistoryMath = _interopRequireDefault(require(\"../../vendor/react-native/TouchHistoryMath\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar currentCentroidX = _TouchHistoryMath.default.currentCentroidX,\n    currentCentroidY = _TouchHistoryMath.default.currentCentroidY,\n    currentCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidXOfTouchesChangedAfter,\n    currentCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidYOfTouchesChangedAfter,\n    previousCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidXOfTouchesChangedAfter,\n    previousCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidYOfTouchesChangedAfter;\nvar PanResponder = {\n  _initializeGestureState: function _initializeGestureState(gestureState) {\n    gestureState.x = 0;\n    gestureState.y = 0;\n    gestureState.initialX = 0;\n    gestureState.initialY = 0;\n    gestureState.deltaX = 0;\n    gestureState.deltaY = 0;\n    gestureState.velocityX = 0;\n    gestureState.velocityY = 0;\n    gestureState.numberActiveTouches = 0;\n    gestureState._accountsForMovesUpTo = 0;\n  },\n  _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {\n    var movedAfter = gestureState._accountsForMovesUpTo;\n    var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    var prevDeltaX = gestureState.deltaX;\n    var prevDeltaY = gestureState.deltaY;\n    var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    var deltaX = prevDeltaX + (x - prevX);\n    var deltaY = prevDeltaY + (y - prevY);\n    var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;\n    gestureState.deltaX = deltaX;\n    gestureState.deltaY = deltaY;\n    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n    gestureState.velocityX = (deltaX - prevDeltaX) / dt;\n    gestureState.velocityY = (deltaY - prevDeltaY) / dt;\n    gestureState.x = x;\n    gestureState.y = y;\n    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n  },\n  create: function create(config) {\n    var interactionState = {\n      handle: null\n    };\n    var gestureState = {\n      stateID: Math.random(),\n      x: 0,\n      y: 0,\n      initialX: 0,\n      initialY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      numberActiveTouches: 0,\n      _accountsForMovesUpTo: 0\n    };\n    var _onStartShouldSetResponder = config.onStartShouldSetResponder,\n        _onStartShouldSetResponderCapture = config.onStartShouldSetResponderCapture,\n        _onMoveShouldSetResponder = config.onMoveShouldSetResponder,\n        _onMoveShouldSetResponderCapture = config.onMoveShouldSetResponderCapture,\n        onPanGrant = config.onPanGrant,\n        onPanStart = config.onPanStart,\n        onPanMove = config.onPanMove,\n        onPanEnd = config.onPanEnd,\n        onPanRelease = config.onPanRelease,\n        onPanReject = config.onPanReject,\n        onPanTerminate = config.onPanTerminate,\n        onPanTerminationRequest = config.onPanTerminationRequest;\n    var panHandlers = {\n      onStartShouldSetResponder: function onStartShouldSetResponder(event) {\n        return _onStartShouldSetResponder != null ? _onStartShouldSetResponder(event, gestureState) : false;\n      },\n      onMoveShouldSetResponder: function onMoveShouldSetResponder(event) {\n        return _onMoveShouldSetResponder != null ? _onMoveShouldSetResponder(event, gestureState) : false;\n      },\n      onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(event) {\n        if (event.nativeEvent.touches.length === 1) {\n          PanResponder._initializeGestureState(gestureState);\n        }\n\n        gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;\n        return _onStartShouldSetResponderCapture != null ? _onStartShouldSetResponderCapture(event, gestureState) : false;\n      },\n      onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(event) {\n        var touchHistory = event.touchHistory;\n\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n        return _onMoveShouldSetResponderCapture != null ? _onMoveShouldSetResponderCapture(event, gestureState) : false;\n      },\n      onResponderGrant: function onResponderGrant(event) {\n        if (!interactionState.handle) {\n          interactionState.handle = _InteractionManager.default.createInteractionHandle();\n        }\n\n        gestureState.initialX = currentCentroidX(event.touchHistory);\n        gestureState.initialY = currentCentroidY(event.touchHistory);\n        gestureState.deltaX = 0;\n        gestureState.deltaY = 0;\n\n        if (onPanGrant != null) {\n          onPanGrant(event, gestureState);\n        }\n      },\n      onResponderReject: function onResponderReject(event) {\n        clearInteractionHandle(interactionState, onPanReject, event, gestureState);\n      },\n      onResponderStart: function onResponderStart(event) {\n        var numberActiveTouches = event.touchHistory.numberActiveTouches;\n        gestureState.numberActiveTouches = numberActiveTouches;\n\n        if (onPanStart != null) {\n          onPanStart(event, gestureState);\n        }\n      },\n      onResponderMove: function onResponderMove(event) {\n        var touchHistory = event.touchHistory;\n\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n          return;\n        }\n\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n        if (onPanMove != null) {\n          onPanMove(event, gestureState);\n        }\n      },\n      onResponderEnd: function onResponderEnd(event) {\n        var numberActiveTouches = event.touchHistory.numberActiveTouches;\n        gestureState.numberActiveTouches = numberActiveTouches;\n        clearInteractionHandle(interactionState, onPanEnd, event, gestureState);\n      },\n      onResponderRelease: function onResponderRelease(event) {\n        clearInteractionHandle(interactionState, onPanRelease, event, gestureState);\n\n        PanResponder._initializeGestureState(gestureState);\n      },\n      onResponderTerminate: function onResponderTerminate(event) {\n        clearInteractionHandle(interactionState, onPanTerminate, event, gestureState);\n\n        PanResponder._initializeGestureState(gestureState);\n      },\n      onResponderTerminationRequest: function onResponderTerminationRequest(event) {\n        return onPanTerminationRequest != null ? onPanTerminationRequest(event, gestureState) : true;\n      }\n    };\n    return {\n      panHandlers: panHandlers,\n      getInteractionHandle: function getInteractionHandle() {\n        return interactionState.handle;\n      }\n    };\n  }\n};\n\nfunction clearInteractionHandle(interactionState, callback, event, gestureState) {\n  if (interactionState.handle) {\n    _InteractionManager.default.clearInteractionHandle(interactionState.handle);\n\n    interactionState.handle = null;\n  }\n\n  if (callback) {\n    callback(event, gestureState);\n  }\n}\n\nvar _default = PanResponder;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/dist/cjs/exports/PanResponder/Alternative.js"],"names":["exports","__esModule","default","_InteractionManager","_interopRequireDefault","require","_TouchHistoryMath","obj","currentCentroidX","currentCentroidY","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","PanResponder","_initializeGestureState","gestureState","x","y","initialX","initialY","deltaX","deltaY","velocityX","velocityY","numberActiveTouches","_accountsForMovesUpTo","_updateGestureStateOnMove","touchHistory","movedAfter","prevX","prevY","prevDeltaX","prevDeltaY","dt","mostRecentTimeStamp","create","config","interactionState","handle","stateID","Math","random","_onStartShouldSetResponder","onStartShouldSetResponder","_onStartShouldSetResponderCapture","onStartShouldSetResponderCapture","_onMoveShouldSetResponder","onMoveShouldSetResponder","_onMoveShouldSetResponderCapture","onMoveShouldSetResponderCapture","onPanGrant","onPanStart","onPanMove","onPanEnd","onPanRelease","onPanReject","onPanTerminate","onPanTerminationRequest","panHandlers","event","nativeEvent","touches","length","onResponderGrant","createInteractionHandle","onResponderReject","clearInteractionHandle","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","getInteractionHandle","callback","_default","module"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n/**\n * PAN RESPONDER\n *\n * `PanResponder` uses the Responder System to reconcile several touches into\n * a single gesture. It makes single-touch gestures resilient to extra touches,\n * and can be used to recognize simple multi-touch gestures. For each handler,\n * it provides a `gestureState` object alongside the ResponderEvent object.\n *\n * By default, `PanResponder` holds an `InteractionManager` handle to block\n * long-running JS events from interrupting active gestures.\n *\n * A graphical explanation of the touch data flow:\n *\n * +----------------------------+             +--------------------------------+\n * | ResponderTouchHistoryStore |             |TouchHistoryMath                |\n * +----------------------------+             +----------+---------------------+\n * |Global store of touchHistory|             |Allocation-less math util       |\n * |including activeness, start |             |on touch history (centroids     |\n * |position, prev/cur position.|             |and multitouch movement etc)    |\n * |                            |             |                                |\n * +----^-----------------------+             +----^---------------------------+\n *      |                                          |\n *      | (records relevant history                |\n *      |  of touches relevant for                 |\n *      |  implementing higher level               |\n *      |  gestures)                               |\n *      |                                          |\n * +----+-----------------------+             +----|---------------------------+\n * | ResponderEventPlugin       |             |    |   Your App/Component      |\n * +----------------------------+             +----|---------------------------+\n * |Negotiates which view gets  | Low level   |    |             High level    |\n * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |\n * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |\n * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|\n * +----------------------------+ attached to |  |         |     distance and  |\n *                                 each event |  +---------+     velocity.     |\n *                                            |                                |\n *                                            |                                |\n *                                            +--------------------------------+\n */\n'use strict';\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _InteractionManager = _interopRequireDefault(require(\"../InteractionManager\"));\n\nvar _TouchHistoryMath = _interopRequireDefault(require(\"../../vendor/react-native/TouchHistoryMath\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar currentCentroidX = _TouchHistoryMath.default.currentCentroidX,\n    currentCentroidY = _TouchHistoryMath.default.currentCentroidY,\n    currentCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidXOfTouchesChangedAfter,\n    currentCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidYOfTouchesChangedAfter,\n    previousCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidXOfTouchesChangedAfter,\n    previousCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidYOfTouchesChangedAfter;\nvar PanResponder = {\n  _initializeGestureState: function _initializeGestureState(gestureState) {\n    gestureState.x = 0;\n    gestureState.y = 0;\n    gestureState.initialX = 0;\n    gestureState.initialY = 0;\n    gestureState.deltaX = 0;\n    gestureState.deltaY = 0;\n    gestureState.velocityX = 0;\n    gestureState.velocityY = 0;\n    gestureState.numberActiveTouches = 0; // All `gestureState` accounts for timeStamps up until:\n\n    gestureState._accountsForMovesUpTo = 0;\n  },\n\n  /**\n   * Take all recently moved touches, calculate how the centroid has changed just for those\n   * recently moved touches, and append that change to an accumulator. This is\n   * to (at least) handle the case where the user is moving three fingers, and\n   * then one of the fingers stops but the other two continue.\n   *\n   * This is very different than taking all of the recently moved touches and\n   * storing their centroid as `dx/dy`. For correctness, we must *accumulate\n   * changes* in the centroid of recently moved touches.\n   *\n   * There is also some nuance with how we handle multiple moved touches in a\n   * single event. Multiple touches generate two 'move' events, each of\n   * them triggering `onResponderMove`. But with the way `PanResponder` works,\n   * all of the gesture inference is performed on the first dispatch, since it\n   * looks at all of the touches. Therefore, `PanResponder` does not call\n   * `onResponderMove` passed the first dispatch. This diverges from the\n   * typical responder callback pattern (without using `PanResponder`), but\n   * avoids more dispatches than necessary.\n   *\n   * When moving two touches in opposite directions, the cumulative\n   * distance is zero in each dimension. When two touches move in parallel five\n   * pixels in the same direction, the cumulative distance is five, not ten. If\n   * two touches start, one moves five in a direction, then stops and the other\n   * touch moves fives in the same direction, the cumulative distance is ten.\n   *\n   * This logic requires a kind of processing of time \"clusters\" of touch events\n   * so that two touch moves that essentially occur in parallel but move every\n   * other frame respectively, are considered part of the same movement.\n   *\n   * x/y: If a move event has been observed, `(x, y)` is the centroid of the most\n   * recently moved \"cluster\" of active touches.\n   * deltaX/deltaY: Cumulative touch distance. Accounts for touch moves that are\n   * clustered together in time, moving the same direction. Only valid when\n   * currently responder (otherwise, it only represents the drag distance below\n   * the threshold).\n   */\n  _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {\n    var movedAfter = gestureState._accountsForMovesUpTo;\n    var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    var prevDeltaX = gestureState.deltaX;\n    var prevDeltaY = gestureState.deltaY;\n    var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n    var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n    var deltaX = prevDeltaX + (x - prevX);\n    var deltaY = prevDeltaY + (y - prevY); // TODO: This must be filtered intelligently.\n\n    var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;\n    gestureState.deltaX = deltaX;\n    gestureState.deltaY = deltaY;\n    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n    gestureState.velocityX = (deltaX - prevDeltaX) / dt;\n    gestureState.velocityY = (deltaY - prevDeltaY) / dt;\n    gestureState.x = x;\n    gestureState.y = y;\n    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n  },\n\n  /**\n   * Enhanced versions of all of the responder callbacks that provide not only\n   * the `ResponderEvent`, but also the `PanResponder` gesture state.\n   *\n   * In general, for events that have capture equivalents, we update the\n   * gestureState once in the capture phase and can use it in the bubble phase\n   * as well.\n   */\n  create: function create(config) {\n    var interactionState = {\n      handle: null\n    };\n    var gestureState = {\n      // Useful for debugging\n      stateID: Math.random(),\n      x: 0,\n      y: 0,\n      initialX: 0,\n      initialY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      numberActiveTouches: 0,\n      _accountsForMovesUpTo: 0\n    };\n    var _onStartShouldSetResponder = config.onStartShouldSetResponder,\n        _onStartShouldSetResponderCapture = config.onStartShouldSetResponderCapture,\n        _onMoveShouldSetResponder = config.onMoveShouldSetResponder,\n        _onMoveShouldSetResponderCapture = config.onMoveShouldSetResponderCapture,\n        onPanGrant = config.onPanGrant,\n        onPanStart = config.onPanStart,\n        onPanMove = config.onPanMove,\n        onPanEnd = config.onPanEnd,\n        onPanRelease = config.onPanRelease,\n        onPanReject = config.onPanReject,\n        onPanTerminate = config.onPanTerminate,\n        onPanTerminationRequest = config.onPanTerminationRequest;\n    var panHandlers = {\n      onStartShouldSetResponder: function onStartShouldSetResponder(event) {\n        return _onStartShouldSetResponder != null ? _onStartShouldSetResponder(event, gestureState) : false;\n      },\n      onMoveShouldSetResponder: function onMoveShouldSetResponder(event) {\n        return _onMoveShouldSetResponder != null ? _onMoveShouldSetResponder(event, gestureState) : false;\n      },\n      onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(event) {\n        // TODO: Actually, we should reinitialize the state any time\n        // touches.length increases from 0 active to > 0 active.\n        if (event.nativeEvent.touches.length === 1) {\n          PanResponder._initializeGestureState(gestureState);\n        }\n\n        gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;\n        return _onStartShouldSetResponderCapture != null ? _onStartShouldSetResponderCapture(event, gestureState) : false;\n      },\n      onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(event) {\n        var touchHistory = event.touchHistory; // Responder system incorrectly dispatches should* to current responder\n        // Filter out any touch moves past the first one - we would have\n        // already processed multi-touch geometry during the first event.\n        // NOTE: commented out because new responder system should get it right.\n        //if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        //  return false;\n        //}\n\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n        return _onMoveShouldSetResponderCapture != null ? _onMoveShouldSetResponderCapture(event, gestureState) : false;\n      },\n      onResponderGrant: function onResponderGrant(event) {\n        if (!interactionState.handle) {\n          interactionState.handle = _InteractionManager.default.createInteractionHandle();\n        }\n\n        gestureState.initialX = currentCentroidX(event.touchHistory);\n        gestureState.initialY = currentCentroidY(event.touchHistory);\n        gestureState.deltaX = 0;\n        gestureState.deltaY = 0;\n\n        if (onPanGrant != null) {\n          onPanGrant(event, gestureState);\n        }\n      },\n      onResponderReject: function onResponderReject(event) {\n        clearInteractionHandle(interactionState, onPanReject, event, gestureState);\n      },\n      onResponderStart: function onResponderStart(event) {\n        var numberActiveTouches = event.touchHistory.numberActiveTouches;\n        gestureState.numberActiveTouches = numberActiveTouches;\n\n        if (onPanStart != null) {\n          onPanStart(event, gestureState);\n        }\n      },\n      onResponderMove: function onResponderMove(event) {\n        var touchHistory = event.touchHistory; // Guard against the dispatch of two touch moves when there are two\n        // simultaneously changed touches.\n\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n          return;\n        } // Filter out any touch moves past the first one - we would have\n        // already processed multi-touch geometry during the first event.\n\n\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\n\n        if (onPanMove != null) {\n          onPanMove(event, gestureState);\n        }\n      },\n      onResponderEnd: function onResponderEnd(event) {\n        var numberActiveTouches = event.touchHistory.numberActiveTouches;\n        gestureState.numberActiveTouches = numberActiveTouches;\n        clearInteractionHandle(interactionState, onPanEnd, event, gestureState);\n      },\n      onResponderRelease: function onResponderRelease(event) {\n        clearInteractionHandle(interactionState, onPanRelease, event, gestureState);\n\n        PanResponder._initializeGestureState(gestureState);\n      },\n      onResponderTerminate: function onResponderTerminate(event) {\n        clearInteractionHandle(interactionState, onPanTerminate, event, gestureState);\n\n        PanResponder._initializeGestureState(gestureState);\n      },\n      onResponderTerminationRequest: function onResponderTerminationRequest(event) {\n        return onPanTerminationRequest != null ? onPanTerminationRequest(event, gestureState) : true;\n      }\n    };\n    return {\n      panHandlers: panHandlers,\n      getInteractionHandle: function getInteractionHandle() {\n        return interactionState.handle;\n      }\n    };\n  }\n};\n\nfunction clearInteractionHandle(interactionState, callback, event, gestureState) {\n  if (interactionState.handle) {\n    _InteractionManager.default.clearInteractionHandle(interactionState.handle);\n\n    interactionState.handle = null;\n  }\n\n  if (callback) {\n    callback(event, gestureState);\n  }\n}\n\nvar _default = PanResponder;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}