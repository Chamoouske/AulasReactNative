{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar require_from_string_1 = __importDefault(require(\"require-from-string\"));\n\nvar Errors_1 = require(\"./Errors\");\n\nvar Serialize_1 = require(\"./Serialize\");\n\nvar getBabelPreset_1 = require(\"./getBabelPreset\");\n\nfunction evalConfig(configFile, request) {\n  var babel = require('@babel/core');\n\n  var _babel$transformFileS = babel.transformFileSync(configFile, {\n    cwd: (request === null || request === void 0 ? void 0 : request.projectRoot) || process.cwd(),\n    babelrc: false,\n    configFile: false,\n    comments: false,\n    ignore: [/node_modules/],\n    filename: 'unknown',\n    presets: [getBabelPreset_1.getBabelPreset()]\n  }),\n      code = _babel$transformFileS.code;\n\n  var result = require_from_string_1.default(code, configFile);\n  return resolveConfigExport(result, configFile, request);\n}\n\nexports.evalConfig = evalConfig;\n\nfunction resolveConfigExport(result, configFile, request) {\n  if (result.default != null) {\n    result = result.default;\n  }\n\n  var exportedObjectType = typeof result;\n\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new Errors_1.ConfigError(\"Config file \" + configFile + \" cannot return a Promise.\", 'INVALID_CONFIG');\n  }\n\n  if (result === null || result === void 0 ? void 0 : result.expo) {\n    result = Serialize_1.serializeSkippingMods(result.expo);\n  } else {\n    result = Serialize_1.serializeSkippingMods(result);\n  }\n\n  return {\n    config: result,\n    exportedObjectType: exportedObjectType\n  };\n}\n\nexports.resolveConfigExport = resolveConfigExport;","map":{"version":3,"sources":["../src/evalConfig.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,IAAA,qBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,qBAAA,CAAA,CAAA;;AAGA,IAAA,QAAA,GAAA,OAAA,YAAA;;AACA,IAAA,WAAA,GAAA,OAAA,eAAA;;AACA,IAAA,gBAAA,GAAA,OAAA,oBAAA;;AAcA,SAAgB,UAAhB,CACE,UADF,EAEE,OAFF,EAE+B;AAE7B,MAAM,KAAK,GAAG,OAAO,CAAC,aAAD,CAArB;;AAF6B,8BAIZ,KAAK,CAAC,iBAAN,CAAwB,UAAxB,EAAoC;AAEnD,IAAA,GAAG,EAAE,CAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,WAAT,KAAwB,OAAO,CAAC,GAAR,EAFsB;AAGnD,IAAA,OAAO,EAAE,KAH0C;AAInD,IAAA,UAAU,EAAE,KAJuC;AAKnD,IAAA,QAAQ,EAAE,KALyC;AAMnD,IAAA,MAAM,EAAE,CAAC,cAAD,CAN2C;AAOnD,IAAA,QAAQ,EAAE,SAPyC;AAQnD,IAAA,OAAO,EAAE,CAAC,gBAAA,CAAA,cAAA,EAAD;AAR0C,GAApC,CAJY;AAAA,MAIrB,IAJqB,yBAIrB,IAJqB;;AAe7B,MAAM,MAAM,GAAG,qBAAA,CAAA,OAAA,CAAc,IAAd,EAAoB,UAApB,CAAf;AACA,SAAO,mBAAmB,CAAC,MAAD,EAAS,UAAT,EAAqB,OAArB,CAA1B;AACD;;AAnBD,OAAA,CAAA,UAAA,GAAA,UAAA;;AA+BA,SAAgB,mBAAhB,CACE,MADF,EAEE,UAFF,EAGE,OAHF,EAG+B;AAE7B,MAAI,MAAM,CAAC,OAAP,IAAkB,IAAtB,EAA4B;AAC1B,IAAA,MAAM,GAAG,MAAM,CAAC,OAAhB;AACD;;AACD,MAAM,kBAAkB,GAAG,OAAO,MAAlC;;AACA,MAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAChC,IAAA,MAAM,GAAG,MAAM,CAAC,OAAD,CAAf;AACD;;AAED,MAAI,MAAM,YAAY,OAAtB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,WAAJ,kBAA+B,UAA/B,gCAAsE,gBAAtE,CAAN;AACD;;AAGD,MAAI,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,IAAZ,EAAkB;AAChB,IAAA,MAAM,GAAG,WAAA,CAAA,qBAAA,CAAsB,MAAM,CAAC,IAA7B,CAAT;AACD,GAFD,MAEO;AACL,IAAA,MAAM,GAAG,WAAA,CAAA,qBAAA,CAAsB,MAAtB,CAAT;AACD;;AAED,SAAO;AAAE,IAAA,MAAM,EAAE,MAAV;AAAkB,IAAA,kBAAkB,EAAlB;AAAlB,GAAP;AACD;;AAzBD,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourcesContent":["// @ts-ignore\nimport requireString from 'require-from-string';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\nimport { getBabelPreset } from './getBabelPreset';\n// import babel from '@babel/core';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const babel = require('@babel/core');\n\n  const { code } = babel.transformFileSync(configFile, {\n    // only: [configFile],\n    cwd: request?.projectRoot || process.cwd(),\n    babelrc: false,\n    configFile: false,\n    comments: false,\n    ignore: [/node_modules/],\n    filename: 'unknown',\n    presets: [getBabelPreset()],\n  });\n\n  const result = requireString(code, configFile);\n  return resolveConfigExport(result, configFile, request);\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}