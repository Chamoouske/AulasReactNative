{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insert = exports.replace = void 0;\n\nrequire(\"core-js/es/string/match-all\");\n\nfunction replace(content, _ref) {\n  var replaceContent = _ref.replaceContent,\n      replacePattern = _ref.replacePattern;\n  var replacePatternOccurrence = content.search(replacePattern);\n\n  if (replacePatternOccurrence !== -1) {\n    return [true, content.replace(replacePattern, replaceContent)];\n  }\n\n  return [false, content];\n}\n\nexports.replace = replace;\n\nfunction insert(content, _ref2) {\n  var insertContent = _ref2.insertContent,\n      insertPattern = _ref2.insertPattern;\n  var insertBeforeLastOccurrence = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (insertBeforeLastOccurrence) {\n    return insertBeforeLastOccurrenceFun(content, {\n      insertContent: insertContent,\n      insertPattern: insertPattern\n    });\n  }\n\n  var insertPatternOccurrence = content.search(insertPattern);\n\n  if (insertPatternOccurrence !== -1) {\n    return [true, \"\" + content.slice(0, insertPatternOccurrence) + insertContent + content.slice(insertPatternOccurrence)];\n  }\n\n  return [false, content];\n}\n\nexports.insert = insert;\n\nfunction insertBeforeLastOccurrenceFun(content, _ref3) {\n  var insertContent = _ref3.insertContent,\n      insertPattern = _ref3.insertPattern;\n\n  var results = _toConsumableArray(content.matchAll(new RegExp(insertPattern, 'gm')));\n\n  var patternLastOccurrence = results[results.length - 1];\n\n  if (!patternLastOccurrence) {\n    return [false, content];\n  }\n\n  return [true, \"\" + content.slice(0, patternLastOccurrence.index) + insertContent + content.slice(patternLastOccurrence.index)];\n}","map":{"version":3,"sources":["../../src/utils/string-utils.ts"],"names":[],"mappings":";;;;;;;;;AACA,OAAA,CAAA,6BAAA,CAAA;;AAKA,SAAgB,OAAhB,CACE,OADF,QAEiG;AAAA,MAA7F,cAA6F,QAA7F,cAA6F;AAAA,MAA7E,cAA6E,QAA7E,cAA6E;AAE/F,MAAM,wBAAwB,GAAG,OAAO,CAAC,MAAR,CAAe,cAAf,CAAjC;;AACA,MAAI,wBAAwB,KAAK,CAAC,CAAlC,EAAqC;AACnC,WAAO,CAAC,IAAD,EAAO,OAAO,CAAC,OAAR,CAAgB,cAAhB,EAAgC,cAAhC,CAAP,CAAP;AACD;;AACD,SAAO,CAAC,KAAD,EAAQ,OAAR,CAAP;AACD;;AATD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAeA,SAAgB,MAAhB,CACE,OADF,SAG6C;AAAA,MADzC,aACyC,SADzC,aACyC;AAAA,MAD1B,aAC0B,SAD1B,aAC0B;AAAA,MAA3C,0BAA2C,uEAAL,KAAK;;AAE3C,MAAI,0BAAJ,EAAgC;AAC9B,WAAO,6BAA6B,CAAC,OAAD,EAAU;AAAE,MAAA,aAAa,EAAb,aAAF;AAAiB,MAAA,aAAa,EAAb;AAAjB,KAAV,CAApC;AACD;;AACD,MAAM,uBAAuB,GAAG,OAAO,CAAC,MAAR,CAAe,aAAf,CAAhC;;AACA,MAAI,uBAAuB,KAAK,CAAC,CAAjC,EAAoC;AAClC,WAAO,CACL,IADK,OAEF,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,uBAAjB,CAFE,GAE0C,aAF1C,GAE0D,OAAO,CAAC,KAAR,CAC7D,uBAD6D,CAF1D,CAAP;AAMD;;AACD,SAAO,CAAC,KAAD,EAAQ,OAAR,CAAP;AACD;;AAlBD,OAAA,CAAA,MAAA,GAAA,MAAA;;AAwBA,SAAS,6BAAT,CACE,OADF,SAE6F;AAAA,MAAzF,aAAyF,SAAzF,aAAyF;AAAA,MAA1E,aAA0E,SAA1E,aAA0E;;AAE3F,MAAM,OAAO,sBAAO,OAAO,CAAC,QAAR,CAAiB,IAAI,MAAJ,CAAW,aAAX,EAA0B,IAA1B,CAAjB,CAAP,CAAb;;AACA,MAAM,qBAAqB,GAAG,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAArC;;AACA,MAAI,CAAC,qBAAL,EAA4B;AAC1B,WAAO,CAAC,KAAD,EAAQ,OAAR,CAAP;AACD;;AACD,SAAO,CACL,IADK,OAEF,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,qBAAqB,CAAC,KAAvC,CAFE,GAE8C,aAF9C,GAE8D,OAAO,CAAC,KAAR,CACjE,qBAAqB,CAAC,KAD2C,CAF9D,CAAP;AAMD","sourcesContent":["// runtime polyfills\nimport 'core-js/es/string/match-all';\n\n/**\n * @returns [`true`, modifiedContent: string] if replacement is successful, [`false`, originalContent] otherwise.\n */\nexport function replace(\n  content: string,\n  { replaceContent, replacePattern }: { replaceContent: string; replacePattern: string | RegExp }\n): [boolean, string] {\n  const replacePatternOccurrence = content.search(replacePattern);\n  if (replacePatternOccurrence !== -1) {\n    return [true, content.replace(replacePattern, replaceContent)];\n  }\n  return [false, content];\n}\n\n/**\n * Inserts content just before first occurrence of provided pattern.\n * @returns [`true`, modifiedContent: string] if insertion is successful, [`false`, originalContent] otherwise.\n */\nexport function insert(\n  content: string,\n  { insertContent, insertPattern }: { insertContent: string; insertPattern: RegExp | string },\n  insertBeforeLastOccurrence: boolean = false\n): [boolean, string] {\n  if (insertBeforeLastOccurrence) {\n    return insertBeforeLastOccurrenceFun(content, { insertContent, insertPattern });\n  }\n  const insertPatternOccurrence = content.search(insertPattern);\n  if (insertPatternOccurrence !== -1) {\n    return [\n      true,\n      `${content.slice(0, insertPatternOccurrence)}${insertContent}${content.slice(\n        insertPatternOccurrence\n      )}`,\n    ];\n  }\n  return [false, content];\n}\n\n/**\n * Finds last occurrence of provided pattern and inserts content just before it.\n *@returns [`true`, modifiedContent: string] if insertion is successful, [`false`, originalContent] otherwise.\n */\nfunction insertBeforeLastOccurrenceFun(\n  content: string,\n  { insertContent, insertPattern }: { insertContent: string; insertPattern: RegExp | string }\n): [boolean, string] {\n  const results = [...content.matchAll(new RegExp(insertPattern, 'gm'))];\n  const patternLastOccurrence = results[results.length - 1];\n  if (!patternLastOccurrence) {\n    return [false, content];\n  }\n  return [\n    true,\n    `${content.slice(0, patternLastOccurrence.index)}${insertContent}${content.slice(\n      patternLastOccurrence.index\n    )}`,\n  ];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}