{"ast":null,"code":"","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import { ConfigPlugin, ExportedConfig, Mod, ModPlatform, StaticPlugin } from '../Plugin.types';\nimport { PluginHistoryItem } from '../utils/history';\n/**\n * Resolves a list of plugins.\n *\n * @param config exported config\n * @param plugins list of config config plugins to apply to the exported config\n */\nexport declare const withPlugins: ConfigPlugin<(StaticPlugin | ConfigPlugin | string)[]>;\n/**\n * Prevents the same plugin from being run twice.\n * Used for migrating from unversioned expo config plugins to versioned plugins.\n *\n * @param config\n * @param name\n */\nexport declare const withRunOnce: ConfigPlugin<{\n    plugin: ConfigPlugin<void>;\n    name: PluginHistoryItem['name'];\n    version?: PluginHistoryItem['version'];\n}>;\n/**\n * Helper method for creating mods from existing config functions.\n *\n * @param action\n */\nexport declare function createRunOncePlugin<T>(plugin: ConfigPlugin<T>, name: string, version?: string): ConfigPlugin<T>;\n/**\n * Mods that don't modify any data, all unresolved functionality is performed inside a dangerous mod.\n * All dangerous mods run first before other mods.\n *\n * @param config\n * @param platform\n * @param action\n */\nexport declare const withDangerousMod: ConfigPlugin<[ModPlatform, Mod<unknown>]>;\n/**\n * Plugin to extend a mod function in the plugins config.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to extend\n * @param action method to run on the mod when the config is compiled\n */\nexport declare function withExtendedMod<T>(config: ExportedConfig, { platform, mod, action, }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n}): ExportedConfig;\n/**\n * Plugin to intercept execution of a given `mod` with the given `action`.\n * If an action was already set on the given `config` config for `mod`, then it\n * will be provided to the `action` as `nextMod` when it's evaluated, otherwise\n * `nextMod` will be an identity function.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to intercept\n * @param skipEmptyMod should skip running the action if there is no existing mod to intercept\n * @param action method to run on the mod when the config is compiled\n */\nexport declare function withInterceptedMod<T>(config: ExportedConfig, { platform, mod, action, skipEmptyMod, }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n    skipEmptyMod?: boolean;\n}): ExportedConfig;\n"]},"metadata":{},"sourceType":"module"}