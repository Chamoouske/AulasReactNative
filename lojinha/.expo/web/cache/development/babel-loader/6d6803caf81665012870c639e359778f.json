{"ast":null,"code":"'use strict';\n\nimport { Graph } from \"../src/Graph.js\";\nvar graph = null;\nbeforeEach(function () {\n  graph = new Graph();\n  graph.addEdge('A1', 'B1');\n  graph.addEdge('A2', 'B1');\n  graph.addEdge('A2', 'B2');\n  graph.addEdge('A3', 'B2');\n  graph.addEdge('A3', 'C3');\n  graph.addEdge('B1', 'C1');\n  graph.addEdge('B1', 'C2');\n  graph.addEdge('B1', 'C3');\n  graph.addEdge('B2', 'C2');\n});\n\nfunction expectOccursAfter(arr, id1, id2) {\n  var idx1 = arr.indexOf(id1);\n  var idx2 = arr.indexOf(id2);\n  expect(idx1).not.toBe(-1);\n  expect(idx2).not.toBe(-1);\n  expect(idx1).toBeGreaterThan(idx2);\n}\n\ntest('detects cycle', function () {\n  graph.addEdge('C2', 'A1');\n  expect(function () {\n    return graph.traverse(['A2']);\n  }).toThrow(/^Not a DAG/);\n});\ntest('checks for presence of root', function () {\n  expect(function () {\n    return graph.traverse(['A1', 'NX']);\n  }).toThrow(/^No node/);\n});\ntest('traverses partial graph', function () {\n  var ids = graph.traverse(['B1', 'A3']);\n  var sortedIds = ids.slice().sort();\n  expect(sortedIds).toEqual(['A3', 'B1', 'B2', 'C1', 'C2', 'C3']);\n  expectOccursAfter(ids, 'A3', 'B2');\n  expectOccursAfter(ids, 'A3', 'C3');\n  expectOccursAfter(ids, 'B1', 'C1');\n  expectOccursAfter(ids, 'B1', 'C2');\n  expectOccursAfter(ids, 'B1', 'C3');\n  expectOccursAfter(ids, 'B2', 'C2');\n});\ntest('traverses complete graph', function () {\n  var ids = graph.traverse(['A1', 'A2', 'A3']);\n  var sortedIds = ids.slice().sort();\n  expect(sortedIds).toEqual(['A1', 'A2', 'A3', 'B1', 'B2', 'C1', 'C2', 'C3']);\n  expectOccursAfter(ids, 'A1', 'B1');\n  expectOccursAfter(ids, 'A2', 'B1');\n  expectOccursAfter(ids, 'A2', 'B2');\n  expectOccursAfter(ids, 'A3', 'B2');\n  expectOccursAfter(ids, 'A3', 'C3');\n  expectOccursAfter(ids, 'B1', 'C1');\n  expectOccursAfter(ids, 'B1', 'C2');\n  expectOccursAfter(ids, 'B1', 'C3');\n  expectOccursAfter(ids, 'B2', 'C2');\n});","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/ReactCommon/hermes/inspector/tools/msggen/__tests__/GraphTest.js"],"names":["Graph","graph","beforeEach","addEdge","expectOccursAfter","arr","id1","id2","idx1","indexOf","idx2","expect","not","toBe","toBeGreaterThan","test","traverse","toThrow","ids","sortedIds","slice","sort","toEqual"],"mappings":"AAOA;;AAEA,SAASA,KAAT;AAGA,IAAIC,KAAK,GAAG,IAAZ;AAEAC,UAAU,CAAC,YAAM;AACfD,EAAAA,KAAK,GAAG,IAAID,KAAJ,EAAR;AACAC,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAF,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACD,CAXS,CAAV;;AAcA,SAASC,iBAAT,CAA2BC,GAA3B,EAAgCC,GAAhC,EAAqCC,GAArC,EAA0C;AACxC,MAAIC,IAAI,GAAGH,GAAG,CAACI,OAAJ,CAAYH,GAAZ,CAAX;AACA,MAAII,IAAI,GAAGL,GAAG,CAACI,OAAJ,CAAYF,GAAZ,CAAX;AAEAI,EAAAA,MAAM,CAACH,IAAD,CAAN,CAAaI,GAAb,CAAiBC,IAAjB,CAAsB,CAAC,CAAvB;AACAF,EAAAA,MAAM,CAACD,IAAD,CAAN,CAAaE,GAAb,CAAiBC,IAAjB,CAAsB,CAAC,CAAvB;AACAF,EAAAA,MAAM,CAACH,IAAD,CAAN,CAAaM,eAAb,CAA6BJ,IAA7B;AACD;;AAEDK,IAAI,CAAC,eAAD,EAAkB,YAAM;AAC1Bd,EAAAA,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoB,IAApB;AACAQ,EAAAA,MAAM,CAAC;AAAA,WAAMV,KAAK,CAACe,QAAN,CAAe,CAAC,IAAD,CAAf,CAAN;AAAA,GAAD,CAAN,CAAqCC,OAArC,CAA6C,YAA7C;AACD,CAHG,CAAJ;AAKAF,IAAI,CAAC,6BAAD,EAAgC,YAAM;AACxCJ,EAAAA,MAAM,CAAC;AAAA,WAAMV,KAAK,CAACe,QAAN,CAAe,CAAC,IAAD,EAAO,IAAP,CAAf,CAAN;AAAA,GAAD,CAAN,CAA2CC,OAA3C,CAAmD,UAAnD;AACD,CAFG,CAAJ;AAIAF,IAAI,CAAC,yBAAD,EAA4B,YAAM;AACpC,MAAIG,GAAG,GAAGjB,KAAK,CAACe,QAAN,CAAe,CAAC,IAAD,EAAO,IAAP,CAAf,CAAV;AAGA,MAAIG,SAAS,GAAGD,GAAG,CAACE,KAAJ,GAAYC,IAAZ,EAAhB;AACAV,EAAAA,MAAM,CAACQ,SAAD,CAAN,CAAkBG,OAAlB,CAA0B,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAA1B;AAGAlB,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACD,CAdG,CAAJ;AAgBAH,IAAI,CAAC,0BAAD,EAA6B,YAAM;AACrC,MAAIG,GAAG,GAAGjB,KAAK,CAACe,QAAN,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAAV;AAGA,MAAIG,SAAS,GAAGD,GAAG,CAACE,KAAJ,GAAYC,IAAZ,EAAhB;AACAV,EAAAA,MAAM,CAACQ,SAAD,CAAN,CAAkBG,OAAlB,CAA0B,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAA1B;AAGAlB,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACAd,EAAAA,iBAAiB,CAACc,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAjB;AACD,CAjBG,CAAJ","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nimport { Graph } from '../src/Graph.js';\n\n// graph looks like this before test: https://pxl.cl/9k8t\nlet graph = null;\n\nbeforeEach(() => {\n  graph = new Graph();\n  graph.addEdge('A1', 'B1');\n  graph.addEdge('A2', 'B1');\n  graph.addEdge('A2', 'B2');\n  graph.addEdge('A3', 'B2');\n  graph.addEdge('A3', 'C3');\n  graph.addEdge('B1', 'C1');\n  graph.addEdge('B1', 'C2');\n  graph.addEdge('B1', 'C3');\n  graph.addEdge('B2', 'C2');\n});\n\n// checks id1 occurs after id2 in arr\nfunction expectOccursAfter(arr, id1, id2) {\n  let idx1 = arr.indexOf(id1);\n  let idx2 = arr.indexOf(id2);\n\n  expect(idx1).not.toBe(-1);\n  expect(idx2).not.toBe(-1);\n  expect(idx1).toBeGreaterThan(idx2);\n}\n\ntest('detects cycle', () => {\n  graph.addEdge('C2', 'A1');\n  expect(() => graph.traverse(['A2'])).toThrow(/^Not a DAG/);\n});\n\ntest('checks for presence of root', () => {\n  expect(() => graph.traverse(['A1', 'NX'])).toThrow(/^No node/);\n});\n\ntest('traverses partial graph', () => {\n  let ids = graph.traverse(['B1', 'A3']);\n\n  // Check that expected nodes are there\n  let sortedIds = ids.slice().sort();\n  expect(sortedIds).toEqual(['A3', 'B1', 'B2', 'C1', 'C2', 'C3']);\n\n  // Check that the result is topologically sorted\n  expectOccursAfter(ids, 'A3', 'B2');\n  expectOccursAfter(ids, 'A3', 'C3');\n  expectOccursAfter(ids, 'B1', 'C1');\n  expectOccursAfter(ids, 'B1', 'C2');\n  expectOccursAfter(ids, 'B1', 'C3');\n  expectOccursAfter(ids, 'B2', 'C2');\n});\n\ntest('traverses complete graph', () => {\n  let ids = graph.traverse(['A1', 'A2', 'A3']);\n\n  // Check that expected nodes are there\n  let sortedIds = ids.slice().sort();\n  expect(sortedIds).toEqual(['A1', 'A2', 'A3', 'B1', 'B2', 'C1', 'C2', 'C3']);\n\n  // Check that the result is topologically sorted\n  expectOccursAfter(ids, 'A1', 'B1');\n  expectOccursAfter(ids, 'A2', 'B1');\n  expectOccursAfter(ids, 'A2', 'B2');\n  expectOccursAfter(ids, 'A3', 'B2');\n  expectOccursAfter(ids, 'A3', 'C3');\n  expectOccursAfter(ids, 'B1', 'C1');\n  expectOccursAfter(ids, 'B1', 'C2');\n  expectOccursAfter(ids, 'B1', 'C3');\n  expectOccursAfter(ids, 'B2', 'C2');\n});\n"]},"metadata":{},"sourceType":"module"}