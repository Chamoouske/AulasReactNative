{"ast":null,"code":"'use strict';\n\njest.mock(\"../../vendor/core/ErrorUtils\").mock('../../BatchedBridge/BatchedBridge');\nvar isWindows = process.platform === 'win32';\n\nfunction expectToBeCalledOnce(fn) {\n  if (isWindows) {\n    return;\n  }\n\n  expect(fn.mock.calls.length).toBe(1);\n}\n\ndescribe('InteractionManager', function () {\n  var InteractionManager;\n  var interactionStart;\n  var interactionComplete;\n  beforeEach(function () {\n    jest.resetModules();\n    InteractionManager = require(\"../InteractionManager\");\n    interactionStart = jest.fn();\n    interactionComplete = jest.fn();\n    InteractionManager.addListener(InteractionManager.Events.interactionStart, interactionStart);\n    InteractionManager.addListener(InteractionManager.Events.interactionComplete, interactionComplete);\n  });\n  it('throws when clearing an undefined handle', function () {\n    expect(function () {\n      return InteractionManager.clearInteractionHandle();\n    }).toThrow();\n  });\n  it('notifies asynchronously when interaction starts', function () {\n    InteractionManager.createInteractionHandle();\n    expect(interactionStart).not.toBeCalled();\n    jest.runAllTimers();\n    expect(interactionStart).toBeCalled();\n    expect(interactionComplete).not.toBeCalled();\n  });\n  it('notifies asynchronously when interaction stops', function () {\n    var handle = InteractionManager.createInteractionHandle();\n    jest.runAllTimers();\n    interactionStart.mockClear();\n    InteractionManager.clearInteractionHandle(handle);\n    expect(interactionComplete).not.toBeCalled();\n    jest.runAllTimers();\n    expect(interactionStart).not.toBeCalled();\n    expect(interactionComplete).toBeCalled();\n  });\n  it('does not notify when started & stopped in same event loop', function () {\n    var handle = InteractionManager.createInteractionHandle();\n    InteractionManager.clearInteractionHandle(handle);\n    jest.runAllTimers();\n    expect(interactionStart).not.toBeCalled();\n    expect(interactionComplete).not.toBeCalled();\n  });\n  it('does not notify when going from two -> one active interactions', function () {\n    InteractionManager.createInteractionHandle();\n    var handle = InteractionManager.createInteractionHandle();\n    jest.runAllTimers();\n    interactionStart.mockClear();\n    interactionComplete.mockClear();\n    InteractionManager.clearInteractionHandle(handle);\n    jest.runAllTimers();\n    expect(interactionStart).not.toBeCalled();\n    expect(interactionComplete).not.toBeCalled();\n  });\n  it('runs tasks asynchronously when there are interactions', function () {\n    var task = jest.fn();\n    InteractionManager.runAfterInteractions(task);\n    expect(task).not.toBeCalled();\n    jest.runAllTimers();\n    expect(task).toBeCalled();\n  });\n  it('runs tasks when interactions complete', function () {\n    var task = jest.fn();\n    var handle = InteractionManager.createInteractionHandle();\n    InteractionManager.runAfterInteractions(task);\n    jest.runAllTimers();\n    InteractionManager.clearInteractionHandle(handle);\n    expect(task).not.toBeCalled();\n    jest.runAllTimers();\n    expect(task).toBeCalled();\n  });\n  it('does not run tasks twice', function () {\n    var task1 = jest.fn();\n    var task2 = jest.fn();\n    InteractionManager.runAfterInteractions(task1);\n    jest.runAllTimers();\n    InteractionManager.runAfterInteractions(task2);\n    jest.runAllTimers();\n    expectToBeCalledOnce(task1);\n  });\n  it('runs tasks added while processing previous tasks', function () {\n    var task1 = jest.fn(function () {\n      InteractionManager.runAfterInteractions(task2);\n    });\n    var task2 = jest.fn();\n    InteractionManager.runAfterInteractions(task1);\n    expect(task2).not.toBeCalled();\n    jest.runAllTimers();\n    expect(task1).toBeCalled();\n    expect(task2).toBeCalled();\n  });\n  it('allows tasks to be cancelled', function () {\n    var task1 = jest.fn();\n    var task2 = jest.fn();\n    var promise1 = InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions(task2);\n    expect(task1).not.toBeCalled();\n    expect(task2).not.toBeCalled();\n    promise1.cancel();\n    jest.runAllTimers();\n    expect(task1).not.toBeCalled();\n    expect(task2).toBeCalled();\n  });\n});\ndescribe('promise tasks', function () {\n  var InteractionManager;\n  var BatchedBridge;\n  var sequenceId;\n\n  function createSequenceTask(expectedSequenceId) {\n    return jest.fn(function () {\n      expect(++sequenceId).toBe(expectedSequenceId);\n    });\n  }\n\n  beforeEach(function () {\n    jest.resetModules();\n    jest.useFakeTimers();\n    InteractionManager = require(\"../InteractionManager\");\n    BatchedBridge = require(\"../../BatchedBridge/BatchedBridge\");\n    sequenceId = 0;\n  });\n  it('should run a basic promise task', function () {\n    var task1 = jest.fn(function () {\n      expect(++sequenceId).toBe(1);\n      return new Promise(function (resolve) {\n        return resolve();\n      });\n    });\n    InteractionManager.runAfterInteractions({\n      gen: task1,\n      name: 'gen1'\n    });\n    jest.runAllTimers();\n    expectToBeCalledOnce(task1);\n  });\n  it('should handle nested promises', function () {\n    var task1 = jest.fn(function () {\n      expect(++sequenceId).toBe(1);\n      return new Promise(function (resolve) {\n        InteractionManager.runAfterInteractions({\n          gen: task2,\n          name: 'gen2'\n        }).then(resolve);\n      });\n    });\n    var task2 = jest.fn(function () {\n      expect(++sequenceId).toBe(2);\n      return new Promise(function (resolve) {\n        return resolve();\n      });\n    });\n    InteractionManager.runAfterInteractions({\n      gen: task1,\n      name: 'gen1'\n    });\n    jest.runAllTimers();\n    expectToBeCalledOnce(task1);\n    expectToBeCalledOnce(task2);\n  });\n  it('should pause promise tasks during interactions then resume', function () {\n    var task1 = createSequenceTask(1);\n    var task2 = jest.fn(function () {\n      expect(++sequenceId).toBe(2);\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          InteractionManager.runAfterInteractions(task3).then(resolve);\n        }, 1);\n      });\n    });\n    var task3 = createSequenceTask(3);\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions({\n      gen: task2,\n      name: 'gen2'\n    });\n    jest.runOnlyPendingTimers();\n    expectToBeCalledOnce(task1);\n    expectToBeCalledOnce(task2);\n    var handle = InteractionManager.createInteractionHandle();\n    jest.runAllTimers();\n    jest.runAllTimers();\n    expect(task3).not.toBeCalled();\n    InteractionManager.clearInteractionHandle(handle);\n    jest.runAllTimers();\n    expectToBeCalledOnce(task3);\n  });\n  it('should execute tasks in loop within deadline', function () {\n    InteractionManager.setDeadline(100);\n    BatchedBridge.getEventLoopRunningTime.mockReturnValue(10);\n    var task1 = createSequenceTask(1);\n    var task2 = createSequenceTask(2);\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions(task2);\n    jest.runOnlyPendingTimers();\n    expectToBeCalledOnce(task1);\n    expectToBeCalledOnce(task2);\n  });\n  it('should execute tasks one at a time if deadline exceeded', function () {\n    InteractionManager.setDeadline(100);\n    BatchedBridge.getEventLoopRunningTime.mockReturnValue(200);\n    var task1 = createSequenceTask(1);\n    var task2 = createSequenceTask(2);\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions(task2);\n    jest.runOnlyPendingTimers();\n    expectToBeCalledOnce(task1);\n    expect(task2).not.toBeCalled();\n    jest.runOnlyPendingTimers();\n    jest.runOnlyPendingTimers();\n    expectToBeCalledOnce(task2);\n  });\n\n  var bigAsyncTest = function bigAsyncTest(resolveTest) {\n    jest.useRealTimers();\n    var task1 = createSequenceTask(1);\n    var task2 = jest.fn(function () {\n      expect(++sequenceId).toBe(2);\n      return new Promise(function (resolve) {\n        InteractionManager.runAfterInteractions(task3);\n        setTimeout(function () {\n          InteractionManager.runAfterInteractions({\n            gen: task4,\n            name: 'gen4'\n          }).then(resolve);\n        }, 1);\n      });\n    });\n    var task3 = createSequenceTask(3);\n    var task4 = jest.fn(function () {\n      expect(++sequenceId).toBe(4);\n      return new Promise(function (resolve) {\n        InteractionManager.runAfterInteractions(task5).then(resolve);\n      });\n    });\n    var task5 = createSequenceTask(5);\n    var task6 = createSequenceTask(6);\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions({\n      gen: task2,\n      name: 'gen2'\n    });\n    InteractionManager.runAfterInteractions(task6);\n    setTimeout(function () {\n      expectToBeCalledOnce(task1);\n      expectToBeCalledOnce(task2);\n      expectToBeCalledOnce(task3);\n      expectToBeCalledOnce(task4);\n      expectToBeCalledOnce(task5);\n      expectToBeCalledOnce(task6);\n      resolveTest();\n    }, 100);\n  };\n\n  it('resolves async tasks recursively before other queued tasks', function () {\n    return new Promise(bigAsyncTest);\n  });\n  it('should also work with a deadline', function () {\n    InteractionManager.setDeadline(100);\n    BatchedBridge.getEventLoopRunningTime.mockReturnValue(200);\n    return new Promise(bigAsyncTest);\n  });\n});","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/Libraries/Interaction/__tests__/InteractionManager-test.js"],"names":["jest","mock","isWindows","process","platform","expectToBeCalledOnce","fn","expect","calls","length","toBe","describe","InteractionManager","interactionStart","interactionComplete","beforeEach","resetModules","require","addListener","Events","it","clearInteractionHandle","toThrow","createInteractionHandle","not","toBeCalled","runAllTimers","handle","mockClear","task","runAfterInteractions","task1","task2","promise1","cancel","BatchedBridge","sequenceId","createSequenceTask","expectedSequenceId","useFakeTimers","Promise","resolve","gen","name","then","setTimeout","task3","runOnlyPendingTimers","setDeadline","getEventLoopRunningTime","mockReturnValue","bigAsyncTest","resolveTest","useRealTimers","task4","task5","task6"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @emails oncall+react_native\n */\n\n'use strict';\n\njest\n  .mock('../../vendor/core/ErrorUtils')\n  .mock('../../BatchedBridge/BatchedBridge');\n\nconst isWindows = process.platform === 'win32';\nfunction expectToBeCalledOnce(fn) {\n  // todo fix this test case on windows\n  if (isWindows) {\n    return;\n  }\n  expect(fn.mock.calls.length).toBe(1);\n}\n\ndescribe('InteractionManager', () => {\n  let InteractionManager;\n  let interactionStart;\n  let interactionComplete;\n\n  beforeEach(() => {\n    jest.resetModules();\n    InteractionManager = require('../InteractionManager');\n\n    interactionStart = jest.fn();\n    interactionComplete = jest.fn();\n\n    InteractionManager.addListener(\n      InteractionManager.Events.interactionStart,\n      interactionStart,\n    );\n    InteractionManager.addListener(\n      InteractionManager.Events.interactionComplete,\n      interactionComplete,\n    );\n  });\n\n  it('throws when clearing an undefined handle', () => {\n    expect(() => InteractionManager.clearInteractionHandle()).toThrow();\n  });\n\n  it('notifies asynchronously when interaction starts', () => {\n    InteractionManager.createInteractionHandle();\n    expect(interactionStart).not.toBeCalled();\n\n    jest.runAllTimers();\n    expect(interactionStart).toBeCalled();\n    expect(interactionComplete).not.toBeCalled();\n  });\n\n  it('notifies asynchronously when interaction stops', () => {\n    const handle = InteractionManager.createInteractionHandle();\n    jest.runAllTimers();\n    interactionStart.mockClear();\n    InteractionManager.clearInteractionHandle(handle);\n    expect(interactionComplete).not.toBeCalled();\n\n    jest.runAllTimers();\n    expect(interactionStart).not.toBeCalled();\n    expect(interactionComplete).toBeCalled();\n  });\n\n  it('does not notify when started & stopped in same event loop', () => {\n    const handle = InteractionManager.createInteractionHandle();\n    InteractionManager.clearInteractionHandle(handle);\n\n    jest.runAllTimers();\n    expect(interactionStart).not.toBeCalled();\n    expect(interactionComplete).not.toBeCalled();\n  });\n\n  it('does not notify when going from two -> one active interactions', () => {\n    InteractionManager.createInteractionHandle();\n    const handle = InteractionManager.createInteractionHandle();\n    jest.runAllTimers();\n\n    interactionStart.mockClear();\n    interactionComplete.mockClear();\n\n    InteractionManager.clearInteractionHandle(handle);\n    jest.runAllTimers();\n    expect(interactionStart).not.toBeCalled();\n    expect(interactionComplete).not.toBeCalled();\n  });\n\n  it('runs tasks asynchronously when there are interactions', () => {\n    const task = jest.fn();\n    InteractionManager.runAfterInteractions(task);\n    expect(task).not.toBeCalled();\n\n    jest.runAllTimers();\n    expect(task).toBeCalled();\n  });\n\n  it('runs tasks when interactions complete', () => {\n    const task = jest.fn();\n    const handle = InteractionManager.createInteractionHandle();\n    InteractionManager.runAfterInteractions(task);\n\n    jest.runAllTimers();\n    InteractionManager.clearInteractionHandle(handle);\n    expect(task).not.toBeCalled();\n\n    jest.runAllTimers();\n    expect(task).toBeCalled();\n  });\n\n  it('does not run tasks twice', () => {\n    const task1 = jest.fn();\n    const task2 = jest.fn();\n    InteractionManager.runAfterInteractions(task1);\n    jest.runAllTimers();\n\n    InteractionManager.runAfterInteractions(task2);\n    jest.runAllTimers();\n\n    expectToBeCalledOnce(task1);\n  });\n\n  it('runs tasks added while processing previous tasks', () => {\n    const task1 = jest.fn(() => {\n      InteractionManager.runAfterInteractions(task2);\n    });\n    const task2 = jest.fn();\n\n    InteractionManager.runAfterInteractions(task1);\n    expect(task2).not.toBeCalled();\n\n    jest.runAllTimers();\n\n    expect(task1).toBeCalled();\n    expect(task2).toBeCalled();\n  });\n\n  it('allows tasks to be cancelled', () => {\n    const task1 = jest.fn();\n    const task2 = jest.fn();\n    const promise1 = InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions(task2);\n    expect(task1).not.toBeCalled();\n    expect(task2).not.toBeCalled();\n    promise1.cancel();\n\n    jest.runAllTimers();\n    expect(task1).not.toBeCalled();\n    expect(task2).toBeCalled();\n  });\n});\n\ndescribe('promise tasks', () => {\n  let InteractionManager;\n  let BatchedBridge;\n  let sequenceId;\n  function createSequenceTask(expectedSequenceId) {\n    return jest.fn(() => {\n      expect(++sequenceId).toBe(expectedSequenceId);\n    });\n  }\n  beforeEach(() => {\n    jest.resetModules();\n    jest.useFakeTimers();\n    InteractionManager = require('../InteractionManager');\n    BatchedBridge = require('../../BatchedBridge/BatchedBridge');\n    sequenceId = 0;\n  });\n\n  it('should run a basic promise task', () => {\n    const task1 = jest.fn(() => {\n      expect(++sequenceId).toBe(1);\n      return new Promise(resolve => resolve());\n    });\n    InteractionManager.runAfterInteractions({gen: task1, name: 'gen1'});\n    jest.runAllTimers();\n    expectToBeCalledOnce(task1);\n  });\n\n  it('should handle nested promises', () => {\n    const task1 = jest.fn(() => {\n      expect(++sequenceId).toBe(1);\n      return new Promise(resolve => {\n        InteractionManager.runAfterInteractions({\n          gen: task2,\n          name: 'gen2',\n        }).then(resolve);\n      });\n    });\n    const task2 = jest.fn(() => {\n      expect(++sequenceId).toBe(2);\n      return new Promise(resolve => resolve());\n    });\n    InteractionManager.runAfterInteractions({gen: task1, name: 'gen1'});\n    jest.runAllTimers();\n    expectToBeCalledOnce(task1);\n    expectToBeCalledOnce(task2);\n  });\n\n  it('should pause promise tasks during interactions then resume', () => {\n    const task1 = createSequenceTask(1);\n    const task2 = jest.fn(() => {\n      expect(++sequenceId).toBe(2);\n      return new Promise(resolve => {\n        setTimeout(() => {\n          InteractionManager.runAfterInteractions(task3).then(resolve);\n        }, 1);\n      });\n    });\n    const task3 = createSequenceTask(3);\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions({gen: task2, name: 'gen2'});\n    jest.runOnlyPendingTimers();\n    expectToBeCalledOnce(task1);\n    expectToBeCalledOnce(task2);\n    const handle = InteractionManager.createInteractionHandle();\n    jest.runAllTimers();\n    jest.runAllTimers(); // Just to be sure...\n    expect(task3).not.toBeCalled();\n    InteractionManager.clearInteractionHandle(handle);\n    jest.runAllTimers();\n    expectToBeCalledOnce(task3);\n  });\n\n  it('should execute tasks in loop within deadline', () => {\n    InteractionManager.setDeadline(100);\n    BatchedBridge.getEventLoopRunningTime.mockReturnValue(10);\n    const task1 = createSequenceTask(1);\n    const task2 = createSequenceTask(2);\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions(task2);\n\n    jest.runOnlyPendingTimers();\n\n    expectToBeCalledOnce(task1);\n    expectToBeCalledOnce(task2);\n  });\n\n  it('should execute tasks one at a time if deadline exceeded', () => {\n    InteractionManager.setDeadline(100);\n    BatchedBridge.getEventLoopRunningTime.mockReturnValue(200);\n    const task1 = createSequenceTask(1);\n    const task2 = createSequenceTask(2);\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions(task2);\n\n    jest.runOnlyPendingTimers();\n\n    expectToBeCalledOnce(task1);\n    expect(task2).not.toBeCalled();\n\n    jest.runOnlyPendingTimers(); // resolve1\n    jest.runOnlyPendingTimers(); // task2\n\n    expectToBeCalledOnce(task2);\n  });\n\n  const bigAsyncTest = resolveTest => {\n    jest.useRealTimers();\n\n    const task1 = createSequenceTask(1);\n    const task2 = jest.fn(() => {\n      expect(++sequenceId).toBe(2);\n      return new Promise(resolve => {\n        InteractionManager.runAfterInteractions(task3);\n        setTimeout(() => {\n          InteractionManager.runAfterInteractions({\n            gen: task4,\n            name: 'gen4',\n          }).then(resolve);\n        }, 1);\n      });\n    });\n    const task3 = createSequenceTask(3);\n    const task4 = jest.fn(() => {\n      expect(++sequenceId).toBe(4);\n      return new Promise(resolve => {\n        InteractionManager.runAfterInteractions(task5).then(resolve);\n      });\n    });\n    const task5 = createSequenceTask(5);\n    const task6 = createSequenceTask(6);\n\n    InteractionManager.runAfterInteractions(task1);\n    InteractionManager.runAfterInteractions({gen: task2, name: 'gen2'});\n    InteractionManager.runAfterInteractions(task6);\n\n    setTimeout(() => {\n      expectToBeCalledOnce(task1);\n      expectToBeCalledOnce(task2);\n      expectToBeCalledOnce(task3);\n      expectToBeCalledOnce(task4);\n      expectToBeCalledOnce(task5);\n      expectToBeCalledOnce(task6);\n\n      resolveTest();\n    }, 100);\n  };\n\n  it('resolves async tasks recursively before other queued tasks', () => {\n    return new Promise(bigAsyncTest);\n  });\n\n  it('should also work with a deadline', () => {\n    InteractionManager.setDeadline(100);\n    BatchedBridge.getEventLoopRunningTime.mockReturnValue(200);\n    return new Promise(bigAsyncTest);\n  });\n});\n"]},"metadata":{},"sourceType":"script"}