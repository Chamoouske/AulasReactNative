{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar getenv_1 = require(\"getenv\");\n\nvar errors_1 = require(\"../utils/errors\");\n\nvar plugin_resolver_1 = require(\"../utils/plugin-resolver\");\n\nvar EXPO_DEBUG = getenv_1.boolish('EXPO_DEBUG', false);\nvar EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = getenv_1.boolish('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\n\nfunction isModuleMissingError(name, error) {\n  if (error.code === 'MODULE_NOT_FOUND') {\n    return true;\n  }\n\n  return error.message.includes(\"Cannot find module '\" + name + \"'\");\n}\n\nfunction isUnexpectedTokenError(error) {\n  if (error instanceof SyntaxError) {\n    return !!error.message.match(/Unexpected token/) || !!error.message.match(/Cannot use import statement/);\n  }\n\n  return false;\n}\n\nexports.withStaticPlugin = function (config, props) {\n  var _a;\n\n  var projectRoot = props.projectRoot;\n\n  if (!projectRoot) {\n    projectRoot = (_a = config._internal) === null || _a === void 0 ? void 0 : _a.projectRoot;\n    plugin_resolver_1.assertInternalProjectRoot(projectRoot);\n  }\n\n  var _plugin_resolver_1$no = plugin_resolver_1.normalizeStaticPlugin(props.plugin),\n      _plugin_resolver_1$no2 = _slicedToArray(_plugin_resolver_1$no, 2),\n      pluginResolve = _plugin_resolver_1$no2[0],\n      pluginProps = _plugin_resolver_1$no2[1];\n\n  errors_1.assert(!(pluginProps === null || pluginProps === void 0 ? void 0 : pluginProps._resolverError), \"Plugin property '_resolverError' is a reserved property of `withStaticPlugin`\");\n  var withPlugin;\n\n  if (typeof pluginResolve === 'function') {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      withPlugin = plugin_resolver_1.resolveConfigPluginFunction(projectRoot, pluginResolve);\n    } catch (error) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          console.log(\"Error resolving plugin \\\"\" + pluginResolve + \"\\\"\");\n          console.log(error);\n          console.log();\n        } else {\n          var shouldMuteWarning = props._isLegacyPlugin && (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              console.log(\"Could not find plugin \\\"\" + pluginResolve + \"\\\"\");\n            } else {\n              console.log(\"Error resolving plugin \\\"\" + pluginResolve + \"\\\"\");\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        throw error;\n      }\n    }\n  } else {\n    throw new errors_1.PluginError(\"Plugin is an unexpected type: \" + typeof pluginResolve, 'INVALID_PLUGIN_TYPE');\n  }\n\n  config = withPlugin(config, pluginProps);\n  return config;\n};","map":{"version":3,"sources":["../../src/plugins/static-plugins.ts"],"names":[],"mappings":"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","sourcesContent":["import { boolish } from 'getenv';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { assert, PluginError } from '../utils/errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n} from '../utils/plugin-resolver';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\nconst EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = boolish('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\n\nfunction isModuleMissingError(name: string, error: Error): boolean {\n  // @ts-ignore\n  if (error.code === 'MODULE_NOT_FOUND') {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\n\nfunction isUnexpectedTokenError(error: Error): boolean {\n  if (error instanceof SyntaxError) {\n    return (\n      // These are the most common errors that'll be thrown when a package isn't transpiled correctly.\n      !!error.message.match(/Unexpected token/) ||\n      !!error.message.match(/Cannot use import statement/)\n    );\n  }\n  return false;\n}\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n * @param _isLegacyPlugin Used to suppress errors thrown by plugins that are applied automatically\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | ConfigPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n  _isLegacyPlugin?: boolean;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n  // Function was provided, no need to resolve: [withPlugin, {}]\n  if (typeof pluginResolve === 'function') {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n    } catch (error) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        } else {\n          const shouldMuteWarning =\n            props._isLegacyPlugin &&\n            (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              // Prevent causing log spew for basic resolution errors.\n              console.log(`Could not find plugin \"${pluginResolve}\"`);\n            } else {\n              // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n              console.log(`Error resolving plugin \"${pluginResolve}\"`);\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n      // TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new PluginError(\n      `Plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}