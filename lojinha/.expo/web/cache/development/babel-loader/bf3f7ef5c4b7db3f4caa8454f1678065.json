{"ast":null,"code":"var _NativeModulesProxy$E, _NativeModulesProxy$E2;\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { NativeModulesProxy } from '@unimodules/core';\nimport computeMd5 from 'blueimp-md5';\nimport Constants from 'expo-constants';\nimport * as FileSystem from 'expo-file-system';\nimport { getManifestBaseUrl } from \"./AssetUris\";\nexport var IS_MANAGED_ENV = !!Constants.appOwnership;\nexport var IS_BARE_ENV_WITH_UPDATES = !IS_MANAGED_ENV && !!((_NativeModulesProxy$E = NativeModulesProxy.ExpoUpdates) != null && _NativeModulesProxy$E.isEnabled) && !((_NativeModulesProxy$E2 = NativeModulesProxy.ExpoUpdates) != null && _NativeModulesProxy$E2.isUsingEmbeddedAssets);\nexport var IS_ENV_WITH_UPDATES_ENABLED = IS_MANAGED_ENV || IS_BARE_ENV_WITH_UPDATES;\nexport var IS_BARE_ENV_WITHOUT_UPDATES = !IS_MANAGED_ENV && !IS_BARE_ENV_WITH_UPDATES;\nexport function getLocalAssets() {\n  var _NativeModulesProxy$E3, _NativeModulesProxy$E4;\n\n  return (_NativeModulesProxy$E3 = (_NativeModulesProxy$E4 = NativeModulesProxy.ExpoUpdates) == null ? void 0 : _NativeModulesProxy$E4.localAssets) != null ? _NativeModulesProxy$E3 : {};\n}\nexport function getManifest() {\n  var _Constants$manifest;\n\n  return (_Constants$manifest = Constants.manifest) != null ? _Constants$manifest : {};\n}\nexport var manifestBaseUrl = Constants.experienceUrl ? getManifestBaseUrl(Constants.experienceUrl) : null;\nexport function downloadAsync(uri, hash, type, name) {\n  return _regeneratorRuntime.async(function downloadAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!IS_MANAGED_ENV) {\n            _context.next = 2;\n            break;\n          }\n\n          return _context.abrupt(\"return\", _downloadAsyncManagedEnv(uri, hash, type, name));\n\n        case 2:\n          return _context.abrupt(\"return\", _downloadAsyncUnmanagedEnv(uri, hash, type));\n\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _downloadAsyncManagedEnv(uri, hash, type, name) {\n  var cacheFileId, localUri, _await$FileSystem$get, exists, md5, _await$FileSystem$dow;\n\n  return _regeneratorRuntime.async(function _downloadAsyncManagedEnv$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          cacheFileId = hash || computeMd5(uri);\n          localUri = FileSystem.cacheDirectory + \"ExponentAsset-\" + cacheFileId + \".\" + type;\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(FileSystem.getInfoAsync(localUri, {\n            md5: true\n          }));\n\n        case 4:\n          _await$FileSystem$get = _context2.sent;\n          exists = _await$FileSystem$get.exists;\n          md5 = _await$FileSystem$get.md5;\n\n          if (!(!exists || hash !== null && md5 !== hash)) {\n            _context2.next = 14;\n            break;\n          }\n\n          _context2.next = 10;\n          return _regeneratorRuntime.awrap(FileSystem.downloadAsync(uri, localUri, {\n            md5: true\n          }));\n\n        case 10:\n          _await$FileSystem$dow = _context2.sent;\n          md5 = _await$FileSystem$dow.md5;\n\n          if (!(hash !== null && md5 !== hash)) {\n            _context2.next = 14;\n            break;\n          }\n\n          throw new Error(\"Downloaded file for asset '\" + name + \".\" + type + \"' \" + (\"Located at \" + uri + \" \") + \"failed MD5 integrity check\");\n\n        case 14:\n          return _context2.abrupt(\"return\", localUri);\n\n        case 15:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _downloadAsyncUnmanagedEnv(uri, hash, type) {\n  var cacheFileId, localUri;\n  return _regeneratorRuntime.async(function _downloadAsyncUnmanagedEnv$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!uri.startsWith('file://')) {\n            _context3.next = 2;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", uri);\n\n        case 2:\n          cacheFileId = hash || computeMd5(uri);\n          localUri = FileSystem.cacheDirectory + \"ExponentAsset-\" + cacheFileId + \".\" + type;\n          _context3.next = 6;\n          return _regeneratorRuntime.awrap(FileSystem.downloadAsync(uri, localUri));\n\n        case 6:\n          return _context3.abrupt(\"return\", localUri);\n\n        case 7:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/expo-asset/src/PlatformUtils.ts"],"names":["NativeModulesProxy","computeMd5","Constants","FileSystem","getManifestBaseUrl","IS_MANAGED_ENV","appOwnership","IS_BARE_ENV_WITH_UPDATES","ExpoUpdates","isEnabled","isUsingEmbeddedAssets","IS_ENV_WITH_UPDATES_ENABLED","IS_BARE_ENV_WITHOUT_UPDATES","getLocalAssets","localAssets","getManifest","manifest","manifestBaseUrl","experienceUrl","downloadAsync","uri","hash","type","name","_downloadAsyncManagedEnv","_downloadAsyncUnmanagedEnv","cacheFileId","localUri","cacheDirectory","getInfoAsync","md5","exists","Error","startsWith"],"mappings":"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","sourcesContent":["import { NativeModulesProxy } from '@unimodules/core';\nimport computeMd5 from 'blueimp-md5';\nimport Constants from 'expo-constants';\nimport * as FileSystem from 'expo-file-system';\n\nimport { getManifestBaseUrl } from './AssetUris';\n\n// Constants.appOwnership is only available in managed apps (Expo client and standalone)\nexport const IS_MANAGED_ENV = !!Constants.appOwnership;\n\n// In the future (SDK38+) expo-updates is likely to be used in managed apps, so we decide\n// that you are in a bare app with updates if you're not in a managed app and you have\n// local assets available.\nexport const IS_BARE_ENV_WITH_UPDATES =\n  !IS_MANAGED_ENV &&\n  !!NativeModulesProxy.ExpoUpdates?.isEnabled &&\n  // if expo-updates is installed but we're running directly from the embedded bundle, we don't want\n  // to override the AssetSourceResolver\n  !NativeModulesProxy.ExpoUpdates?.isUsingEmbeddedAssets;\n\nexport const IS_ENV_WITH_UPDATES_ENABLED = IS_MANAGED_ENV || IS_BARE_ENV_WITH_UPDATES;\n\n// If it's not managed or bare w/ updates, then it must be bare w/o updates!\nexport const IS_BARE_ENV_WITHOUT_UPDATES = !IS_MANAGED_ENV && !IS_BARE_ENV_WITH_UPDATES;\n\n// Get the localAssets property from the ExpoUpdates native module so that we do\n// not need to include expo-updates as a dependency of expo-asset\nexport function getLocalAssets() {\n  return NativeModulesProxy.ExpoUpdates?.localAssets ?? {};\n}\n\nexport function getManifest(): { [key: string]: any } {\n  return Constants.manifest ?? {};\n}\n\n// Compute manifest base URL if available\nexport const manifestBaseUrl = Constants.experienceUrl\n  ? getManifestBaseUrl(Constants.experienceUrl)\n  : null;\n\n// TODO: how should this behave in bare app with updates? re: hashAssetFiles\nexport async function downloadAsync(uri, hash, type, name): Promise<string> {\n  if (IS_MANAGED_ENV) {\n    return _downloadAsyncManagedEnv(uri, hash, type, name);\n  }\n\n  return _downloadAsyncUnmanagedEnv(uri, hash, type);\n}\n\n/**\n * Check if the file exists on disk already, perform integrity check if so.\n * Otherwise, download it.\n */\nasync function _downloadAsyncManagedEnv(uri, hash, type, name): Promise<string> {\n  const cacheFileId = hash || computeMd5(uri);\n  const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${type}`;\n  let { exists, md5 } = await FileSystem.getInfoAsync(localUri, {\n    md5: true,\n  });\n  if (!exists || (hash !== null && md5 !== hash)) {\n    ({ md5 } = await FileSystem.downloadAsync(uri, localUri, {\n      md5: true,\n    }));\n    if (hash !== null && md5 !== hash) {\n      throw new Error(\n        `Downloaded file for asset '${name}.${type}' ` +\n          `Located at ${uri} ` +\n          `failed MD5 integrity check`\n      );\n    }\n  }\n  return localUri;\n}\n\n/**\n * Just download the asset, don't perform integrity check because we don't have\n * the hash to compare it with (we don't have hashAssetFiles plugin). Hash is\n * only used for the file name.\n */\nasync function _downloadAsyncUnmanagedEnv(uri, hash, type): Promise<string> {\n  // TODO: does this make sense to bail out if it's already at a file URL\n  // because it's already available locally?\n  if (uri.startsWith('file://')) {\n    return uri;\n  }\n\n  const cacheFileId = hash || computeMd5(uri);\n  const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${type}`;\n\n  // We don't check the FileSystem for an existing version of the asset and we\n  // also don't perform an integrity check!\n  await FileSystem.downloadAsync(uri, localUri);\n  return localUri;\n}\n"]},"metadata":{},"sourceType":"module"}