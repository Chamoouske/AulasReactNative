{"ast":null,"code":"","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\n// Modified from https://raw.githubusercontent.com/flow-typed/flow-typed/master/definitions/npm/jest_v23.x.x/flow_v0.39.x-v0.103.x/jest_v23.x.x.js\n// List of modifications:\n//  - fix some [] -> Array lint warnings\n//  - make it.each/describe.each take $ReadOnlyArray instead of Array<mixed>\n//  - added definition for `isolateModules`\n//\n// TODO(T35016336) remove the .each modifications if flow-typed adopts them\n\ntype JestMockFn<TArguments: $ReadOnlyArray<mixed>, TReturn> = {|\n  (...args: TArguments): TReturn,\n  /**\n   * An object for introspecting mock calls\n   */\n  mock: {\n    /**\n     * An array that represents all calls that have been made into this mock\n     * function. Each call is represented by an array of arguments that were\n     * passed during the call.\n     */\n    calls: Array<TArguments>,\n    /**\n     * An array that contains all the object instances that have been\n     * instantiated from this mock function.\n     */\n    instances: Array<TReturn>,\n    /**\n     * An array that contains all the object results that have been\n     * returned by this mock function call\n     */\n    results: Array<{isThrow: boolean, value: TReturn, ...}>,\n    ...\n  },\n  /**\n   * Resets all information stored in the mockFn.mock.calls and\n   * mockFn.mock.instances arrays. Often this is useful when you want to clean\n   * up a mock's usage data between two assertions.\n   */\n  mockClear(): void,\n  /**\n   * Resets all information stored in the mock. This is useful when you want to\n   * completely restore a mock back to its initial state.\n   */\n  mockReset(): void,\n  /**\n   * Removes the mock and restores the initial implementation. This is useful\n   * when you want to mock functions in certain test cases and restore the\n   * original implementation in others. Beware that mockFn.mockRestore only\n   * works when mock was created with jest.spyOn. Thus you have to take care of\n   * restoration yourself when manually assigning jest.fn().\n   */\n  mockRestore(): void,\n  /**\n   * Accepts a function that should be used as the implementation of the mock.\n   * The mock itself will still record all calls that go into and instances\n   * that come from itself -- the only difference is that the implementation\n   * will also be executed when the mock is called.\n   */\n  mockImplementation(\n    fn: (...args: TArguments) => TReturn,\n  ): JestMockFn<TArguments, TReturn>,\n  /**\n   * Accepts a function that will be used as an implementation of the mock for\n   * one call to the mocked function. Can be chained so that multiple function\n   * calls produce different results.\n   */\n  mockImplementationOnce(\n    fn: (...args: TArguments) => TReturn,\n  ): JestMockFn<TArguments, TReturn>,\n  /**\n   * Accepts a string to use in test result output in place of \"jest.fn()\" to\n   * indicate which mock function is being referenced.\n   */\n  mockName(name: string): JestMockFn<TArguments, TReturn>,\n  /**\n   * Just a simple sugar function for returning `this`\n   */\n  mockReturnThis(): void,\n  /**\n   * Accepts a value that will be returned whenever the mock function is called.\n   */\n  mockReturnValue(value: TReturn): JestMockFn<TArguments, TReturn>,\n  /**\n   * Sugar for only returning a value once inside your mock\n   */\n  mockReturnValueOnce(value: TReturn): JestMockFn<TArguments, TReturn>,\n  /**\n   * Sugar for jest.fn().mockImplementation(() => Promise.resolve(value))\n   */\n  mockResolvedValue(value: TReturn): JestMockFn<TArguments, Promise<TReturn>>,\n  /**\n   * Sugar for jest.fn().mockImplementationOnce(() => Promise.resolve(value))\n   */\n  mockResolvedValueOnce(\n    value: TReturn,\n  ): JestMockFn<TArguments, Promise<TReturn>>,\n  /**\n   * Sugar for jest.fn().mockImplementation(() => Promise.reject(value))\n   */\n  mockRejectedValue(value: TReturn): JestMockFn<TArguments, Promise<any>>,\n  /**\n   * Sugar for jest.fn().mockImplementationOnce(() => Promise.reject(value))\n   */\n  mockRejectedValueOnce(value: TReturn): JestMockFn<TArguments, Promise<any>>,\n|};\n\ntype JestAsymmetricEqualityType = {\n  /**\n   * A custom Jasmine equality tester\n   */\n  asymmetricMatch(value: mixed): boolean,\n  ...\n};\n\ntype JestCallsType = {\n  allArgs(): mixed,\n  all(): mixed,\n  any(): boolean,\n  count(): number,\n  first(): mixed,\n  mostRecent(): mixed,\n  reset(): void,\n  ...\n};\n\ntype JestClockType = {\n  install(): void,\n  mockDate(date: Date): void,\n  tick(milliseconds?: number): void,\n  uninstall(): void,\n  ...\n};\n\ntype JestMatcherResult = {\n  message?: string | (() => string),\n  pass: boolean,\n  ...\n};\n\ntype JestMatcher = (\n  actual: any,\n  expected: any,\n) => JestMatcherResult | Promise<JestMatcherResult>;\n\ntype JestPromiseType = {\n  /**\n   * Use rejects to unwrap the reason of a rejected promise so any other\n   * matcher can be chained. If the promise is fulfilled the assertion fails.\n   */\n  rejects: JestExpectType,\n  /**\n   * Use resolves to unwrap the value of a fulfilled promise so any other\n   * matcher can be chained. If the promise is rejected the assertion fails.\n   */\n  resolves: JestExpectType,\n  ...\n};\n\n/**\n * Jest allows functions and classes to be used as test names in test() and\n * describe()\n */\ntype JestTestName = string | Function;\n\n/**\n *  Plugin: jest-styled-components\n */\n\ntype JestStyledComponentsMatcherValue =\n  | string\n  | JestAsymmetricEqualityType\n  | RegExp\n  | typeof undefined;\n\ntype JestStyledComponentsMatcherOptions = {\n  media?: string,\n  modifier?: string,\n  supports?: string,\n  ...\n};\n\ntype JestStyledComponentsMatchersType = {\n  toHaveStyleRule(\n    property: string,\n    value: JestStyledComponentsMatcherValue,\n    options?: JestStyledComponentsMatcherOptions,\n  ): void,\n  ...\n};\n\n/**\n *  Plugin: jest-enzyme\n */\ntype EnzymeMatchersType = {\n  toBeChecked(): void,\n  toBeDisabled(): void,\n  toBeEmpty(): void,\n  toBeEmptyRender(): void,\n  toBePresent(): void,\n  toContainReact(element: React$Element<any>): void,\n  toExist(): void,\n  toHaveClassName(className: string): void,\n  toHaveHTML(html: string): void,\n  toHaveProp: ((propKey: string, propValue?: any) => void) &\n    ((props: Object) => void),\n  toHaveRef(refName: string): void,\n  toHaveState: ((stateKey: string, stateValue?: any) => void) &\n    ((state: Object) => void),\n  toHaveStyle: ((styleKey: string, styleValue?: any) => void) &\n    ((style: Object) => void),\n  toHaveTagName(tagName: string): void,\n  toHaveText(text: string): void,\n  toIncludeText(text: string): void,\n  toHaveValue(value: any): void,\n  toMatchElement(element: React$Element<any>): void,\n  toMatchSelector(selector: string): void,\n  ...\n};\n\n// DOM testing library extensions https://github.com/kentcdodds/dom-testing-library#custom-jest-matchers\ntype DomTestingLibraryType = {\n  toBeInTheDOM(): void,\n  toHaveTextContent(content: string): void,\n  toHaveAttribute(name: string, expectedValue?: string): void,\n  ...\n};\n\n// Jest JQuery Matchers: https://github.com/unindented/custom-jquery-matchers\ntype JestJQueryMatchersType = {\n  toExist(): void,\n  toHaveLength(len: number): void,\n  toHaveId(id: string): void,\n  toHaveClass(className: string): void,\n  toHaveTag(tag: string): void,\n  toHaveAttr(key: string, val?: any): void,\n  toHaveProp(key: string, val?: any): void,\n  toHaveText(text: string | RegExp): void,\n  toHaveData(key: string, val?: any): void,\n  toHaveValue(val: any): void,\n  toHaveCss(css: {[key: string]: any, ...}): void,\n  toBeChecked(): void,\n  toBeDisabled(): void,\n  toBeEmpty(): void,\n  toBeHidden(): void,\n  toBeSelected(): void,\n  toBeVisible(): void,\n  toBeFocused(): void,\n  toBeInDom(): void,\n  toBeMatchedBy(sel: string): void,\n  toHaveDescendant(sel: string): void,\n  toHaveDescendantWithText(sel: string, text: string | RegExp): void,\n  ...\n};\n\n// Jest Extended Matchers: https://github.com/jest-community/jest-extended\ntype JestExtendedMatchersType = {\n  /**\n   * Note: Currently unimplemented\n   * Passing assertion\n   *\n   * @param {String} message\n   */\n  //  pass(message: string): void;\n\n  /**\n   * Note: Currently unimplemented\n   * Failing assertion\n   *\n   * @param {String} message\n   */\n  //  fail(message: string): void;\n\n  /**\n   * Use .toBeEmpty when checking if a String '', Array [] or Object {} is empty.\n   */\n  toBeEmpty(): void,\n\n  /**\n   * Use .toBeOneOf when checking if a value is a member of a given Array.\n   * @param {Array.<*>} members\n   */\n  toBeOneOf(members: Array<any>): void,\n\n  /**\n   * Use `.toBeNil` when checking a value is `null` or `undefined`.\n   */\n  toBeNil(): void,\n\n  /**\n   * Use `.toSatisfy` when you want to use a custom matcher by supplying a predicate function that returns a `Boolean`.\n   * @param {Function} predicate\n   */\n  toSatisfy(predicate: (n: any) => boolean): void,\n\n  /**\n   * Use `.toBeArray` when checking if a value is an `Array`.\n   */\n  toBeArray(): void,\n\n  /**\n   * Use `.toBeArrayOfSize` when checking if a value is an `Array` of size x.\n   * @param {Number} x\n   */\n  toBeArrayOfSize(x: number): void,\n\n  /**\n   * Use `.toIncludeAllMembers` when checking if an `Array` contains all of the same members of a given set.\n   * @param {Array.<*>} members\n   */\n  toIncludeAllMembers(members: Array<any>): void,\n\n  /**\n   * Use `.toIncludeAnyMembers` when checking if an `Array` contains any of the members of a given set.\n   * @param {Array.<*>} members\n   */\n  toIncludeAnyMembers(members: Array<any>): void,\n\n  /**\n   * Use `.toSatisfyAll` when you want to use a custom matcher by supplying a predicate function that returns a `Boolean` for all values in an array.\n   * @param {Function} predicate\n   */\n  toSatisfyAll(predicate: (n: any) => boolean): void,\n\n  /**\n   * Use `.toBeBoolean` when checking if a value is a `Boolean`.\n   */\n  toBeBoolean(): void,\n\n  /**\n   * Use `.toBeTrue` when checking a value is equal (===) to `true`.\n   */\n  toBeTrue(): void,\n\n  /**\n   * Use `.toBeFalse` when checking a value is equal (===) to `false`.\n   */\n  toBeFalse(): void,\n\n  /**\n   * Use .toBeDate when checking if a value is a Date.\n   */\n  toBeDate(): void,\n\n  /**\n   * Use `.toBeFunction` when checking if a value is a `Function`.\n   */\n  toBeFunction(): void,\n\n  /**\n   * Use `.toHaveBeenCalledBefore` when checking if a `Mock` was called before another `Mock`.\n   *\n   * Note: Required Jest version >22\n   * Note: Your mock functions will have to be asynchronous to cause the timestamps inside of Jest to occur in a differentJS event loop, otherwise the mock timestamps will all be the same\n   *\n   * @param {Mock} mock\n   */\n  toHaveBeenCalledBefore(mock: JestMockFn<any, any>): void,\n\n  /**\n   * Use `.toBeNumber` when checking if a value is a `Number`.\n   */\n  toBeNumber(): void,\n\n  /**\n   * Use `.toBeNaN` when checking a value is `NaN`.\n   */\n  toBeNaN(): void,\n\n  /**\n   * Use `.toBeFinite` when checking if a value is a `Number`, not `NaN` or `Infinity`.\n   */\n  toBeFinite(): void,\n\n  /**\n   * Use `.toBePositive` when checking if a value is a positive `Number`.\n   */\n  toBePositive(): void,\n\n  /**\n   * Use `.toBeNegative` when checking if a value is a negative `Number`.\n   */\n  toBeNegative(): void,\n\n  /**\n   * Use `.toBeEven` when checking if a value is an even `Number`.\n   */\n  toBeEven(): void,\n\n  /**\n   * Use `.toBeOdd` when checking if a value is an odd `Number`.\n   */\n  toBeOdd(): void,\n\n  /**\n   * Use `.toBeWithin` when checking if a number is in between the given bounds of: start (inclusive) and end (exclusive).\n   *\n   * @param {Number} start\n   * @param {Number} end\n   */\n  toBeWithin(start: number, end: number): void,\n\n  /**\n   * Use `.toBeObject` when checking if a value is an `Object`.\n   */\n  toBeObject(): void,\n\n  /**\n   * Use `.toContainKey` when checking if an object contains the provided key.\n   *\n   * @param {String} key\n   */\n  toContainKey(key: string): void,\n\n  /**\n   * Use `.toContainKeys` when checking if an object has all of the provided keys.\n   *\n   * @param {Array.<String>} keys\n   */\n  toContainKeys(keys: Array<string>): void,\n\n  /**\n   * Use `.toContainAllKeys` when checking if an object only contains all of the provided keys.\n   *\n   * @param {Array.<String>} keys\n   */\n  toContainAllKeys(keys: Array<string>): void,\n\n  /**\n   * Use `.toContainAnyKeys` when checking if an object contains at least one of the provided keys.\n   *\n   * @param {Array.<String>} keys\n   */\n  toContainAnyKeys(keys: Array<string>): void,\n\n  /**\n   * Use `.toContainValue` when checking if an object contains the provided value.\n   *\n   * @param {*} value\n   */\n  toContainValue(value: any): void,\n\n  /**\n   * Use `.toContainValues` when checking if an object contains all of the provided values.\n   *\n   * @param {Array.<*>} values\n   */\n  toContainValues(values: Array<any>): void,\n\n  /**\n   * Use `.toContainAllValues` when checking if an object only contains all of the provided values.\n   *\n   * @param {Array.<*>} values\n   */\n  toContainAllValues(values: Array<any>): void,\n\n  /**\n   * Use `.toContainAnyValues` when checking if an object contains at least one of the provided values.\n   *\n   * @param {Array.<*>} values\n   */\n  toContainAnyValues(values: Array<any>): void,\n\n  /**\n   * Use `.toContainEntry` when checking if an object contains the provided entry.\n   *\n   * @param {Array.<String, String>} entry\n   */\n  toContainEntry(entry: [string, string]): void,\n\n  /**\n   * Use `.toContainEntries` when checking if an object contains all of the provided entries.\n   *\n   * @param {Array.<Array.<String, String>>} entries\n   */\n  toContainEntries(entries: Array<[string, string]>): void,\n\n  /**\n   * Use `.toContainAllEntries` when checking if an object only contains all of the provided entries.\n   *\n   * @param {Array.<Array.<String, String>>} entries\n   */\n  toContainAllEntries(entries: Array<[string, string]>): void,\n\n  /**\n   * Use `.toContainAnyEntries` when checking if an object contains at least one of the provided entries.\n   *\n   * @param {Array.<Array.<String, String>>} entries\n   */\n  toContainAnyEntries(entries: Array<[string, string]>): void,\n\n  /**\n   * Use `.toBeExtensible` when checking if an object is extensible.\n   */\n  toBeExtensible(): void,\n\n  /**\n   * Use `.toBeFrozen` when checking if an object is frozen.\n   */\n  toBeFrozen(): void,\n\n  /**\n   * Use `.toBeSealed` when checking if an object is sealed.\n   */\n  toBeSealed(): void,\n\n  /**\n   * Use `.toBeString` when checking if a value is a `String`.\n   */\n  toBeString(): void,\n\n  /**\n   * Use `.toEqualCaseInsensitive` when checking if a string is equal (===) to another ignoring the casing of both strings.\n   *\n   * @param {String} string\n   */\n  toEqualCaseInsensitive(string: string): void,\n\n  /**\n   * Use `.toStartWith` when checking if a `String` starts with a given `String` prefix.\n   *\n   * @param {String} prefix\n   */\n  toStartWith(prefix: string): void,\n\n  /**\n   * Use `.toEndWith` when checking if a `String` ends with a given `String` suffix.\n   *\n   * @param {String} suffix\n   */\n  toEndWith(suffix: string): void,\n\n  /**\n   * Use `.toInclude` when checking if a `String` includes the given `String` substring.\n   *\n   * @param {String} substring\n   */\n  toInclude(substring: string): void,\n\n  /**\n   * Use `.toIncludeRepeated` when checking if a `String` includes the given `String` substring the correct number of times.\n   *\n   * @param {String} substring\n   * @param {Number} times\n   */\n  toIncludeRepeated(substring: string, times: number): void,\n\n  /**\n   * Use `.toIncludeMultiple` when checking if a `String` includes all of the given substrings.\n   *\n   * @param {Array.<String>} substring\n   */\n  toIncludeMultiple(substring: Array<string>): void,\n  ...\n};\n\ninterface JestExpectType {\n  not: JestExpectType &\n    EnzymeMatchersType &\n    DomTestingLibraryType &\n    JestJQueryMatchersType &\n    JestStyledComponentsMatchersType &\n    JestExtendedMatchersType;\n  /**\n   * If you have a mock function, you can use .lastCalledWith to test what\n   * arguments it was last called with.\n   */\n  lastCalledWith(...args: Array<any>): void;\n  /**\n   * toBe just checks that a value is what you expect. It uses === to check\n   * strict equality.\n   */\n  toBe(value: any): void;\n  /**\n   * Use .toBeCalledWith to ensure that a mock function was called with\n   * specific arguments.\n   */\n  toBeCalledWith(...args: Array<any>): void;\n  /**\n   * Using exact equality with floating point numbers is a bad idea. Rounding\n   * means that intuitive things fail.\n   */\n  toBeCloseTo(num: number, delta: any): void;\n  /**\n   * Use .toBeDefined to check that a variable is not undefined.\n   */\n  toBeDefined(): void;\n  /**\n   * Use .toBeFalsy when you don't care what a value is, you just want to\n   * ensure a value is false in a boolean context.\n   */\n  toBeFalsy(): void;\n  /**\n   * To compare floating point numbers, you can use toBeGreaterThan.\n   */\n  toBeGreaterThan(number: number): void;\n  /**\n   * To compare floating point numbers, you can use toBeGreaterThanOrEqual.\n   */\n  toBeGreaterThanOrEqual(number: number): void;\n  /**\n   * To compare floating point numbers, you can use toBeLessThan.\n   */\n  toBeLessThan(number: number): void;\n  /**\n   * To compare floating point numbers, you can use toBeLessThanOrEqual.\n   */\n  toBeLessThanOrEqual(number: number): void;\n  /**\n   * Use .toBeInstanceOf(Class) to check that an object is an instance of a\n   * class.\n   */\n  toBeInstanceOf(cls: Class<*>): void;\n  /**\n   * .toBeNull() is the same as .toBe(null) but the error messages are a bit\n   * nicer.\n   */\n  toBeNull(): void;\n  /**\n   * Use .toBeTruthy when you don't care what a value is, you just want to\n   * ensure a value is true in a boolean context.\n   */\n  toBeTruthy(): void;\n  /**\n   * Use .toBeUndefined to check that a variable is undefined.\n   */\n  toBeUndefined(): void;\n  /**\n   * Use .toContain when you want to check that an item is in a list. For\n   * testing the items in the list, this uses ===, a strict equality check.\n   */\n  toContain(item: any): void;\n  /**\n   * Use .toContainEqual when you want to check that an item is in a list. For\n   * testing the items in the list, this matcher recursively checks the\n   * equality of all fields, rather than checking for object identity.\n   */\n  toContainEqual(item: any): void;\n  /**\n   * Use .toEqual when you want to check that two objects have the same value.\n   * This matcher recursively checks the equality of all fields, rather than\n   * checking for object identity.\n   */\n  toEqual(value: any): void;\n  /**\n   * Use .toHaveBeenCalled to ensure that a mock function got called.\n   */\n  toHaveBeenCalled(): void;\n  toBeCalled(): void;\n  /**\n   * Use .toHaveBeenCalledTimes to ensure that a mock function got called exact\n   * number of times.\n   */\n  toHaveBeenCalledTimes(number: number): void;\n  toBeCalledTimes(number: number): void;\n  /**\n   *\n   */\n  toHaveBeenNthCalledWith(nthCall: number, ...args: Array<any>): void;\n  nthCalledWith(nthCall: number, ...args: Array<any>): void;\n  /**\n   *\n   */\n  toHaveReturned(): void;\n  toReturn(): void;\n  /**\n   *\n   */\n  toHaveReturnedTimes(number: number): void;\n  toReturnTimes(number: number): void;\n  /**\n   *\n   */\n  toHaveReturnedWith(value: any): void;\n  toReturnWith(value: any): void;\n  /**\n   *\n   */\n  toHaveLastReturnedWith(value: any): void;\n  lastReturnedWith(value: any): void;\n  /**\n   *\n   */\n  toHaveNthReturnedWith(nthCall: number, value: any): void;\n  nthReturnedWith(nthCall: number, value: any): void;\n  /**\n   * Use .toHaveBeenCalledWith to ensure that a mock function was called with\n   * specific arguments.\n   */\n  toHaveBeenCalledWith(...args: Array<any>): void;\n  toBeCalledWith(...args: Array<any>): void;\n  /**\n   * Use .toHaveBeenLastCalledWith to ensure that a mock function was last called\n   * with specific arguments.\n   */\n  toHaveBeenLastCalledWith(...args: Array<any>): void;\n  lastCalledWith(...args: Array<any>): void;\n  /**\n   * Check that an object has a .length property and it is set to a certain\n   * numeric value.\n   */\n  toHaveLength(number: number): void;\n  /**\n   *\n   */\n  toHaveProperty(propPath: string, value?: any): void;\n  /**\n   * Use .toMatch to check that a string matches a regular expression or string.\n   */\n  toMatch(regexpOrString: RegExp | string): void;\n  /**\n   * Use .toMatchObject to check that a javascript object matches a subset of the properties of an object.\n   */\n  toMatchObject(object: Object | Array<Object>): void;\n  /**\n   * Use .toStrictEqual to check that a javascript object matches a subset of the properties of an object.\n   */\n  toStrictEqual(value: any): void;\n  /**\n   * This ensures that an Object matches the most recent snapshot.\n   */\n  toMatchSnapshot(\n    propertyMatchers?: {[key: string]: JestAsymmetricEqualityType, ...},\n    name?: string,\n  ): void;\n  /**\n   * This ensures that an Object matches the most recent snapshot.\n   */\n  toMatchSnapshot(name: string): void;\n\n  toMatchInlineSnapshot(snapshot?: string): void;\n  toMatchInlineSnapshot(\n    propertyMatchers?: {[key: string]: JestAsymmetricEqualityType, ...},\n    snapshot?: string,\n  ): void;\n  /**\n   * Use .toThrow to test that a function throws when it is called.\n   * If you want to test that a specific error gets thrown, you can provide an\n   * argument to toThrow. The argument can be a string for the error message,\n   * a class for the error, or a regex that should match the error.\n   *\n   * Alias: .toThrowError\n   */\n  toThrow(message?: string | Error | Class<Error> | RegExp): void;\n  toThrowError(message?: string | Error | Class<Error> | RegExp): void;\n  /**\n   * Use .toThrowErrorMatchingSnapshot to test that a function throws a error\n   * matching the most recent snapshot when it is called.\n   */\n  toThrowErrorMatchingSnapshot(): void;\n  toThrowErrorMatchingInlineSnapshot(snapshot?: string): void;\n}\n\ntype JestObjectType = {\n  /**\n   *  Disables automatic mocking in the module loader.\n   *\n   *  After this method is called, all `require()`s will return the real\n   *  versions of each module (rather than a mocked version).\n   */\n  disableAutomock(): JestObjectType,\n  /**\n   * An un-hoisted version of disableAutomock\n   */\n  autoMockOff(): JestObjectType,\n  /**\n   * Enables automatic mocking in the module loader.\n   */\n  enableAutomock(): JestObjectType,\n  /**\n   * An un-hoisted version of enableAutomock\n   */\n  autoMockOn(): JestObjectType,\n  /**\n   * Clears the mock.calls and mock.instances properties of all mocks.\n   * Equivalent to calling .mockClear() on every mocked function.\n   */\n  clearAllMocks(): JestObjectType,\n  /**\n   * Resets the state of all mocks. Equivalent to calling .mockReset() on every\n   * mocked function.\n   */\n  resetAllMocks(): JestObjectType,\n  /**\n   * Restores all mocks back to their original value.\n   */\n  restoreAllMocks(): JestObjectType,\n  /**\n   * Removes any pending timers from the timer system.\n   */\n  clearAllTimers(): void,\n  /**\n   * The same as `mock` but not moved to the top of the expectation by\n   * babel-jest.\n   */\n  doMock(moduleName: string, moduleFactory?: any): JestObjectType,\n  /**\n   * The same as `unmock` but not moved to the top of the expectation by\n   * babel-jest.\n   */\n  dontMock(moduleName: string): JestObjectType,\n  /**\n   * Returns a new, unused mock function. Optionally takes a mock\n   * implementation.\n   */\n  fn<TArguments: $ReadOnlyArray<mixed>, TReturn>(\n    implementation?: (...args: TArguments) => TReturn,\n  ): JestMockFn<TArguments, TReturn>,\n  /**\n   * Determines if the given function is a mocked function.\n   */\n  isMockFunction(fn: Function): boolean,\n  /**\n   * Given the name of a module, use the automatic mocking system to generate a\n   * mocked version of the module for you.\n   */\n  genMockFromModule(moduleName: string): any,\n  /**\n   * Mocks a module with an auto-mocked version when it is being required.\n   *\n   * The second argument can be used to specify an explicit module factory that\n   * is being run instead of using Jest's automocking feature.\n   *\n   * The third argument can be used to create virtual mocks -- mocks of modules\n   * that don't exist anywhere in the system.\n   */\n  mock(\n    moduleName: string,\n    moduleFactory?: any,\n    options?: Object,\n  ): JestObjectType,\n  /**\n   * Returns the actual module instead of a mock, bypassing all checks on\n   * whether the module should receive a mock implementation or not.\n   */\n  requireActual<T>(m: $Flow$ModuleRef<T> | string): T,\n  /**\n   * Returns a mock module instead of the actual module, bypassing all checks\n   * on whether the module should be required normally or not.\n   */\n  requireMock(moduleName: string): any,\n  /**\n   * Resets the module registry - the cache of all required modules. This is\n   * useful to isolate modules where local state might conflict between tests.\n   */\n  resetModules(): JestObjectType,\n  /**\n   * Exhausts the micro-task queue (usually interfaced in node via\n   * process.nextTick).\n   */\n  runAllTicks(): void,\n  /**\n   * Exhausts the macro-task queue (i.e., all tasks queued by setTimeout(),\n   * setInterval(), and setImmediate()).\n   */\n  runAllTimers(): void,\n  /**\n   * Exhausts all tasks queued by setImmediate().\n   */\n  runAllImmediates(): void,\n  /**\n   * Executes only the macro task queue (i.e. all tasks queued by setTimeout()\n   * or setInterval() and setImmediate()).\n   */\n  advanceTimersByTime(msToRun: number): void,\n  /**\n   * Executes only the macro task queue (i.e. all tasks queued by setTimeout()\n   * or setInterval() and setImmediate()).\n   *\n   * Renamed to `advanceTimersByTime`.\n   */\n  runTimersToTime(msToRun: number): void,\n  /**\n   * Executes only the macro-tasks that are currently pending (i.e., only the\n   * tasks that have been queued by setTimeout() or setInterval() up to this\n   * point)\n   */\n  runOnlyPendingTimers(): void,\n  /**\n   * Explicitly supplies the mock object that the module system should return\n   * for the specified module. Note: It is recommended to use jest.mock()\n   * instead.\n   */\n  setMock(moduleName: string, moduleExports: any): JestObjectType,\n  /**\n   * Indicates that the module system should never return a mocked version of\n   * the specified module from require() (e.g. that it should always return the\n   * real module).\n   */\n  unmock(moduleName: string): JestObjectType,\n  /**\n   * Instructs Jest to use fake versions of the standard timer functions\n   * (setTimeout, setInterval, clearTimeout, clearInterval, nextTick,\n   * setImmediate and clearImmediate).\n   */\n  useFakeTimers(): JestObjectType,\n  /**\n   * Instructs Jest to use the real versions of the standard timer functions.\n   */\n  useRealTimers(): JestObjectType,\n  /**\n   * Creates a mock function similar to jest.fn but also tracks calls to\n   * object[methodName].\n   */\n  spyOn(\n    object: Object,\n    methodName: string,\n    accessType?: 'get' | 'set',\n  ): JestMockFn<any, any>,\n  /**\n   * Set the default timeout interval for tests and before/after hooks in milliseconds.\n   * Note: The default timeout interval is 5 seconds if this method is not called.\n   */\n  setTimeout(timeout: number): JestObjectType,\n  ...\n};\n\ntype JestSpyType = {\n  calls: JestCallsType,\n  ...\n};\n\n/** Runs this function after every test inside this context */\ndeclare function afterEach(\n  fn: (done: () => void) => ?Promise<mixed>,\n  timeout?: number,\n): void;\n/** Runs this function before every test inside this context */\ndeclare function beforeEach(\n  fn: (done: () => void) => ?Promise<mixed>,\n  timeout?: number,\n): void;\n/** Runs this function after all tests have finished inside this context */\ndeclare function afterAll(\n  fn: (done: () => void) => ?Promise<mixed>,\n  timeout?: number,\n): void;\n/** Runs this function before any tests have started inside this context */\ndeclare function beforeAll(\n  fn: (done: () => void) => ?Promise<mixed>,\n  timeout?: number,\n): void;\n\n/** A context for grouping tests together */\ndeclare var describe: {\n  /**\n   * Creates a block that groups together several related tests in one \"test suite\"\n   */\n  (name: JestTestName, fn: () => void): void,\n\n  /**\n   * Only run this describe block\n   */\n  only(name: JestTestName, fn: () => void): void,\n\n  /**\n   * Skip running this describe block\n   */\n  skip(name: JestTestName, fn: () => void): void,\n\n  /**\n   * each runs this test against array of argument arrays per each run\n   *\n   * @param {table} table of Test\n   */\n  each<TArguments: Array<mixed> | mixed>(\n    table: $ReadOnlyArray<TArguments>,\n  ): (\n    name: JestTestName,\n    fn?: (...args: TArguments) => ?Promise<mixed>,\n  ) => void,\n  ...\n};\n\n/** An individual test unit */\ndeclare var it: {\n  /**\n   * An individual test unit\n   *\n   * @param {JestTestName} Name of Test\n   * @param {Function} Test\n   * @param {number} Timeout for the test, in milliseconds.\n   */\n  (\n    name: JestTestName,\n    fn?: (done: () => void) => ?Promise<mixed>,\n    timeout?: number,\n  ): void,\n  /**\n   * each runs this test against array of argument arrays per each run\n   *\n   * @param {table} table of Test\n   */\n  each<TArguments: Array<mixed> | mixed>(\n    table: $ReadOnlyArray<TArguments>,\n  ): (\n    name: JestTestName,\n    fn?: (...args: TArguments) => ?Promise<mixed>,\n  ) => void,\n  /**\n   * Only run this test\n   *\n   * @param {JestTestName} Name of Test\n   * @param {Function} Test\n   * @param {number} Timeout for the test, in milliseconds.\n   */\n  only(\n    name: JestTestName,\n    fn?: (done: () => void) => ?Promise<mixed>,\n    timeout?: number,\n  ): {\n    each<TArguments: Array<mixed> | mixed>(\n      table: $ReadOnlyArray<TArguments>,\n    ): (\n      name: JestTestName,\n      fn?: (...args: TArguments) => ?Promise<mixed>,\n    ) => void,\n    ...\n  },\n  /**\n   * Skip running this test\n   *\n   * @param {JestTestName} Name of Test\n   * @param {Function} Test\n   * @param {number} Timeout for the test, in milliseconds.\n   */\n  skip(\n    name: JestTestName,\n    fn?: (done: () => void) => ?Promise<mixed>,\n    timeout?: number,\n  ): void,\n  /**\n   * Run the test concurrently\n   *\n   * @param {JestTestName} Name of Test\n   * @param {Function} Test\n   * @param {number} Timeout for the test, in milliseconds.\n   */\n  concurrent(\n    name: JestTestName,\n    fn?: (done: () => void) => ?Promise<mixed>,\n    timeout?: number,\n  ): void,\n  ...\n};\ndeclare function fit(\n  name: JestTestName,\n  fn: (done: () => void) => ?Promise<mixed>,\n  timeout?: number,\n): void;\n/** An individual test unit */\ndeclare var test: typeof it;\n/** A disabled group of tests */\ndeclare var xdescribe: typeof describe;\n/** A focused group of tests */\ndeclare var fdescribe: typeof describe;\n/** A disabled individual test */\ndeclare var xit: typeof it;\n/** A disabled individual test */\ndeclare var xtest: typeof it;\n\ntype JestPrettyFormatColors = {\n  comment: {close: string, open: string, ...},\n  content: {close: string, open: string, ...},\n  prop: {close: string, open: string, ...},\n  tag: {close: string, open: string, ...},\n  value: {close: string, open: string, ...},\n  ...\n};\n\ntype JestPrettyFormatIndent = string => string;\ntype JestPrettyFormatPrint = any => string;\n\ntype JestPrettyFormatOptions = {|\n  callToJSON: boolean,\n  edgeSpacing: string,\n  escapeRegex: boolean,\n  highlight: boolean,\n  indent: number,\n  maxDepth: number,\n  min: boolean,\n  plugins: JestPrettyFormatPlugins,\n  printFunctionName: boolean,\n  spacing: string,\n  theme: {|\n    comment: string,\n    content: string,\n    prop: string,\n    tag: string,\n    value: string,\n  |},\n|};\n\ntype JestPrettyFormatPlugin = {\n  print: (\n    val: any,\n    serialize: JestPrettyFormatPrint,\n    indent: JestPrettyFormatIndent,\n    opts: JestPrettyFormatOptions,\n    colors: JestPrettyFormatColors,\n  ) => string,\n  test: any => boolean,\n  ...\n};\n\ntype JestPrettyFormatPlugins = Array<JestPrettyFormatPlugin>;\n\n/** The expect function is used every time you want to test a value */\ndeclare var expect: {\n  /** The object that you want to make assertions against */\n  (\n    value: any,\n  ): JestExpectType &\n    JestPromiseType &\n    EnzymeMatchersType &\n    DomTestingLibraryType &\n    JestJQueryMatchersType &\n    JestStyledComponentsMatchersType &\n    JestExtendedMatchersType,\n\n  /** Add additional Jasmine matchers to Jest's roster */\n  extend(matchers: {[name: string]: JestMatcher, ...}): void,\n  /** Add a module that formats application-specific data structures. */\n  addSnapshotSerializer(pluginModule: JestPrettyFormatPlugin): void,\n  assertions(expectedAssertions: number): void,\n  hasAssertions(): void,\n  any(value: mixed): JestAsymmetricEqualityType,\n  anything(): any,\n  arrayContaining(value: $ReadOnlyArray<mixed>): Array<mixed>,\n  objectContaining(value: Object): Object,\n  /** Matches any received string that contains the exact expected string. */\n  stringContaining(value: string): string,\n  stringMatching(value: string | RegExp): string,\n  not: {\n    arrayContaining: (value: $ReadOnlyArray<mixed>) => Array<mixed>,\n    objectContaining: (value: {...}) => Object,\n    stringContaining: (value: string) => string,\n    stringMatching: (value: string | RegExp) => string,\n    ...\n  },\n  ...\n};\n\n// TODO handle return type\n// http://jasmine.github.io/2.4/introduction.html#section-Spies\ndeclare function spyOn(value: mixed, method: string): Object;\n\n/** Holds all functions related to manipulating test runner */\ndeclare var jest: JestObjectType;\n\n/**\n * https://jasmine.github.io/2.4/custom_reporter.html\n */\ntype JasmineReporter = {\n  jasmineStarted?: (suiteInfo: mixed) => void,\n  suiteStarted?: (result: mixed) => void,\n  specStarted?: (result: mixed) => void,\n  specDone?: (result: mixed) => void,\n  suiteDone?: (result: mixed) => void,\n  ...\n};\n\n/**\n * The global Jasmine object, this is generally not exposed as the public API,\n * using features inside here could break in later versions of Jest.\n */\ndeclare var jasmine: {\n  DEFAULT_TIMEOUT_INTERVAL: number,\n  any(value: mixed): JestAsymmetricEqualityType,\n  anything(): any,\n  arrayContaining(value: $ReadOnlyArray<mixed>): Array<mixed>,\n  clock(): JestClockType,\n  createSpy(name: string): JestSpyType,\n  createSpyObj(\n    baseName: string,\n    methodNames: Array<string>,\n  ): {[methodName: string]: JestSpyType, ...},\n  getEnv(): {addReporter: (jasmineReporter: JasmineReporter) => void, ...},\n  objectContaining(value: Object): Object,\n  stringMatching(value: string): string,\n  ...\n};\n"]},"metadata":{},"sourceType":"script"}