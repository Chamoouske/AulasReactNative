{"ast":null,"code":"'use strict';\n\nvar sqlite3 = require('sqlite3');\n\nvar SQLiteResult = require(\"./SQLiteResult\");\n\nvar READ_ONLY_ERROR = new Error('could not prepare statement (23 not authorized)');\n\nfunction SQLiteDatabase(name) {\n  this._db = new sqlite3.Database(name);\n}\n\nfunction runSelect(db, sql, args, cb) {\n  db.all(sql, args, function (err, rows) {\n    if (err) {\n      return cb(new SQLiteResult(err));\n    }\n\n    var insertId = void 0;\n    var rowsAffected = 0;\n    var resultSet = new SQLiteResult(null, insertId, rowsAffected, rows);\n    cb(resultSet);\n  });\n}\n\nfunction runNonSelect(db, sql, args, cb) {\n  db.run(sql, args, function (err) {\n    if (err) {\n      return cb(new SQLiteResult(err));\n    }\n\n    var executionResult = this;\n    var insertId = executionResult.lastID;\n    var rowsAffected = executionResult.changes;\n    var rows = [];\n    var resultSet = new SQLiteResult(null, insertId, rowsAffected, rows);\n    cb(resultSet);\n  });\n}\n\nSQLiteDatabase.prototype.exec = function exec(queries, readOnly, callback) {\n  var db = this._db;\n  var len = queries.length;\n  var results = new Array(len);\n  var i = 0;\n\n  function checkDone() {\n    if (++i === len) {\n      callback(null, results);\n    } else {\n      doNext();\n    }\n  }\n\n  function onQueryComplete(i) {\n    return function (res) {\n      results[i] = res;\n      checkDone();\n    };\n  }\n\n  function doNext() {\n    var query = queries[i];\n    var sql = query.sql;\n    var args = query.args;\n    var isSelect = /^\\s*SELECT\\b/i.test(sql);\n\n    if (readOnly && !isSelect) {\n      onQueryComplete(i)(new SQLiteResult(READ_ONLY_ERROR));\n    } else if (isSelect) {\n      runSelect(db, sql, args, onQueryComplete(i));\n    } else {\n      runNonSelect(db, sql, args, onQueryComplete(i));\n    }\n  }\n\n  doNext();\n};\n\nmodule.exports = SQLiteDatabase;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/@expo/websql/lib/sqlite/SQLiteDatabase.js"],"names":["sqlite3","require","SQLiteResult","READ_ONLY_ERROR","Error","SQLiteDatabase","name","_db","Database","runSelect","db","sql","args","cb","all","err","rows","insertId","rowsAffected","resultSet","runNonSelect","run","executionResult","lastID","changes","prototype","exec","queries","readOnly","callback","len","length","results","Array","i","checkDone","doNext","onQueryComplete","res","query","isSelect","test","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar sqlite3 = require('sqlite3');\nvar SQLiteResult = require('./SQLiteResult');\n\nvar READ_ONLY_ERROR = new Error(\n  'could not prepare statement (23 not authorized)');\n\nfunction SQLiteDatabase(name) {\n  this._db = new sqlite3.Database(name);\n}\n\nfunction runSelect(db, sql, args, cb) {\n  db.all(sql, args, function (err, rows) {\n    if (err) {\n      return cb(new SQLiteResult(err));\n    }\n    var insertId = void 0;\n    var rowsAffected = 0;\n    var resultSet = new SQLiteResult(null, insertId, rowsAffected, rows);\n    cb(resultSet);\n  });\n}\n\nfunction runNonSelect(db, sql, args, cb) {\n  db.run(sql, args, function (err) {\n    if (err) {\n      return cb(new SQLiteResult(err));\n    }\n    /* jshint validthis:true */\n    var executionResult = this;\n    var insertId = executionResult.lastID;\n    var rowsAffected = executionResult.changes;\n    var rows = [];\n    var resultSet = new SQLiteResult(null, insertId, rowsAffected, rows);\n    cb(resultSet);\n  });\n}\n\nSQLiteDatabase.prototype.exec = function exec(queries, readOnly, callback) {\n\n  var db = this._db;\n  var len = queries.length;\n  var results = new Array(len);\n\n  var i = 0;\n\n  function checkDone() {\n    if (++i === len) {\n      callback(null, results);\n    } else {\n      doNext();\n    }\n  }\n\n  function onQueryComplete(i) {\n    return function (res) {\n      results[i] = res;\n      checkDone();\n    };\n  }\n\n  function doNext() {\n    var query = queries[i];\n    var sql = query.sql;\n    var args = query.args;\n\n    // TODO: It seems like the node-sqlite3 API either allows:\n    // 1) all(), which returns results but not rowsAffected or lastID\n    // 2) run(), which doesn't return results, but returns rowsAffected and lastID\n    // So we try to sniff whether it's a SELECT query or not.\n    // This is inherently error-prone, although it will probably work in the 99%\n    // case.\n    var isSelect = /^\\s*SELECT\\b/i.test(sql);\n\n    if (readOnly && !isSelect) {\n      onQueryComplete(i)(new SQLiteResult(READ_ONLY_ERROR));\n    } else if (isSelect) {\n      runSelect(db, sql, args, onQueryComplete(i));\n    } else {\n      runNonSelect(db, sql, args, onQueryComplete(i));\n    }\n  }\n\n  doNext();\n};\n\nmodule.exports = SQLiteDatabase;"]},"metadata":{},"sourceType":"script"}