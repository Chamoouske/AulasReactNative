{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar EventEmitterWithHolding = function () {\n  function EventEmitterWithHolding(emitter, holder) {\n    _classCallCheck(this, EventEmitterWithHolding);\n\n    this._emitter = emitter;\n    this._eventHolder = holder;\n    this._currentEventToken = null;\n    this._emittingHeldEvents = false;\n  }\n\n  _createClass(EventEmitterWithHolding, [{\n    key: \"addListener\",\n    value: function addListener(eventType, listener, context) {\n      return this._emitter.addListener(eventType, listener, context);\n    }\n  }, {\n    key: \"once\",\n    value: function once(eventType, listener, context) {\n      return this._emitter.once(eventType, listener, context);\n    }\n  }, {\n    key: \"addRetroactiveListener\",\n    value: function addRetroactiveListener(eventType, listener, context) {\n      var subscription = this._emitter.addListener(eventType, listener, context);\n\n      this._emittingHeldEvents = true;\n\n      this._eventHolder.emitToListener(eventType, listener, context);\n\n      this._emittingHeldEvents = false;\n      return subscription;\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(eventType) {\n      this._emitter.removeAllListeners(eventType);\n    }\n  }, {\n    key: \"removeCurrentListener\",\n    value: function removeCurrentListener() {\n      this._emitter.removeCurrentListener();\n    }\n  }, {\n    key: \"listeners\",\n    value: function listeners(eventType) {\n      return this._emitter.listeners(eventType);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(eventType) {\n      var _this$_emitter;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (_this$_emitter = this._emitter).emit.apply(_this$_emitter, [eventType].concat(args));\n    }\n  }, {\n    key: \"emitAndHold\",\n    value: function emitAndHold(eventType) {\n      var _this$_eventHolder, _this$_emitter2;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this._currentEventToken = (_this$_eventHolder = this._eventHolder).holdEvent.apply(_this$_eventHolder, [eventType].concat(args));\n\n      (_this$_emitter2 = this._emitter).emit.apply(_this$_emitter2, [eventType].concat(args));\n\n      this._currentEventToken = null;\n    }\n  }, {\n    key: \"releaseCurrentEvent\",\n    value: function releaseCurrentEvent() {\n      if (this._currentEventToken) {\n        this._eventHolder.releaseEvent(this._currentEventToken);\n      } else if (this._emittingHeldEvents) {\n        this._eventHolder.releaseCurrentEvent();\n      }\n    }\n  }, {\n    key: \"releaseHeldEventType\",\n    value: function releaseHeldEventType(eventType) {\n      this._eventHolder.releaseEventType(eventType);\n    }\n  }]);\n\n  return EventEmitterWithHolding;\n}();\n\nexport default EventEmitterWithHolding;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/src/vendor/react-native/emitter/EventEmitterWithHolding.js"],"names":["EventEmitterWithHolding","emitter","holder","_emitter","_eventHolder","_currentEventToken","_emittingHeldEvents","eventType","listener","context","addListener","once","subscription","emitToListener","removeAllListeners","removeCurrentListener","listeners","args","emit","holdEvent","releaseEvent","releaseCurrentEvent","releaseEventType"],"mappings":"AAUA;;;;;IAkBMA,uB;AAaJ,mCAAYC,OAAZ,EAAmCC,MAAnC,EAAwD;AAAA;;AACtD,SAAKC,QAAL,GAAgBF,OAAhB;AACA,SAAKG,YAAL,GAAoBF,MAApB;AACA,SAAKG,kBAAL,GAA0B,IAA1B;AACA,SAAKC,mBAAL,GAA2B,KAA3B;AACD;;;;WAKD,qBAAYC,SAAZ,EAA+BC,QAA/B,EAAmDC,OAAnD,EAAqE;AACnE,aAAO,KAAKN,QAAL,CAAcO,WAAd,CAA0BH,SAA1B,EAAqCC,QAArC,EAA+CC,OAA/C,CAAP;AACD;;;WAKD,cAAKF,SAAL,EAAwBC,QAAxB,EAA4CC,OAA5C,EAA8D;AAC5D,aAAO,KAAKN,QAAL,CAAcQ,IAAd,CAAmBJ,SAAnB,EAA8BC,QAA9B,EAAwCC,OAAxC,CAAP;AACD;;;WAsBD,gCACEF,SADF,EAEEC,QAFF,EAGEC,OAHF,EAIuB;AACrB,UAAMG,YAAY,GAAG,KAAKT,QAAL,CAAcO,WAAd,CACnBH,SADmB,EAEnBC,QAFmB,EAGnBC,OAHmB,CAArB;;AAMA,WAAKH,mBAAL,GAA2B,IAA3B;;AACA,WAAKF,YAAL,CAAkBS,cAAlB,CAAiCN,SAAjC,EAA4CC,QAA5C,EAAsDC,OAAtD;;AACA,WAAKH,mBAAL,GAA2B,KAA3B;AAEA,aAAOM,YAAP;AACD;;;WAKD,4BAAmBL,SAAnB,EAAsC;AACpC,WAAKJ,QAAL,CAAcW,kBAAd,CAAiCP,SAAjC;AACD;;;WAKD,iCAAwB;AACtB,WAAKJ,QAAL,CAAcY,qBAAd;AACD;;;WAKD,mBAAUR,SAAV,EAAmE;AACjE,aAAO,KAAKJ,QAAL,CAAca,SAAd,CAAwBT,SAAxB,CAAP;AACD;;;WAKD,cAAKA,SAAL,EAAsC;AAAA;;AAAA,wCAAXU,IAAW;AAAXA,QAAAA,IAAW;AAAA;;AACpC,6BAAKd,QAAL,EAAce,IAAd,wBAAmBX,SAAnB,SAAiCU,IAAjC;AACD;;;WAiBD,qBAAYV,SAAZ,EAA6C;AAAA;;AAAA,yCAAXU,IAAW;AAAXA,QAAAA,IAAW;AAAA;;AAC3C,WAAKZ,kBAAL,GAA0B,2BAAKD,YAAL,EAAkBe,SAAlB,4BAA4BZ,SAA5B,SAA0CU,IAA1C,EAA1B;;AACA,8BAAKd,QAAL,EAAce,IAAd,yBAAmBX,SAAnB,SAAiCU,IAAjC;;AACA,WAAKZ,kBAAL,GAA0B,IAA1B;AACD;;;WAKD,+BAAsB;AACpB,UAAI,KAAKA,kBAAT,EAA6B;AAC3B,aAAKD,YAAL,CAAkBgB,YAAlB,CAA+B,KAAKf,kBAApC;AACD,OAFD,MAEO,IAAI,KAAKC,mBAAT,EAA8B;AACnC,aAAKF,YAAL,CAAkBiB,mBAAlB;AACD;AACF;;;WAMD,8BAAqBd,SAArB,EAAwC;AACtC,WAAKH,YAAL,CAAkBkB,gBAAlB,CAAmCf,SAAnC;AACD;;;;;;AAGH,eAAeP,uBAAf","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport type EmitterSubscription from './EmitterSubscription';\nimport type EventEmitter from './EventEmitter';\nimport type EventHolder from './EventHolder';\n\n/**\n * @class EventEmitterWithHolding\n * @description\n * An EventEmitterWithHolding decorates an event emitter and enables one to\n * \"hold\" or cache events and then have a handler register later to actually\n * handle them.\n *\n * This is separated into its own decorator so that only those who want to use\n * the holding functionality have to and others can just use an emitter. Since\n * it implements the emitter interface it can also be combined with anything\n * that uses an emitter.\n */\nclass EventEmitterWithHolding {\n  _emitter: EventEmitter;\n  _eventHolder: EventHolder;\n  _currentEventToken: ?Object;\n  _emittingHeldEvents: boolean;\n\n  /**\n   * @constructor\n   * @param {object} emitter - The object responsible for emitting the actual\n   *   events.\n   * @param {object} holder - The event holder that is responsible for holding\n   *   and then emitting held events.\n   */\n  constructor(emitter: EventEmitter, holder: EventHolder) {\n    this._emitter = emitter;\n    this._eventHolder = holder;\n    this._currentEventToken = null;\n    this._emittingHeldEvents = false;\n  }\n\n  /**\n   * @see EventEmitter#addListener\n   */\n  addListener(eventType: string, listener: Function, context: ?Object) {\n    return this._emitter.addListener(eventType, listener, context);\n  }\n\n  /**\n   * @see EventEmitter#once\n   */\n  once(eventType: string, listener: Function, context: ?Object) {\n    return this._emitter.once(eventType, listener, context);\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function. In addition to subscribing\n   * to all subsequent events, this method will also handle any events that have\n   * already been emitted, held, and not released.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   *\n   * @example\n   *   emitter.emitAndHold('someEvent', 'abc');\n   *\n   *   emitter.addRetroactiveListener('someEvent', function(message) {\n   *     console.log(message);\n   *   }); // logs 'abc'\n   */\n  addRetroactiveListener(\n    eventType: string,\n    listener: Function,\n    context: ?Object,\n  ): EmitterSubscription {\n    const subscription = this._emitter.addListener(\n      eventType,\n      listener,\n      context,\n    );\n\n    this._emittingHeldEvents = true;\n    this._eventHolder.emitToListener(eventType, listener, context);\n    this._emittingHeldEvents = false;\n\n    return subscription;\n  }\n\n  /**\n   * @see EventEmitter#removeAllListeners\n   */\n  removeAllListeners(eventType: string) {\n    this._emitter.removeAllListeners(eventType);\n  }\n\n  /**\n   * @see EventEmitter#removeCurrentListener\n   */\n  removeCurrentListener() {\n    this._emitter.removeCurrentListener();\n  }\n\n  /**\n   * @see EventEmitter#listeners\n   */\n  listeners(eventType: string) /* TODO: Annotate return type here */ {\n    return this._emitter.listeners(eventType);\n  }\n\n  /**\n   * @see EventEmitter#emit\n   */\n  emit(eventType: string, ...args: any) {\n    this._emitter.emit(eventType, ...args);\n  }\n\n  /**\n   * Emits an event of the given type with the given data, and holds that event\n   * in order to be able to dispatch it to a later subscriber when they say they\n   * want to handle held events.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {...*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.emitAndHold('someEvent', 'abc');\n   *\n   *   emitter.addRetroactiveListener('someEvent', function(message) {\n   *     console.log(message);\n   *   }); // logs 'abc'\n   */\n  emitAndHold(eventType: string, ...args: any) {\n    this._currentEventToken = this._eventHolder.holdEvent(eventType, ...args);\n    this._emitter.emit(eventType, ...args);\n    this._currentEventToken = null;\n  }\n\n  /**\n   * @see EventHolder#releaseCurrentEvent\n   */\n  releaseCurrentEvent() {\n    if (this._currentEventToken) {\n      this._eventHolder.releaseEvent(this._currentEventToken);\n    } else if (this._emittingHeldEvents) {\n      this._eventHolder.releaseCurrentEvent();\n    }\n  }\n\n  /**\n   * @see EventHolder#releaseEventType\n   * @param {string} eventType\n   */\n  releaseHeldEventType(eventType: string) {\n    this._eventHolder.releaseEventType(eventType);\n  }\n}\n\nexport default EventEmitterWithHolding;\n"]},"metadata":{},"sourceType":"module"}