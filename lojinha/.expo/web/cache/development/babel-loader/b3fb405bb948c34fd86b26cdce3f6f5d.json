{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar dataUriPattern = /^data:/;\nexport var ImageUriCache = function () {\n  function ImageUriCache() {\n    _classCallCheck(this, ImageUriCache);\n  }\n\n  _createClass(ImageUriCache, null, [{\n    key: \"has\",\n    value: function has(uri) {\n      var entries = ImageUriCache._entries;\n      var isDataUri = dataUriPattern.test(uri);\n      return isDataUri || Boolean(entries[uri]);\n    }\n  }, {\n    key: \"add\",\n    value: function add(uri) {\n      var entries = ImageUriCache._entries;\n      var lastUsedTimestamp = Date.now();\n\n      if (entries[uri]) {\n        entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n        entries[uri].refCount += 1;\n      } else {\n        entries[uri] = {\n          lastUsedTimestamp: lastUsedTimestamp,\n          refCount: 1\n        };\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(uri) {\n      var entries = ImageUriCache._entries;\n\n      if (entries[uri]) {\n        entries[uri].refCount -= 1;\n      }\n\n      ImageUriCache._cleanUpIfNeeded();\n    }\n  }, {\n    key: \"_cleanUpIfNeeded\",\n    value: function _cleanUpIfNeeded() {\n      var entries = ImageUriCache._entries;\n      var imageUris = Object.keys(entries);\n\n      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n        var leastRecentlyUsedKey;\n        var leastRecentlyUsedEntry;\n        imageUris.forEach(function (uri) {\n          var entry = entries[uri];\n\n          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n            leastRecentlyUsedKey = uri;\n            leastRecentlyUsedEntry = entry;\n          }\n        });\n\n        if (leastRecentlyUsedKey) {\n          delete entries[leastRecentlyUsedKey];\n        }\n      }\n    }\n  }]);\n\n  return ImageUriCache;\n}();\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = function (e) {\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n\n      if (typeof image.decode === 'function') {\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nexport default ImageLoader;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/src/modules/ImageLoader/index.js"],"names":["dataUriPattern","ImageUriCache","uri","entries","_entries","isDataUri","test","Boolean","lastUsedTimestamp","Date","now","refCount","_cleanUpIfNeeded","imageUris","Object","keys","length","_maximumEntries","leastRecentlyUsedKey","leastRecentlyUsedEntry","forEach","entry","id","requests","ImageLoader","abort","requestId","image","onerror","onload","getSize","success","failure","complete","interval","setInterval","callback","load","errorCallback","naturalHeight","naturalWidth","clearInterval","has","onLoad","onError","window","Image","e","onDecode","nativeEvent","decode","then","setTimeout","src","prefetch","Promise","resolve","reject","add","remove","queryCache","uris","result","u"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst dataUriPattern = /^data:/;\n\nexport class ImageUriCache {\n  static _maximumEntries: number = 256;\n  static _entries = {};\n\n  static has(uri: string) {\n    const entries = ImageUriCache._entries;\n    const isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  }\n\n  static add(uri: string) {\n    const entries = ImageUriCache._entries;\n    const lastUsedTimestamp = Date.now();\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  }\n\n  static remove(uri: string) {\n    const entries = ImageUriCache._entries;\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    }\n    // Free up entries when the cache is \"full\"\n    ImageUriCache._cleanUpIfNeeded();\n  }\n\n  static _cleanUpIfNeeded() {\n    const entries = ImageUriCache._entries;\n    const imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      let leastRecentlyUsedKey;\n      let leastRecentlyUsedEntry;\n\n      imageUris.forEach(uri => {\n        const entry = entries[uri];\n        if (\n          (!leastRecentlyUsedEntry ||\n            entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) &&\n          entry.refCount === 0\n        ) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  }\n}\n\nlet id = 0;\nconst requests = {};\n\nconst ImageLoader = {\n  abort(requestId: number) {\n    let image = requests[`${requestId}`];\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[`${requestId}`];\n    }\n  },\n  getSize(uri: string, success: Function, failure: Function) {\n    let complete = false;\n    const interval = setInterval(callback, 16);\n    const requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      const image = requests[`${requestId}`];\n      if (image) {\n        const { naturalHeight, naturalWidth } = image;\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has(uri: string) {\n    return ImageUriCache.has(uri);\n  },\n  load(uri: string, onLoad: Function, onError: Function): number {\n    id += 1;\n    const image = new window.Image();\n    image.onerror = onError;\n    image.onload = e => {\n      // avoid blocking the main thread\n      const onDecode = () => onLoad({ nativeEvent: e });\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n    image.src = uri;\n    requests[`${id}`] = image;\n    return id;\n  },\n  prefetch(uri: string): Promise<*> {\n    return new Promise((resolve, reject) => {\n      ImageLoader.load(\n        uri,\n        () => {\n          // Add the uri to the cache so it can be immediately displayed when used\n          // but also immediately remove it to correctly reflect that it has no active references\n          ImageUriCache.add(uri);\n          ImageUriCache.remove(uri);\n          resolve();\n        },\n        reject\n      );\n    });\n  },\n  queryCache(uris: Array<string>): Object {\n    const result = {};\n    uris.forEach(u => {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\n\nexport default ImageLoader;\n"]},"metadata":{},"sourceType":"module"}