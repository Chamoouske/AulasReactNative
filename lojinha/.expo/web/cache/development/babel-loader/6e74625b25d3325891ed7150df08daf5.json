{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\njest.mock(\"../LogBoxSymbolication\", function () {\n  return {\n    __esModule: true,\n    symbolicate: jest.fn(),\n    deleteStack: jest.fn()\n  };\n});\n\nfunction getLogBoxLog() {\n  return new (require(\"../LogBoxLog\").default)({\n    level: 'warn',\n    isComponentError: false,\n    message: {\n      content: '...',\n      substitutions: []\n    },\n    stack: createStack(['A', 'B', 'C']),\n    category: 'Message category...',\n    componentStack: [{\n      content: 'LogBoxLog',\n      fileName: 'LogBoxLog.js',\n      location: {\n        column: -1,\n        row: 1\n      }\n    }],\n    codeFrame: {\n      fileName: '/path/to/RKJSModules/Apps/CrashReact/CrashReactApp.js',\n      location: {\n        row: 199,\n        column: 0\n      },\n      content: '<code frame>'\n    }\n  });\n}\n\nfunction getLogBoxSymbolication() {\n  return require(\"../LogBoxSymbolication\");\n}\n\nvar createStack = function createStack(methodNames) {\n  return methodNames.map(function (methodName) {\n    return {\n      column: null,\n      file: 'file://path/to/file.js',\n      lineNumber: 1,\n      methodName: methodName\n    };\n  });\n};\n\ndescribe('LogBoxLog', function () {\n  beforeEach(function () {\n    jest.resetModules();\n    getLogBoxSymbolication().symbolicate.mockImplementation(function _callee(stack) {\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", {\n                stack: createStack(stack.map(function (frame) {\n                  return \"S(\" + frame.methodName + \")\";\n                })),\n                codeFrame: null\n              });\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    });\n  });\n  it('creates a LogBoxLog object', function () {\n    var log = getLogBoxLog();\n    expect(log.level).toEqual('warn');\n    expect(log.message).toEqual({\n      content: '...',\n      substitutions: []\n    });\n    expect(log.stack).toEqual(createStack(['A', 'B', 'C']));\n    expect(log.category).toEqual('Message category...');\n    expect(log.componentStack).toEqual([{\n      content: 'LogBoxLog',\n      fileName: 'LogBoxLog.js',\n      location: {\n        column: -1,\n        row: 1\n      }\n    }]);\n    expect(log.codeFrame).toEqual({\n      fileName: '/path/to/RKJSModules/Apps/CrashReact/CrashReactApp.js',\n      location: {\n        row: 199,\n        column: 0\n      },\n      content: '<code frame>'\n    });\n  });\n  it('increments LogBoxLog count', function () {\n    var log = getLogBoxLog();\n    expect(log.count).toEqual(1);\n    log.incrementCount();\n    expect(log.count).toEqual(2);\n  });\n  it('starts without a symbolicated stack', function () {\n    var log = getLogBoxLog();\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: null,\n      status: 'NONE'\n    });\n  });\n  it('updates when symbolication is in progress', function () {\n    var log = getLogBoxLog();\n    var callback = jest.fn();\n    log.symbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalledTimes(1);\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: null,\n      status: 'PENDING'\n    });\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n    log.symbolicate(callback);\n    expect(callback).not.toBeCalled();\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n  it('updates when symbolication finishes', function () {\n    var log = getLogBoxLog();\n    var callback = jest.fn();\n    log.symbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('COMPLETE');\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: createStack(['S(A)', 'S(B)', 'S(C)']),\n      status: 'COMPLETE'\n    });\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n    log.symbolicate(callback);\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(0);\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n  it('updates when symbolication fails', function () {\n    var error = new Error('...');\n    getLogBoxSymbolication().symbolicate.mockImplementation(function _callee2(stack) {\n      return _regeneratorRuntime.async(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              throw error;\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    });\n    var log = getLogBoxLog();\n    var callback = jest.fn();\n    log.symbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('FAILED');\n    expect(log.symbolicated).toEqual({\n      error: error,\n      stack: null,\n      status: 'FAILED'\n    });\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n    log.symbolicate(callback);\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(0);\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n  it('retry updates when symbolication is in progress', function () {\n    var log = getLogBoxLog();\n    var callback = jest.fn();\n    log.retrySymbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalledTimes(1);\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: null,\n      status: 'PENDING'\n    });\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n    log.symbolicate(callback);\n    expect(callback).not.toBeCalled();\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n  it('retry updates when symbolication finishes', function () {\n    var log = getLogBoxLog();\n    var callback = jest.fn();\n    log.retrySymbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('COMPLETE');\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: createStack(['S(A)', 'S(B)', 'S(C)']),\n      status: 'COMPLETE'\n    });\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n    log.retrySymbolicate(callback);\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(0);\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n  it('retry updates when symbolication fails', function () {\n    var error = new Error('...');\n    getLogBoxSymbolication().symbolicate.mockImplementation(function _callee3(stack) {\n      return _regeneratorRuntime.async(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              throw error;\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    });\n    var log = getLogBoxLog();\n    var callback = jest.fn();\n    log.retrySymbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('FAILED');\n    expect(log.symbolicated).toEqual({\n      error: error,\n      stack: null,\n      status: 'FAILED'\n    });\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n    getLogBoxSymbolication().symbolicate.mockImplementation(function _callee4(stack) {\n      return _regeneratorRuntime.async(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", {\n                stack: createStack(stack.map(function (frame) {\n                  return \"S(\" + frame.methodName + \")\";\n                })),\n                codeFrame: null\n              });\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    });\n    log.retrySymbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n    jest.runAllTicks();\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('COMPLETE');\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: createStack(['S(A)', 'S(B)', 'S(C)']),\n      status: 'COMPLETE'\n    });\n  });\n});","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/Libraries/LogBox/Data/__tests__/LogBoxLog-test.js"],"names":["jest","mock","__esModule","symbolicate","fn","deleteStack","getLogBoxLog","require","default","level","isComponentError","message","content","substitutions","stack","createStack","category","componentStack","fileName","location","column","row","codeFrame","getLogBoxSymbolication","methodNames","map","methodName","file","lineNumber","describe","beforeEach","resetModules","mockImplementation","frame","it","log","expect","toEqual","count","incrementCount","symbolicated","error","status","callback","toBeCalledTimes","toBeCalledWith","mockClear","not","toBeCalled","runAllTicks","Error","retrySymbolicate"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @emails oncall+react_native\n * @format\n * @flow\n */\n\n'use strict';\n\nimport type {StackFrame} from '../../../Core/NativeExceptionsManager';\nimport type {SymbolicatedStackTrace} from '../../../Core/Devtools/symbolicateStackTrace';\n\njest.mock('../LogBoxSymbolication', () => {\n  return {__esModule: true, symbolicate: jest.fn(), deleteStack: jest.fn()};\n});\n\nfunction getLogBoxLog() {\n  return new (require('../LogBoxLog')).default({\n    level: 'warn',\n    isComponentError: false,\n    message: {content: '...', substitutions: []},\n    stack: createStack(['A', 'B', 'C']),\n    category: 'Message category...',\n    componentStack: [\n      {\n        content: 'LogBoxLog',\n        fileName: 'LogBoxLog.js',\n        location: {column: -1, row: 1},\n      },\n    ],\n    codeFrame: {\n      fileName: '/path/to/RKJSModules/Apps/CrashReact/CrashReactApp.js',\n      location: {row: 199, column: 0},\n      content: '<code frame>',\n    },\n  });\n}\n\nfunction getLogBoxSymbolication(): {|\n  symbolicate: JestMockFn<\n    $ReadOnlyArray<Array<StackFrame>>,\n    Promise<SymbolicatedStackTrace>,\n  >,\n|} {\n  return (require('../LogBoxSymbolication'): any);\n}\n\nconst createStack = methodNames =>\n  methodNames.map(methodName => ({\n    column: null,\n    file: 'file://path/to/file.js',\n    lineNumber: 1,\n    methodName,\n  }));\n\ndescribe('LogBoxLog', () => {\n  beforeEach(() => {\n    jest.resetModules();\n\n    getLogBoxSymbolication().symbolicate.mockImplementation(async stack => ({\n      stack: createStack(stack.map(frame => `S(${frame.methodName})`)),\n      codeFrame: null,\n    }));\n  });\n\n  it('creates a LogBoxLog object', () => {\n    const log = getLogBoxLog();\n\n    expect(log.level).toEqual('warn');\n    expect(log.message).toEqual({content: '...', substitutions: []});\n    expect(log.stack).toEqual(createStack(['A', 'B', 'C']));\n    expect(log.category).toEqual('Message category...');\n    expect(log.componentStack).toEqual([\n      {\n        content: 'LogBoxLog',\n        fileName: 'LogBoxLog.js',\n        location: {column: -1, row: 1},\n      },\n    ]);\n    expect(log.codeFrame).toEqual({\n      fileName: '/path/to/RKJSModules/Apps/CrashReact/CrashReactApp.js',\n      location: {row: 199, column: 0},\n      content: '<code frame>',\n    });\n  });\n\n  it('increments LogBoxLog count', () => {\n    const log = getLogBoxLog();\n\n    expect(log.count).toEqual(1);\n\n    log.incrementCount();\n\n    expect(log.count).toEqual(2);\n  });\n\n  it('starts without a symbolicated stack', () => {\n    const log = getLogBoxLog();\n\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: null,\n      status: 'NONE',\n    });\n  });\n\n  it('updates when symbolication is in progress', () => {\n    const log = getLogBoxLog();\n\n    const callback = jest.fn();\n    log.symbolicate(callback);\n\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalledTimes(1);\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: null,\n      status: 'PENDING',\n    });\n\n    // Symbolicating while pending should not make more requests.\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n\n    log.symbolicate(callback);\n    expect(callback).not.toBeCalled();\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n\n  it('updates when symbolication finishes', () => {\n    const log = getLogBoxLog();\n\n    const callback = jest.fn();\n    log.symbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('COMPLETE');\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: createStack(['S(A)', 'S(B)', 'S(C)']),\n      status: 'COMPLETE',\n    });\n\n    // Do not symbolicate again.\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n\n    log.symbolicate(callback);\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(0);\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n\n  it('updates when symbolication fails', () => {\n    const error = new Error('...');\n    getLogBoxSymbolication().symbolicate.mockImplementation(async stack => {\n      throw error;\n    });\n\n    const log = getLogBoxLog();\n\n    const callback = jest.fn();\n    log.symbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('FAILED');\n    expect(log.symbolicated).toEqual({\n      error,\n      stack: null,\n      status: 'FAILED',\n    });\n\n    // Do not symbolicate again, retry if needed.\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n\n    log.symbolicate(callback);\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(0);\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n\n  it('retry updates when symbolication is in progress', () => {\n    const log = getLogBoxLog();\n\n    const callback = jest.fn();\n    log.retrySymbolicate(callback);\n\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalledTimes(1);\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: null,\n      status: 'PENDING',\n    });\n\n    // Symbolicating while pending should not make more requests.\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n\n    log.symbolicate(callback);\n    expect(callback).not.toBeCalled();\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n\n  it('retry updates when symbolication finishes', () => {\n    const log = getLogBoxLog();\n\n    const callback = jest.fn();\n    log.retrySymbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('COMPLETE');\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: createStack(['S(A)', 'S(B)', 'S(C)']),\n      status: 'COMPLETE',\n    });\n\n    // Do not symbolicate again\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n\n    log.retrySymbolicate(callback);\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(0);\n    expect(getLogBoxSymbolication().symbolicate).not.toBeCalled();\n  });\n\n  it('retry updates when symbolication fails', () => {\n    const error = new Error('...');\n    getLogBoxSymbolication().symbolicate.mockImplementation(async stack => {\n      throw error;\n    });\n\n    const log = getLogBoxLog();\n\n    const callback = jest.fn();\n    log.retrySymbolicate(callback);\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('FAILED');\n    expect(log.symbolicated).toEqual({\n      error,\n      stack: null,\n      status: 'FAILED',\n    });\n\n    // Retry to symbolicate again.\n    callback.mockClear();\n    getLogBoxSymbolication().symbolicate.mockClear();\n    getLogBoxSymbolication().symbolicate.mockImplementation(async stack => ({\n      stack: createStack(stack.map(frame => `S(${frame.methodName})`)),\n      codeFrame: null,\n    }));\n\n    log.retrySymbolicate(callback);\n\n    expect(callback).toBeCalledTimes(1);\n    expect(callback).toBeCalledWith('PENDING');\n    expect(getLogBoxSymbolication().symbolicate).toBeCalled();\n\n    jest.runAllTicks();\n\n    expect(callback).toBeCalledTimes(2);\n    expect(callback).toBeCalledWith('COMPLETE');\n    expect(log.symbolicated).toEqual({\n      error: null,\n      stack: createStack(['S(A)', 'S(B)', 'S(C)']),\n      status: 'COMPLETE',\n    });\n  });\n});\n"]},"metadata":{},"sourceType":"script"}