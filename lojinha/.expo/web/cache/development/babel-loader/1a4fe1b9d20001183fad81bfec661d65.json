{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar pLimit = require('p-limit');\n\nvar EndError = function (_Error) {\n  _inherits(EndError, _Error);\n\n  var _super = _createSuper(EndError);\n\n  function EndError(value) {\n    var _this;\n\n    _classCallCheck(this, EndError);\n\n    _this = _super.call(this);\n    _this.value = value;\n    return _this;\n  }\n\n  return EndError;\n}(_wrapNativeSuper(Error));\n\nvar testElement = function testElement(element, tester) {\n  return _regeneratorRuntime.async(function testElement$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.t0 = tester;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(element);\n\n        case 3:\n          _context.t1 = _context.sent;\n          return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar finder = function finder(element) {\n  var values;\n  return _regeneratorRuntime.async(function finder$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regeneratorRuntime.awrap(Promise.all(element));\n\n        case 2:\n          values = _context2.sent;\n\n          if (!(values[1] === true)) {\n            _context2.next = 5;\n            break;\n          }\n\n          throw new EndError(values[0]);\n\n        case 5:\n          return _context2.abrupt(\"return\", false);\n\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar pLocate = function pLocate(iterable, tester, options) {\n  var limit, items, checkLimit;\n  return _regeneratorRuntime.async(function pLocate$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _objectSpread({\n            concurrency: Infinity,\n            preserveOrder: true\n          }, options);\n          limit = pLimit(options.concurrency);\n          items = _toConsumableArray(iterable).map(function (element) {\n            return [element, limit(testElement, element, tester)];\n          });\n          checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n          _context3.prev = 4;\n          _context3.next = 7;\n          return _regeneratorRuntime.awrap(Promise.all(items.map(function (element) {\n            return checkLimit(finder, element);\n          })));\n\n        case 7:\n          _context3.next = 14;\n          break;\n\n        case 9:\n          _context3.prev = 9;\n          _context3.t0 = _context3[\"catch\"](4);\n\n          if (!(_context3.t0 instanceof EndError)) {\n            _context3.next = 13;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", _context3.t0.value);\n\n        case 13:\n          throw _context3.t0;\n\n        case 14:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[4, 9]], Promise);\n};\n\nmodule.exports = pLocate;\nmodule.exports.default = pLocate;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/@react-native-community/cli/node_modules/p-locate/index.js"],"names":["pLimit","require","EndError","value","Error","testElement","element","tester","finder","Promise","all","values","pLocate","iterable","options","concurrency","Infinity","preserveOrder","limit","items","map","checkLimit","module","exports","default"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;IAEMC,Q;;;;;AACL,oBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AAClB;AACA,UAAKA,KAAL,GAAaA,KAAb;AAFkB;AAGlB;;;mBAJqBC,K;;AAQvB,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAOC,OAAP,EAAgBC,MAAhB;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA2BA,MAA3B;AAAA;AAAA,2CAAwCD,OAAxC;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAApB;;AAGA,IAAME,MAAM,GAAG,SAATA,MAAS,CAAMF,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACOG,OAAO,CAACC,GAAR,CAAYJ,OAAZ,CADP;;AAAA;AACRK,UAAAA,MADQ;;AAAA,gBAEVA,MAAM,CAAC,CAAD,CAAN,KAAc,IAFJ;AAAA;AAAA;AAAA;;AAAA,gBAGP,IAAIT,QAAJ,CAAaS,MAAM,CAAC,CAAD,CAAnB,CAHO;;AAAA;AAAA,4CAMP,KANO;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAf;;AASA,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAAOC,QAAP,EAAiBN,MAAjB,EAAyBO,OAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AACfA,UAAAA,OAAO;AACNC,YAAAA,WAAW,EAAEC,QADP;AAENC,YAAAA,aAAa,EAAE;AAFT,aAGHH,OAHG,CAAP;AAMMI,UAAAA,KAPS,GAODlB,MAAM,CAACc,OAAO,CAACC,WAAT,CAPL;AAUTI,UAAAA,KAVS,GAUD,mBAAIN,QAAJ,EAAcO,GAAd,CAAkB,UAAAd,OAAO;AAAA,mBAAI,CAACA,OAAD,EAAUY,KAAK,CAACb,WAAD,EAAcC,OAAd,EAAuBC,MAAvB,CAAf,CAAJ;AAAA,WAAzB,CAVC;AAaTc,UAAAA,UAbS,GAaIrB,MAAM,CAACc,OAAO,CAACG,aAAR,GAAwB,CAAxB,GAA4BD,QAA7B,CAbV;AAAA;AAAA;AAAA,2CAgBRP,OAAO,CAACC,GAAR,CAAYS,KAAK,CAACC,GAAN,CAAU,UAAAd,OAAO;AAAA,mBAAIe,UAAU,CAACb,MAAD,EAASF,OAAT,CAAd;AAAA,WAAjB,CAAZ,CAhBQ;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,gBAkBV,wBAAiBJ,QAlBP;AAAA;AAAA;AAAA;;AAAA,4CAmBN,aAAMC,KAnBA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAhB;;AA0BAmB,MAAM,CAACC,OAAP,GAAiBX,OAAjB;AAEAU,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyBZ,OAAzB","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports.default = pLocate;\n"]},"metadata":{},"sourceType":"script"}