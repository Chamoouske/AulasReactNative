{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nvar _require = require('util'),\n    promisify = _require.promisify;\n\nvar pLocate = require('p-locate');\n\nvar fsStat = promisify(fs.stat);\nvar fsLStat = promisify(fs.lstat);\nvar typeMappings = {\n  directory: 'isDirectory',\n  file: 'isFile'\n};\n\nfunction checkType(_ref) {\n  var type = _ref.type;\n\n  if (type in typeMappings) {\n    return;\n  }\n\n  throw new Error(\"Invalid type specified: \" + type);\n}\n\nvar matchType = function matchType(type, stat) {\n  return type === undefined || stat[typeMappings[type]]();\n};\n\nmodule.exports = function _callee2(paths, options) {\n  var statFn;\n  return _regeneratorRuntime.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _objectSpread({\n            cwd: process.cwd(),\n            type: 'file',\n            allowSymlinks: true\n          }, options);\n          checkType(options);\n          statFn = options.allowSymlinks ? fsStat : fsLStat;\n          return _context2.abrupt(\"return\", pLocate(paths, function _callee(path_) {\n            var stat;\n            return _regeneratorRuntime.async(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.prev = 0;\n                    _context.next = 3;\n                    return _regeneratorRuntime.awrap(statFn(path.resolve(options.cwd, path_)));\n\n                  case 3:\n                    stat = _context.sent;\n                    return _context.abrupt(\"return\", matchType(options.type, stat));\n\n                  case 7:\n                    _context.prev = 7;\n                    _context.t0 = _context[\"catch\"](0);\n                    return _context.abrupt(\"return\", false);\n\n                  case 10:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, null, null, [[0, 7]], Promise);\n          }, options));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nmodule.exports.sync = function (paths, options) {\n  options = _objectSpread({\n    cwd: process.cwd(),\n    allowSymlinks: true,\n    type: 'file'\n  }, options);\n  checkType(options);\n  var statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {\n    var path_ = _step.value;\n\n    try {\n      var stat = statFn(path.resolve(options.cwd, path_));\n\n      if (matchType(options.type, stat)) {\n        return path_;\n      }\n    } catch (_) {}\n  }\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/@react-native-community/cli/node_modules/locate-path/index.js"],"names":["path","require","fs","promisify","pLocate","fsStat","stat","fsLStat","lstat","typeMappings","directory","file","checkType","type","Error","matchType","undefined","module","exports","paths","options","cwd","process","allowSymlinks","statFn","path_","resolve","sync","statSync","lstatSync","_"],"mappings":"AAAA;;;;;;;;;;;;;;;;AACA,IAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;eACoBA,OAAO,CAAC,MAAD,C;IAApBE,S,YAAAA,S;;AACP,IAAMC,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;;AAEA,IAAMI,MAAM,GAAGF,SAAS,CAACD,EAAE,CAACI,IAAJ,CAAxB;AACA,IAAMC,OAAO,GAAGJ,SAAS,CAACD,EAAE,CAACM,KAAJ,CAAzB;AAEA,IAAMC,YAAY,GAAG;AACpBC,EAAAA,SAAS,EAAE,aADS;AAEpBC,EAAAA,IAAI,EAAE;AAFc,CAArB;;AAKA,SAASC,SAAT,OAA2B;AAAA,MAAPC,IAAO,QAAPA,IAAO;;AAC1B,MAAIA,IAAI,IAAIJ,YAAZ,EAA0B;AACzB;AACA;;AAED,QAAM,IAAIK,KAAJ,8BAAqCD,IAArC,CAAN;AACA;;AAED,IAAME,SAAS,GAAG,SAAZA,SAAY,CAACF,IAAD,EAAOP,IAAP;AAAA,SAAgBO,IAAI,KAAKG,SAAT,IAAsBV,IAAI,CAACG,YAAY,CAACI,IAAD,CAAb,CAAJ,EAAtC;AAAA,CAAlB;;AAEAI,MAAM,CAACC,OAAP,GAAiB,kBAAOC,KAAP,EAAcC,OAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAChBA,UAAAA,OAAO;AACNC,YAAAA,GAAG,EAAEC,OAAO,CAACD,GAAR,EADC;AAENR,YAAAA,IAAI,EAAE,MAFA;AAGNU,YAAAA,aAAa,EAAE;AAHT,aAIHH,OAJG,CAAP;AAMAR,UAAAA,SAAS,CAACQ,OAAD,CAAT;AACMI,UAAAA,MARU,GAQDJ,OAAO,CAACG,aAAR,GAAwBlB,MAAxB,GAAiCE,OARhC;AAAA,4CAUTH,OAAO,CAACe,KAAD,EAAQ,iBAAMM,KAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qDAEDD,MAAM,CAACxB,IAAI,CAAC0B,OAAL,CAAaN,OAAO,CAACC,GAArB,EAA0BI,KAA1B,CAAD,CAFL;;AAAA;AAEdnB,oBAAAA,IAFc;AAAA,qDAGbS,SAAS,CAACK,OAAO,CAACP,IAAT,EAAeP,IAAf,CAHI;;AAAA;AAAA;AAAA;AAAA,qDAKb,KALa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAR,EAOXc,OAPW,CAVE;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAjB;;AAoBAH,MAAM,CAACC,OAAP,CAAeS,IAAf,GAAsB,UAACR,KAAD,EAAQC,OAAR,EAAoB;AACzCA,EAAAA,OAAO;AACNC,IAAAA,GAAG,EAAEC,OAAO,CAACD,GAAR,EADC;AAENE,IAAAA,aAAa,EAAE,IAFT;AAGNV,IAAAA,IAAI,EAAE;AAHA,KAIHO,OAJG,CAAP;AAMAR,EAAAA,SAAS,CAACQ,OAAD,CAAT;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAACG,aAAR,GAAwBrB,EAAE,CAAC0B,QAA3B,GAAsC1B,EAAE,CAAC2B,SAAxD;;AAEA,uDAAoBV,KAApB,wCAA2B;AAAA,QAAhBM,KAAgB;;AAC1B,QAAI;AACH,UAAMnB,IAAI,GAAGkB,MAAM,CAACxB,IAAI,CAAC0B,OAAL,CAAaN,OAAO,CAACC,GAArB,EAA0BI,KAA1B,CAAD,CAAnB;;AAEA,UAAIV,SAAS,CAACK,OAAO,CAACP,IAAT,EAAeP,IAAf,CAAb,EAAmC;AAClC,eAAOmB,KAAP;AACA;AACD,KAND,CAME,OAAOK,CAAP,EAAU,CACX;AACD;AACD,CApBD","sourcesContent":["'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst {promisify} = require('util');\nconst pLocate = require('p-locate');\n\nconst fsStat = promisify(fs.stat);\nconst fsLStat = promisify(fs.lstat);\n\nconst typeMappings = {\n\tdirectory: 'isDirectory',\n\tfile: 'isFile'\n};\n\nfunction checkType({type}) {\n\tif (type in typeMappings) {\n\t\treturn;\n\t}\n\n\tthrow new Error(`Invalid type specified: ${type}`);\n}\n\nconst matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();\n\nmodule.exports = async (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\ttype: 'file',\n\t\tallowSymlinks: true,\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fsStat : fsLStat;\n\n\treturn pLocate(paths, async path_ => {\n\t\ttry {\n\t\t\tconst stat = await statFn(path.resolve(options.cwd, path_));\n\t\t\treturn matchType(options.type, stat);\n\t\t} catch (_) {\n\t\t\treturn false;\n\t\t}\n\t}, options);\n};\n\nmodule.exports.sync = (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\tallowSymlinks: true,\n\t\ttype: 'file',\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;\n\n\tfor (const path_ of paths) {\n\t\ttry {\n\t\t\tconst stat = statFn(path.resolve(options.cwd, path_));\n\n\t\t\tif (matchType(options.type, stat)) {\n\t\t\t\treturn path_;\n\t\t\t}\n\t\t} catch (_) {\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}