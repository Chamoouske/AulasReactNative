{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nvar isActiveSignal = function isActiveSignal(signal) {\n  return signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\n\nvar isPressStartSignal = function isPressStartSignal(signal) {\n  return signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\n\nvar isTerminalSignal = function isTerminalSignal(signal) {\n  return signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n};\n\nvar isValidKeyPress = function isValidKeyPress(event) {\n  var key = event.key;\n  var target = event.currentTarget;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return !event.repeat && (key === 'Enter' || isSpacebar && (role === 'button' || role === 'menuitem'));\n};\n\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450;\nvar DEFAULT_PRESS_DELAY_MS = 50;\n\nvar PressResponder = function () {\n  function PressResponder(config) {\n    _classCallCheck(this, PressResponder);\n\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n\n  _createClass(PressResponder, [{\n    key: \"configure\",\n    value: function configure(config) {\n      this._config = config;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._cancelLongPressDelayTimeout();\n\n      this._cancelPressDelayTimeout();\n\n      this._cancelPressOutDelayTimeout();\n    }\n  }, {\n    key: \"getEventHandlers\",\n    value: function getEventHandlers() {\n      if (this._eventHandlers == null) {\n        this._eventHandlers = this._createEventHandlers();\n      }\n\n      return this._eventHandlers;\n    }\n  }, {\n    key: \"_createEventHandlers\",\n    value: function _createEventHandlers() {\n      var _this = this;\n\n      var start = function start(event, shouldDelay) {\n        event.persist();\n\n        _this._cancelPressOutDelayTimeout();\n\n        _this._longPressDispatched = false;\n        _this._responder = event.currentTarget;\n        _this._selectionTerminated = false;\n        _this._touchState = NOT_RESPONDER;\n        _this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n        _this._receiveSignal(RESPONDER_GRANT, event);\n\n        var delayPressStart = normalizeDelay(_this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n\n        if (shouldDelay !== false && delayPressStart > 0) {\n          _this._pressDelayTimeout = setTimeout(function () {\n            _this._receiveSignal(DELAY, event);\n          }, delayPressStart);\n        } else {\n          _this._receiveSignal(DELAY, event);\n        }\n\n        var delayLongPress = normalizeDelay(_this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n        _this._longPressDelayTimeout = setTimeout(function () {\n          _this._handleLongPress(event);\n        }, delayLongPress + delayPressStart);\n      };\n\n      var end = function end(event) {\n        _this._receiveSignal(RESPONDER_RELEASE, event);\n      };\n\n      var keyupHandler = function keyupHandler(event) {\n        if (_this._touchState !== NOT_RESPONDER) {\n          end(event);\n          document.removeEventListener('keyup', keyupHandler);\n        }\n      };\n\n      return {\n        onStartShouldSetResponder: function onStartShouldSetResponder() {\n          var disabled = _this._config.disabled;\n\n          if (disabled == null) {\n            return true;\n          }\n\n          return !disabled;\n        },\n        onKeyDown: function onKeyDown(event) {\n          if (isValidKeyPress(event)) {\n            if (_this._touchState === NOT_RESPONDER) {\n              start(event, false);\n              document.addEventListener('keyup', keyupHandler);\n            }\n\n            event.stopPropagation();\n          }\n        },\n        onResponderGrant: function onResponderGrant(event) {\n          return start(event);\n        },\n        onResponderMove: function onResponderMove(event) {\n          if (_this._config.onPressMove != null) {\n            _this._config.onPressMove(event);\n          }\n\n          var touch = getTouchFromResponderEvent(event);\n\n          if (_this._touchActivatePosition != null) {\n            var deltaX = _this._touchActivatePosition.pageX - touch.pageX;\n            var deltaY = _this._touchActivatePosition.pageY - touch.pageY;\n\n            if (Math.hypot(deltaX, deltaY) > 10) {\n              _this._cancelLongPressDelayTimeout();\n            }\n          }\n        },\n        onResponderRelease: function onResponderRelease(event) {\n          return end(event);\n        },\n        onResponderTerminate: function onResponderTerminate(event) {\n          if (event.nativeEvent.type === 'selectionchange') {\n            _this._selectionTerminated = true;\n          }\n\n          _this._receiveSignal(RESPONDER_TERMINATED, event);\n        },\n        onResponderTerminationRequest: function onResponderTerminationRequest(event) {\n          var _this$_config = _this._config,\n              cancelable = _this$_config.cancelable,\n              disabled = _this$_config.disabled,\n              onLongPress = _this$_config.onLongPress;\n\n          if (!disabled && onLongPress != null && _this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n            return false;\n          }\n\n          if (cancelable == null) {\n            return true;\n          }\n\n          return cancelable;\n        },\n        onClick: function onClick(event) {\n          var _this$_config2 = _this._config,\n              disabled = _this$_config2.disabled,\n              onPress = _this$_config2.onPress;\n\n          if (!disabled) {\n            if (_this._longPressDispatched || _this._selectionTerminated) {\n              event.preventDefault();\n            } else if (onPress != null && event.ctrlKey === false && event.altKey === false) {\n              onPress(event);\n            }\n          }\n\n          event.stopPropagation();\n        },\n        onContextMenu: function onContextMenu(event) {\n          var _this$_config3 = _this._config,\n              disabled = _this$_config3.disabled,\n              onLongPress = _this$_config3.onLongPress;\n\n          if (!disabled && onLongPress != null && _this._isPointerTouch && !event.defaultPrevented) {\n            event.preventDefault();\n          }\n\n          event.stopPropagation();\n        }\n      };\n    }\n  }, {\n    key: \"_receiveSignal\",\n    value: function _receiveSignal(signal, event) {\n      var prevState = this._touchState;\n      var nextState = null;\n\n      if (Transitions[prevState] != null) {\n        nextState = Transitions[prevState][signal];\n      }\n\n      if (this._responder == null && signal === RESPONDER_RELEASE) {\n        return;\n      }\n\n      if (nextState == null || nextState === ERROR) {\n        console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n      } else if (prevState !== nextState) {\n        this._performTransitionSideEffects(prevState, nextState, signal, event);\n\n        this._touchState = nextState;\n      }\n    }\n  }, {\n    key: \"_performTransitionSideEffects\",\n    value: function _performTransitionSideEffects(prevState, nextState, signal, event) {\n      if (isTerminalSignal(signal)) {\n        this._isPointerTouch = false;\n        this._touchActivatePosition = null;\n\n        this._cancelLongPressDelayTimeout();\n      }\n\n      if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n        var onLongPress = this._config.onLongPress;\n\n        if (onLongPress != null && event.nativeEvent.key == null) {\n          onLongPress(event);\n          this._longPressDispatched = true;\n        }\n      }\n\n      var isPrevActive = isActiveSignal(prevState);\n      var isNextActive = isActiveSignal(nextState);\n\n      if (!isPrevActive && isNextActive) {\n        this._activate(event);\n      } else if (isPrevActive && !isNextActive) {\n        this._deactivate(event);\n      }\n\n      if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n        var _this$_config4 = this._config,\n            _onLongPress = _this$_config4.onLongPress,\n            onPress = _this$_config4.onPress;\n\n        if (onPress != null) {\n          var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n\n          if (!isPressCanceledByLongPress) {\n            if (!isNextActive && !isPrevActive) {\n              this._activate(event);\n\n              this._deactivate(event);\n            }\n          }\n        }\n      }\n\n      this._cancelPressDelayTimeout();\n    }\n  }, {\n    key: \"_activate\",\n    value: function _activate(event) {\n      var _this$_config5 = this._config,\n          onPressChange = _this$_config5.onPressChange,\n          onPressStart = _this$_config5.onPressStart;\n      var touch = getTouchFromResponderEvent(event);\n      this._touchActivatePosition = {\n        pageX: touch.pageX,\n        pageY: touch.pageY\n      };\n\n      if (onPressStart != null) {\n        onPressStart(event);\n      }\n\n      if (onPressChange != null) {\n        onPressChange(true);\n      }\n    }\n  }, {\n    key: \"_deactivate\",\n    value: function _deactivate(event) {\n      var _this$_config6 = this._config,\n          onPressChange = _this$_config6.onPressChange,\n          onPressEnd = _this$_config6.onPressEnd;\n\n      function end() {\n        if (onPressEnd != null) {\n          onPressEnd(event);\n        }\n\n        if (onPressChange != null) {\n          onPressChange(false);\n        }\n      }\n\n      var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n\n      if (delayPressEnd > 0) {\n        this._pressOutDelayTimeout = setTimeout(function () {\n          end();\n        }, delayPressEnd);\n      } else {\n        end();\n      }\n    }\n  }, {\n    key: \"_handleLongPress\",\n    value: function _handleLongPress(event) {\n      if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n        this._receiveSignal(LONG_PRESS_DETECTED, event);\n      }\n    }\n  }, {\n    key: \"_cancelLongPressDelayTimeout\",\n    value: function _cancelLongPressDelayTimeout() {\n      if (this._longPressDelayTimeout != null) {\n        clearTimeout(this._longPressDelayTimeout);\n        this._longPressDelayTimeout = null;\n      }\n    }\n  }, {\n    key: \"_cancelPressDelayTimeout\",\n    value: function _cancelPressDelayTimeout() {\n      if (this._pressDelayTimeout != null) {\n        clearTimeout(this._pressDelayTimeout);\n        this._pressDelayTimeout = null;\n      }\n    }\n  }, {\n    key: \"_cancelPressOutDelayTimeout\",\n    value: function _cancelPressOutDelayTimeout() {\n      if (this._pressOutDelayTimeout != null) {\n        clearTimeout(this._pressOutDelayTimeout);\n        this._pressOutDelayTimeout = null;\n      }\n    }\n  }]);\n\n  return PressResponder;\n}();\n\nexport { PressResponder as default };\n\nfunction normalizeDelay(delay) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return Math.max(min, delay != null ? delay : fallback);\n}\n\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n      changedTouches = _event$nativeEvent.changedTouches,\n      touches = _event$nativeEvent.touches;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n\n  return event.nativeEvent;\n}","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/src/hooks/usePressEvents/PressResponder.js"],"names":["DELAY","ERROR","LONG_PRESS_DETECTED","NOT_RESPONDER","RESPONDER_ACTIVE_LONG_PRESS_START","RESPONDER_ACTIVE_PRESS_START","RESPONDER_INACTIVE_PRESS_START","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","Transitions","Object","freeze","isActiveSignal","signal","isPressStartSignal","isTerminalSignal","isValidKeyPress","event","key","target","currentTarget","role","getAttribute","isSpacebar","repeat","DEFAULT_LONG_PRESS_DELAY_MS","DEFAULT_PRESS_DELAY_MS","PressResponder","config","_eventHandlers","_isPointerTouch","_longPressDelayTimeout","_longPressDispatched","_pressDelayTimeout","_pressOutDelayTimeout","_touchState","configure","_config","_cancelLongPressDelayTimeout","_cancelPressDelayTimeout","_cancelPressOutDelayTimeout","_createEventHandlers","start","shouldDelay","persist","_responder","_selectionTerminated","nativeEvent","type","_receiveSignal","delayPressStart","normalizeDelay","setTimeout","delayLongPress","_handleLongPress","end","keyupHandler","document","removeEventListener","onStartShouldSetResponder","disabled","onKeyDown","addEventListener","stopPropagation","onResponderGrant","onResponderMove","onPressMove","touch","getTouchFromResponderEvent","_touchActivatePosition","deltaX","pageX","deltaY","pageY","Math","hypot","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","onLongPress","onClick","onPress","preventDefault","ctrlKey","altKey","onContextMenu","defaultPrevented","prevState","nextState","console","error","_performTransitionSideEffects","isPrevActive","isNextActive","_activate","_deactivate","isPressCanceledByLongPress","onPressChange","onPressStart","onPressEnd","delayPressEnd","clearTimeout","delay","min","fallback","max","changedTouches","touches","length"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\ntype ClickEvent = any;\ntype KeyboardEvent = any;\ntype ResponderEvent = any;\n\nexport type PressResponderConfig = $ReadOnly<{|\n  // The gesture can be interrupted by a parent gesture, e.g., scroll.\n  // Defaults to true.\n  cancelable?: ?boolean,\n  // Whether to disable initialization of the press gesture.\n  disabled?: ?boolean,\n  // Duration (in addition to `delayPressStart`) after which a press gesture is\n  // considered a long press gesture. Defaults to 500 (milliseconds).\n  delayLongPress?: ?number,\n  // Duration to wait after press down before calling `onPressStart`.\n  delayPressStart?: ?number,\n  // Duration to wait after letting up before calling `onPressEnd`.\n  delayPressEnd?: ?number,\n  // Called when a long press gesture has been triggered.\n  onLongPress?: ?(event: ResponderEvent) => void,\n  // Called when a press gestute has been triggered.\n  onPress?: ?(event: ClickEvent) => void,\n  // Called when the press is activated to provide visual feedback.\n  onPressChange?: ?(event: ResponderEvent) => void,\n  // Called when the press is activated to provide visual feedback.\n  onPressStart?: ?(event: ResponderEvent) => void,\n  // Called when the press location moves. (This should rarely be used.)\n  onPressMove?: ?(event: ResponderEvent) => void,\n  // Called when the press is deactivated to undo visual feedback.\n  onPressEnd?: ?(event: ResponderEvent) => void\n|}>;\n\nexport type EventHandlers = $ReadOnly<{|\n  onClick: (event: ClickEvent) => void,\n  onContextMenu: (event: ClickEvent) => void,\n  onKeyDown: (event: KeyboardEvent) => void,\n  onResponderGrant: (event: ResponderEvent) => void,\n  onResponderMove: (event: ResponderEvent) => void,\n  onResponderRelease: (event: ResponderEvent) => void,\n  onResponderTerminate: (event: ResponderEvent) => void,\n  onResponderTerminationRequest: (event: ResponderEvent) => boolean,\n  onStartShouldSetResponder: (event: ResponderEvent) => boolean\n|}>;\n\ntype TouchState =\n  | 'NOT_RESPONDER'\n  | 'RESPONDER_INACTIVE_PRESS_START'\n  | 'RESPONDER_ACTIVE_PRESS_START'\n  | 'RESPONDER_ACTIVE_LONG_PRESS_START'\n  | 'ERROR';\n\ntype TouchSignal =\n  | 'DELAY'\n  | 'RESPONDER_GRANT'\n  | 'RESPONDER_RELEASE'\n  | 'RESPONDER_TERMINATED'\n  | 'LONG_PRESS_DETECTED';\n\nconst DELAY = 'DELAY';\nconst ERROR = 'ERROR';\nconst LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nconst NOT_RESPONDER = 'NOT_RESPONDER';\nconst RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nconst RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nconst RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nconst RESPONDER_GRANT = 'RESPONDER_GRANT';\nconst RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nconst RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\n\nconst Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nconst isActiveSignal = signal =>\n  signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nconst isPressStartSignal = signal =>\n  signal === RESPONDER_INACTIVE_PRESS_START ||\n  signal === RESPONDER_ACTIVE_PRESS_START ||\n  signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nconst isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n\nconst isValidKeyPress = event => {\n  const key = event.key;\n  const target = event.currentTarget;\n  const role = target.getAttribute('role');\n  const isSpacebar = key === ' ' || key === 'Spacebar';\n  return (\n    !event.repeat && (key === 'Enter' || (isSpacebar && (role === 'button' || role === 'menuitem')))\n  );\n};\n\nconst DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\nconst DEFAULT_PRESS_DELAY_MS = 50;\n\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\nexport default class PressResponder {\n  _config: PressResponderConfig;\n  _eventHandlers: ?EventHandlers = null;\n  _isPointerTouch: ?boolean = false;\n  _longPressDelayTimeout: ?TimeoutID = null;\n  _longPressDispatched: ?boolean = false;\n  _pressDelayTimeout: ?TimeoutID = null;\n  _pressOutDelayTimeout: ?TimeoutID = null;\n  _responder: ?any;\n  _selectionTerminated: ?boolean;\n  _touchActivatePosition: ?$ReadOnly<{|\n    pageX: number,\n    pageY: number\n  |}>;\n  _touchState: TouchState = NOT_RESPONDER;\n\n  constructor(config: PressResponderConfig) {\n    this.configure(config);\n  }\n\n  configure(config: PressResponderConfig): void {\n    this._config = config;\n  }\n\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n  reset(): void {\n    this._cancelLongPressDelayTimeout();\n    this._cancelPressDelayTimeout();\n    this._cancelPressOutDelayTimeout();\n  }\n\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n  getEventHandlers(): EventHandlers {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n    return this._eventHandlers;\n  }\n\n  _createEventHandlers(): EventHandlers {\n    const start = (event: ResponderEvent, shouldDelay?: boolean): void => {\n      event.persist();\n\n      this._cancelPressOutDelayTimeout();\n\n      this._longPressDispatched = false;\n      this._responder = event.currentTarget;\n      this._selectionTerminated = false;\n      this._touchState = NOT_RESPONDER;\n      this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n      this._receiveSignal(RESPONDER_GRANT, event);\n\n      const delayPressStart = normalizeDelay(\n        this._config.delayPressStart,\n        0,\n        DEFAULT_PRESS_DELAY_MS\n      );\n\n      if (shouldDelay !== false && delayPressStart > 0) {\n        this._pressDelayTimeout = setTimeout(() => {\n          this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        this._receiveSignal(DELAY, event);\n      }\n\n      const delayLongPress = normalizeDelay(\n        this._config.delayLongPress,\n        10,\n        DEFAULT_LONG_PRESS_DELAY_MS\n      );\n      this._longPressDelayTimeout = setTimeout(() => {\n        this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n\n    const end = (event: ResponderEvent): void => {\n      this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n\n    const keyupHandler = (event: KeyboardEvent) => {\n      if (this._touchState !== NOT_RESPONDER) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n      }\n    };\n\n    return {\n      onStartShouldSetResponder: (): boolean => {\n        const { disabled } = this._config;\n        if (disabled == null) {\n          return true;\n        }\n        return !disabled;\n      },\n\n      onKeyDown: event => {\n        if (isValidKeyPress(event)) {\n          if (this._touchState === NOT_RESPONDER) {\n            start(event, false);\n            // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n            document.addEventListener('keyup', keyupHandler);\n          }\n          event.stopPropagation();\n        }\n      },\n\n      onResponderGrant: event => start(event),\n\n      onResponderMove: event => {\n        if (this._config.onPressMove != null) {\n          this._config.onPressMove(event);\n        }\n        const touch = getTouchFromResponderEvent(event);\n        if (this._touchActivatePosition != null) {\n          const deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          const deltaY = this._touchActivatePosition.pageY - touch.pageY;\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n\n      onResponderRelease: event => end(event),\n\n      onResponderTerminate: event => {\n        if (event.nativeEvent.type === 'selectionchange') {\n          this._selectionTerminated = true;\n        }\n        this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n\n      onResponderTerminationRequest: (event): boolean => {\n        const { cancelable, disabled, onLongPress } = this._config;\n        // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n        if (\n          !disabled &&\n          onLongPress != null &&\n          this._isPointerTouch &&\n          event.nativeEvent.type === 'contextmenu'\n        ) {\n          return false;\n        }\n        if (cancelable == null) {\n          return true;\n        }\n        return cancelable;\n      },\n\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: (event: any): void => {\n        const { disabled, onPress } = this._config;\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          if (this._longPressDispatched || this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.ctrlKey === false && event.altKey === false) {\n            onPress(event);\n          }\n        }\n        event.stopPropagation();\n      },\n\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: (event: any): void => {\n        const { disabled, onLongPress } = this._config;\n        if (!disabled && onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {\n          event.preventDefault();\n        }\n        event.stopPropagation();\n      }\n    };\n  }\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n  _receiveSignal(signal: TouchSignal, event: ResponderEvent): void {\n    const prevState = this._touchState;\n    let nextState = null;\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n    if (this._responder == null && signal === RESPONDER_RELEASE) {\n      return;\n    }\n    if (nextState == null || nextState === ERROR) {\n      console.error(`PressResponder: Invalid signal ${signal} for state ${prevState} on responder`);\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n      this._touchState = nextState;\n    }\n  }\n\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n  _performTransitionSideEffects(\n    prevState: TouchState,\n    nextState: TouchState,\n    signal: TouchSignal,\n    event: ResponderEvent\n  ): void {\n    if (isTerminalSignal(signal)) {\n      this._isPointerTouch = false;\n      this._touchActivatePosition = null;\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      const { onLongPress } = this._config;\n      // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n\n    const isPrevActive = isActiveSignal(prevState);\n    const isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      const { onLongPress, onPress } = this._config;\n      if (onPress != null) {\n        const isPressCanceledByLongPress =\n          onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  }\n\n  _activate(event: ResponderEvent): void {\n    const { onPressChange, onPressStart } = this._config;\n    const touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  }\n\n  _deactivate(event: ResponderEvent): void {\n    const { onPressChange, onPressEnd } = this._config;\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n    const delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(() => {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  }\n\n  _handleLongPress(event: ResponderEvent): void {\n    if (\n      this._touchState === RESPONDER_ACTIVE_PRESS_START ||\n      this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START\n    ) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  }\n\n  _cancelLongPressDelayTimeout(): void {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressDelayTimeout(): void {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressOutDelayTimeout(): void {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n}\n\nfunction normalizeDelay(delay: ?number, min = 0, fallback = 0): number {\n  return Math.max(min, delay ?? fallback);\n}\n\nfunction getTouchFromResponderEvent(event: ResponderEvent) {\n  const { changedTouches, touches } = event.nativeEvent;\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n  return event.nativeEvent;\n}\n"]},"metadata":{},"sourceType":"module"}