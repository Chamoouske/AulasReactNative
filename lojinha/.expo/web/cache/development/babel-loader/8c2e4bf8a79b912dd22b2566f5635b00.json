{"ast":null,"code":"'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\n\nvar EventHolder = function () {\n  function EventHolder() {\n    this._heldEvents = {};\n    this._currentEventKey = null;\n  }\n\n  var _proto = EventHolder.prototype;\n\n  _proto.holdEvent = function holdEvent(eventType) {\n    this._heldEvents[eventType] = this._heldEvents[eventType] || [];\n    var eventsOfType = this._heldEvents[eventType];\n    var key = {\n      eventType: eventType,\n      index: eventsOfType.length\n    };\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    eventsOfType.push(args);\n    return key;\n  };\n\n  _proto.emitToListener = function emitToListener(eventType, listener, context) {\n    var _this = this;\n\n    var eventsOfType = this._heldEvents[eventType];\n\n    if (!eventsOfType) {\n      return;\n    }\n\n    var origEventKey = this._currentEventKey;\n    eventsOfType.forEach(function (eventHeld, index) {\n      if (!eventHeld) {\n        return;\n      }\n\n      _this._currentEventKey = {\n        eventType: eventType,\n        index: index\n      };\n      listener.apply(context, eventHeld);\n    });\n    this._currentEventKey = origEventKey;\n  };\n\n  _proto.releaseCurrentEvent = function releaseCurrentEvent() {\n    invariant(this._currentEventKey !== null, 'Not in an emitting cycle; there is no current event');\n    this._currentEventKey && this.releaseEvent(this._currentEventKey);\n  };\n\n  _proto.releaseEvent = function releaseEvent(token) {\n    delete this._heldEvents[token.eventType][token.index];\n  };\n\n  _proto.releaseEventType = function releaseEventType(type) {\n    this._heldEvents[type] = [];\n  };\n\n  return EventHolder;\n}();\n\nexport default EventHolder;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/dist/vendor/react-native/emitter/EventHolder.js"],"names":["invariant","EventHolder","_heldEvents","_currentEventKey","_proto","prototype","holdEvent","eventType","eventsOfType","key","index","length","_len","arguments","args","Array","_key","push","emitToListener","listener","context","_this","origEventKey","forEach","eventHeld","apply","releaseCurrentEvent","releaseEvent","token","releaseEventType","type"],"mappings":"AASA;;AAEA,OAAOA,SAAP,MAAsB,oBAAtB;;AAEA,IAAIC,WAAW,GAEf,YAAY;AACV,WAASA,WAAT,GAAuB;AACrB,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACD;;AAwBD,MAAIC,MAAM,GAAGH,WAAW,CAACI,SAAzB;;AAEAD,EAAAA,MAAM,CAACE,SAAP,GAAmB,SAASA,SAAT,CAAmBC,SAAnB,EAA8B;AAC/C,SAAKL,WAAL,CAAiBK,SAAjB,IAA8B,KAAKL,WAAL,CAAiBK,SAAjB,KAA+B,EAA7D;AACA,QAAIC,YAAY,GAAG,KAAKN,WAAL,CAAiBK,SAAjB,CAAnB;AACA,QAAIE,GAAG,GAAG;AACRF,MAAAA,SAAS,EAAEA,SADH;AAERG,MAAAA,KAAK,EAAEF,YAAY,CAACG;AAFZ,KAAV;;AAKA,SAAK,IAAIC,IAAI,GAAGC,SAAS,CAACF,MAArB,EAA6BG,IAAI,GAAG,IAAIC,KAAJ,CAAUH,IAAI,GAAG,CAAP,GAAWA,IAAI,GAAG,CAAlB,GAAsB,CAAhC,CAApC,EAAwEI,IAAI,GAAG,CAApF,EAAuFA,IAAI,GAAGJ,IAA9F,EAAoGI,IAAI,EAAxG,EAA4G;AAC1GF,MAAAA,IAAI,CAACE,IAAI,GAAG,CAAR,CAAJ,GAAiBH,SAAS,CAACG,IAAD,CAA1B;AACD;;AAEDR,IAAAA,YAAY,CAACS,IAAb,CAAkBH,IAAlB;AACA,WAAOL,GAAP;AACD,GAdD;;AAyBAL,EAAAA,MAAM,CAACc,cAAP,GAAwB,SAASA,cAAT,CAAwBX,SAAxB,EAAmCY,QAAnC,EAA6CC,OAA7C,EAAsD;AAC5E,QAAIC,KAAK,GAAG,IAAZ;;AAEA,QAAIb,YAAY,GAAG,KAAKN,WAAL,CAAiBK,SAAjB,CAAnB;;AAEA,QAAI,CAACC,YAAL,EAAmB;AACjB;AACD;;AAED,QAAIc,YAAY,GAAG,KAAKnB,gBAAxB;AACAK,IAAAA,YAAY,CAACe,OAAb,CAAqB,UAErBC,SAFqB,EAIrBd,KAJqB,EAId;AACL,UAAI,CAACc,SAAL,EAAgB;AACd;AACD;;AAEDH,MAAAA,KAAK,CAAClB,gBAAN,GAAyB;AACvBI,QAAAA,SAAS,EAAEA,SADY;AAEvBG,QAAAA,KAAK,EAAEA;AAFgB,OAAzB;AAIAS,MAAAA,QAAQ,CAACM,KAAT,CAAeL,OAAf,EAAwBI,SAAxB;AACD,KAdD;AAeA,SAAKrB,gBAAL,GAAwBmB,YAAxB;AACD,GA1BD;;AAqCAlB,EAAAA,MAAM,CAACsB,mBAAP,GAA6B,SAASA,mBAAT,GAA+B;AAC1D1B,IAAAA,SAAS,CAAC,KAAKG,gBAAL,KAA0B,IAA3B,EAAiC,qDAAjC,CAAT;AACA,SAAKA,gBAAL,IAAyB,KAAKwB,YAAL,CAAkB,KAAKxB,gBAAvB,CAAzB;AACD,GAHD;;AAYAC,EAAAA,MAAM,CAACuB,YAAP,GAAsB,SAASA,YAAT,CAAsBC,KAAtB,EAA6B;AACjD,WAAO,KAAK1B,WAAL,CAAiB0B,KAAK,CAACrB,SAAvB,EAAkCqB,KAAK,CAAClB,KAAxC,CAAP;AACD,GAFD;;AAUAN,EAAAA,MAAM,CAACyB,gBAAP,GAA0B,SAASA,gBAAT,CAA0BC,IAA1B,EAAgC;AACxD,SAAK5B,WAAL,CAAiB4B,IAAjB,IAAyB,EAAzB;AACD,GAFD;;AAIA,SAAO7B,WAAP;AACD,CAvHD,EAFA;;AA2HA,eAAeA,WAAf","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\n\nvar EventHolder =\n/*#__PURE__*/\nfunction () {\n  function EventHolder() {\n    this._heldEvents = {};\n    this._currentEventKey = null;\n  }\n  /**\n   * Holds a given event for processing later.\n   *\n   * TODO: Annotate return type better. The structural type of the return here\n   *       is pretty obvious.\n   *\n   * @param {string} eventType - Name of the event to hold and later emit\n   * @param {...*} Arbitrary arguments to be passed to each registered listener\n   * @return {object} Token that can be used to release the held event\n   *\n   * @example\n   *\n   *   holder.holdEvent({someEvent: 'abc'});\n   *\n   *   holder.emitToHandler({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *     }\n   *   }); //logs 'abc'\n   *\n   */\n\n\n  var _proto = EventHolder.prototype;\n\n  _proto.holdEvent = function holdEvent(eventType) {\n    this._heldEvents[eventType] = this._heldEvents[eventType] || [];\n    var eventsOfType = this._heldEvents[eventType];\n    var key = {\n      eventType: eventType,\n      index: eventsOfType.length\n    };\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    eventsOfType.push(args);\n    return key;\n  }\n  /**\n   * Emits the held events of the specified type to the given listener.\n   *\n   * @param {?string} eventType - Optional name of the events to replay\n   * @param {function} listener - The listener to which to dispatch the event\n   * @param {?object} context - Optional context object to use when invoking\n   *   the listener\n   */\n  ;\n\n  _proto.emitToListener = function emitToListener(eventType, listener, context) {\n    var _this = this;\n\n    var eventsOfType = this._heldEvents[eventType];\n\n    if (!eventsOfType) {\n      return;\n    }\n\n    var origEventKey = this._currentEventKey;\n    eventsOfType.forEach(function (\n    /*?array*/\n    eventHeld,\n    /*number*/\n    index) {\n      if (!eventHeld) {\n        return;\n      }\n\n      _this._currentEventKey = {\n        eventType: eventType,\n        index: index\n      };\n      listener.apply(context, eventHeld);\n    });\n    this._currentEventKey = origEventKey;\n  }\n  /**\n   * Provides an API that can be called during an eventing cycle to release\n   * the last event that was invoked, so that it is no longer \"held\".\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   */\n  ;\n\n  _proto.releaseCurrentEvent = function releaseCurrentEvent() {\n    invariant(this._currentEventKey !== null, 'Not in an emitting cycle; there is no current event');\n    this._currentEventKey && this.releaseEvent(this._currentEventKey);\n  }\n  /**\n   * Releases the event corresponding to the handle that was returned when the\n   * event was first held.\n   *\n   * @param {object} token - The token returned from holdEvent\n   */\n  ;\n\n  _proto.releaseEvent = function releaseEvent(token) {\n    delete this._heldEvents[token.eventType][token.index];\n  }\n  /**\n   * Releases all events of a certain type.\n   *\n   * @param {string} type\n   */\n  ;\n\n  _proto.releaseEventType = function releaseEventType(type) {\n    this._heldEvents[type] = [];\n  };\n\n  return EventHolder;\n}();\n\nexport default EventHolder;"]},"metadata":{},"sourceType":"module"}