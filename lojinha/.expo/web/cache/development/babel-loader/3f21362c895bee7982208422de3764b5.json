{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar spawnAsync_1 = __importDefault(require(\"../spawnAsync\"));\n\nit(\"receives output from completed processes\", function _callee() {\n  var result;\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(spawnAsync_1.default('echo', ['hi']));\n\n        case 2:\n          result = _context.sent;\n          expect(typeof result.pid).toBe('number');\n          expect(result.stdout).toBe('hi\\n');\n          expect(result.stderr).toBe('');\n          expect(result.output[0]).toBe(result.stdout);\n          expect(result.output[1]).toBe(result.stderr);\n          expect(result.status).toBe(0);\n          expect(result.signal).toBe(null);\n\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n});\nit(\"throws errors when processes return non-zero exit codes\", function _callee2() {\n  var didThrow;\n  return _regeneratorRuntime.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          didThrow = false;\n          _context2.prev = 1;\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(spawnAsync_1.default('false'));\n\n        case 4:\n          _context2.next = 12;\n          break;\n\n        case 6:\n          _context2.prev = 6;\n          _context2.t0 = _context2[\"catch\"](1);\n          didThrow = true;\n          expect(typeof _context2.t0.pid).toBe('number');\n          expect(_context2.t0.status).toBe(1);\n          expect(_context2.t0.signal).toBe(null);\n\n        case 12:\n          expect(didThrow).toBe(true);\n\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[1, 6]], Promise);\n});\nit(\"returns when processes are killed with signals with non-zero exit codes\", function _callee3() {\n  var didThrow;\n  return _regeneratorRuntime.async(function _callee3$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          didThrow = false;\n          _context3.prev = 1;\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(spawnAsync_1.default(path_1.default.join(__dirname, 'signal-self.sh')));\n\n        case 4:\n          _context3.next = 12;\n          break;\n\n        case 6:\n          _context3.prev = 6;\n          _context3.t0 = _context3[\"catch\"](1);\n          didThrow = true;\n          expect(typeof _context3.t0.pid).toBe('number');\n          expect(_context3.t0.status).toBe(null);\n          expect(_context3.t0.signal).toBe('SIGKILL');\n\n        case 12:\n          expect(didThrow).toBe(true);\n\n        case 13:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[1, 6]], Promise);\n});\nit(\"throws errors when processes don't exist\", function _callee4() {\n  var didThrow;\n  return _regeneratorRuntime.async(function _callee4$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          didThrow = false;\n          _context4.prev = 1;\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(spawnAsync_1.default('nonexistent-program'));\n\n        case 4:\n          _context4.next = 13;\n          break;\n\n        case 6:\n          _context4.prev = 6;\n          _context4.t0 = _context4[\"catch\"](1);\n          didThrow = true;\n          expect(_context4.t0.pid).not.toBeDefined();\n          expect(_context4.t0.code).toBe('ENOENT');\n          expect(_context4.t0.status).toBe(null);\n          expect(_context4.t0.signal).toBe(null);\n\n        case 13:\n          expect(didThrow).toBe(true);\n\n        case 14:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 6]], Promise);\n});\nit(\"exposes the child process through a property named \\\"child\\\"\", function _callee5() {\n  var spawnTask, childProcess, result;\n  return _regeneratorRuntime.async(function _callee5$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          spawnTask = spawnAsync_1.default('echo', ['hi']);\n          childProcess = spawnTask.child;\n          expect(childProcess).toBeDefined();\n          _context5.next = 5;\n          return _regeneratorRuntime.awrap(spawnTask);\n\n        case 5:\n          result = _context5.sent;\n          expect(result.pid).toBe(childProcess.pid);\n\n        case 7:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n});\nit(\"runs extra listeners added to the child process\", function _callee6() {\n  var spawnTask, mockExitListener, mockCloseListener;\n  return _regeneratorRuntime.async(function _callee6$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          spawnTask = spawnAsync_1.default('echo', ['hi']);\n          mockExitListener = jest.fn();\n          mockCloseListener = jest.fn();\n          spawnTask.child.on('exit', mockExitListener);\n          spawnTask.child.on('close', mockCloseListener);\n          _context6.next = 7;\n          return _regeneratorRuntime.awrap(spawnTask);\n\n        case 7:\n          expect(mockExitListener).toHaveBeenCalledTimes(1);\n          expect(mockCloseListener).toHaveBeenCalledTimes(1);\n\n        case 9:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n});\nit(\"runs extra error listeners added to the child process when there is an error\", function _callee7() {\n  var spawnTask, mockErrorListener;\n  return _regeneratorRuntime.async(function _callee7$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          spawnTask = spawnAsync_1.default('nonexistent-program');\n          mockErrorListener = jest.fn();\n          spawnTask.child.on('error', mockErrorListener);\n          _context7.next = 5;\n          return _regeneratorRuntime.awrap(expect(spawnTask).rejects.toThrowError());\n\n        case 5:\n          expect(mockErrorListener).toHaveBeenCalledTimes(1);\n\n        case 6:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n});\nit(\"returns empty strings when ignoring stdio\", function _callee8() {\n  var result;\n  return _regeneratorRuntime.async(function _callee8$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.next = 2;\n          return _regeneratorRuntime.awrap(spawnAsync_1.default('echo', ['hi'], {\n            ignoreStdio: true\n          }));\n\n        case 2:\n          result = _context8.sent;\n          expect(typeof result.pid).toBe('number');\n          expect(result.stdout).toBe('');\n          expect(result.stderr).toBe('');\n          expect(result.output[0]).toBe(result.stdout);\n          expect(result.output[1]).toBe(result.stderr);\n          expect(result.status).toBe(0);\n          expect(result.signal).toBe(null);\n\n        case 10:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n});\nit(\"returns even if stdout is open when ignoring stdio\", function _callee9() {\n  var sourceTask, sinkTask;\n  return _regeneratorRuntime.async(function _callee9$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          sourceTask = spawnAsync_1.default('yes', [], {\n            ignoreStdio: true\n          });\n          expect(sourceTask.child.listenerCount('exit')).toBe(1);\n          expect(sourceTask.child.listenerCount('close')).toBe(0);\n          sinkTask = spawnAsync_1.default('cat');\n          sourceTask.child.stdout.pipe(sinkTask.child.stdin);\n          sinkTask.child.stdin.cork();\n          _context9.next = 8;\n          return _regeneratorRuntime.awrap(new Promise(function (resolve) {\n            return setTimeout(resolve, 5);\n          }));\n\n        case 8:\n          sourceTask.child.kill();\n          _context9.next = 11;\n          return _regeneratorRuntime.awrap(expect(sourceTask).rejects.toThrowError());\n\n        case 11:\n          sinkTask.child.stdin.destroy();\n          _context9.next = 14;\n          return _regeneratorRuntime.awrap(expect(sinkTask).resolves.toMatchObject({\n            status: 0,\n            stdout: '',\n            stderr: ''\n          }));\n\n        case 14:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n});\nit('throws errors with preserved stack traces when processes return non-zero exit codes', function _callee10() {\n  return _regeneratorRuntime.async(function _callee10$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          expect.assertions(2);\n          _context10.prev = 1;\n          _context10.next = 4;\n          return _regeneratorRuntime.awrap(spawnAsync_1.default('false'));\n\n        case 4:\n          _context10.next = 10;\n          break;\n\n        case 6:\n          _context10.prev = 6;\n          _context10.t0 = _context10[\"catch\"](1);\n          expect(_context10.t0.stack).toMatch(/\\n    \\.\\.\\.\\n/);\n          expect(_context10.t0.stack).toMatch(/at Object\\.spawnAsync/);\n\n        case 10:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, [[1, 6]], Promise);\n});","map":{"version":3,"sources":["../../src/__tests__/spawnAsync-test.ts"],"names":[],"mappings":"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","sourcesContent":["import path from 'path';\n\nimport spawnAsync from '../spawnAsync';\n\nit(`receives output from completed processes`, async () => {\n  let result = await spawnAsync('echo', ['hi']);\n  expect(typeof result.pid).toBe('number');\n  expect(result.stdout).toBe('hi\\n');\n  expect(result.stderr).toBe('');\n\n  expect(result.output[0]).toBe(result.stdout);\n  expect(result.output[1]).toBe(result.stderr);\n\n  expect(result.status).toBe(0);\n  expect(result.signal).toBe(null);\n});\n\nit(`throws errors when processes return non-zero exit codes`, async () => {\n  let didThrow = false;\n  try {\n    await spawnAsync('false');\n  } catch (e) {\n    didThrow = true;\n    expect(typeof e.pid).toBe('number');\n    expect(e.status).toBe(1);\n    expect(e.signal).toBe(null);\n  }\n  expect(didThrow).toBe(true);\n});\n\nit(`returns when processes are killed with signals with non-zero exit codes`, async () => {\n  let didThrow = false;\n  try {\n    await spawnAsync(path.join(__dirname, 'signal-self.sh'));\n  } catch (e) {\n    didThrow = true;\n    expect(typeof e.pid).toBe('number');\n    expect(e.status).toBe(null);\n    expect(e.signal).toBe('SIGKILL');\n  }\n  expect(didThrow).toBe(true);\n});\n\nit(`throws errors when processes don't exist`, async () => {\n  let didThrow = false;\n  try {\n    await spawnAsync('nonexistent-program');\n  } catch (e) {\n    didThrow = true;\n    expect(e.pid).not.toBeDefined();\n    expect(e.code).toBe('ENOENT');\n    expect(e.status).toBe(null);\n    expect(e.signal).toBe(null);\n  }\n  expect(didThrow).toBe(true);\n});\n\nit(`exposes the child process through a property named \"child\"`, async () => {\n  let spawnTask = spawnAsync('echo', ['hi']);\n  let childProcess = spawnTask.child;\n  expect(childProcess).toBeDefined();\n\n  let result = await spawnTask;\n  expect(result.pid).toBe(childProcess.pid);\n});\n\nit(`runs extra listeners added to the child process`, async () => {\n  let spawnTask = spawnAsync('echo', ['hi']);\n  let mockExitListener = jest.fn();\n  let mockCloseListener = jest.fn();\n  spawnTask.child.on('exit', mockExitListener);\n  spawnTask.child.on('close', mockCloseListener);\n\n  await spawnTask;\n  expect(mockExitListener).toHaveBeenCalledTimes(1);\n  expect(mockCloseListener).toHaveBeenCalledTimes(1);\n});\n\nit(`runs extra error listeners added to the child process when there is an error`, async () => {\n  let spawnTask = spawnAsync('nonexistent-program');\n  let mockErrorListener = jest.fn();\n  spawnTask.child.on('error', mockErrorListener);\n\n  await expect(spawnTask).rejects.toThrowError();\n  expect(mockErrorListener).toHaveBeenCalledTimes(1);\n});\n\nit(`returns empty strings when ignoring stdio`, async () => {\n  let result = await spawnAsync('echo', ['hi'], { ignoreStdio: true });\n  expect(typeof result.pid).toBe('number');\n  expect(result.stdout).toBe('');\n  expect(result.stderr).toBe('');\n\n  expect(result.output[0]).toBe(result.stdout);\n  expect(result.output[1]).toBe(result.stderr);\n\n  expect(result.status).toBe(0);\n  expect(result.signal).toBe(null);\n});\n\nit(`returns even if stdout is open when ignoring stdio`, async () => {\n  // Without ignoring stdio, the promise will never resolve as stdout remains open indefinitely\n  let sourceTask = spawnAsync('yes', [], { ignoreStdio: true });\n  expect(sourceTask.child.listenerCount('exit')).toBe(1);\n  expect(sourceTask.child.listenerCount('close')).toBe(0);\n\n  // Create a sink that keeps the source's stdout open even after the source process exits\n  let sinkTask = spawnAsync('cat');\n  sourceTask.child.stdout.pipe(sinkTask.child.stdin);\n  sinkTask.child.stdin.cork();\n\n  // Allow the source's stdout to buffer with a short delay\n  await new Promise(resolve => setTimeout(resolve, 5));\n\n  // The source's stdout stays open even after killing the process\n  sourceTask.child.kill();\n  await expect(sourceTask).rejects.toThrowError();\n\n  // Destroy the sink's stdin stream to let the process exit\n  sinkTask.child.stdin.destroy();\n  await expect(sinkTask).resolves.toMatchObject({ status: 0, stdout: '', stderr: '' });\n});\n\nit('throws errors with preserved stack traces when processes return non-zero exit codes', async () => {\n  expect.assertions(2);\n  try {\n    await spawnAsync('false');\n  } catch (e) {\n    expect(e.stack).toMatch(/\\n    \\.\\.\\.\\n/);\n    expect(e.stack).toMatch(/at Object\\.spawnAsync/);\n  }\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}