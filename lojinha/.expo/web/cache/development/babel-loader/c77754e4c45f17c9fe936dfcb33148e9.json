{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeXmlFileOrRemoveFileUponNoResources = exports.xmlElementsEqual = exports.writeXmlFile = exports.readXmlFile = exports.mergeXmlElements = void 0;\n\nvar deep_equal_1 = __importDefault(require(\"deep-equal\"));\n\nvar xml_js_1 = require(\"xml-js\");\n\nvar file_utils_1 = require(\"../utils/file-utils\");\n\nfunction isElementType(el) {\n  return el.name !== undefined;\n}\n\nfunction isElementsType(el) {\n  return !el.name && Boolean(el.elements);\n}\n\nfunction isCommentType(el) {\n  return el.comment !== undefined;\n}\n\nfunction isTextType(el) {\n  return el.text !== undefined;\n}\n\nfunction isExplicitNewValue(el) {\n  return typeof el === 'object' && el.hasOwnProperty('newValue');\n}\n\nfunction unboxExplicitNewValue(el) {\n  return isExplicitNewValue(el) ? el.newValue : el;\n}\n\nfunction compareElements(element, expectedElement) {\n  var _a;\n\n  if (isTextType(expectedElement)) {\n    return element.type === 'text';\n  }\n\n  if (isCommentType(expectedElement)) {\n    return element.type === 'comment' && ((_a = element.comment) === null || _a === void 0 ? void 0 : _a.trim()) === expectedElement.comment.trim();\n  }\n\n  if (isElementType(expectedElement) && element.type === 'element') {\n    if (expectedElement.name !== element.name) {\n      return false;\n    }\n\n    if (!element.attributes) {\n      return true;\n    }\n\n    for (var _i = 0, _Object$entries = Object.entries(expectedElement.attributes || {}); _i < _Object$entries.length; _i++) {\n      var _ref = _Object$entries[_i];\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var key = _ref2[0];\n      var value = _ref2[1];\n\n      if (isExplicitNewValue(value)) {\n        continue;\n      }\n\n      if (element.attributes[key] !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction sortWithExplicitIndex(elements) {\n  if (!elements) {\n    return;\n  }\n\n  var result = new Array(elements.length);\n  var elementsWithExplicitIndices = elements.filter(function (_ref3) {\n    var idx = _ref3.idx;\n    return idx !== undefined;\n  });\n  var elementsWithoutExplicitIndices = elements.filter(function (_ref4) {\n    var idx = _ref4.idx;\n    return idx === undefined;\n  });\n  elementsWithoutExplicitIndices.forEach(function (el, idx) {\n    return result[idx] = el;\n  });\n  elementsWithExplicitIndices.forEach(function (_ref5, i) {\n    var idx = _ref5.idx,\n        el = _objectWithoutProperties(_ref5, [\"idx\"]);\n\n    result.splice(idx !== null && idx !== void 0 ? idx : i, 0, el);\n  });\n  return result;\n}\n\nfunction mergeXmlElementsLists(current, expected) {\n  if (isExplicitNewValue(expected) || !current) {\n    var sortedExpected = sortWithExplicitIndex(unboxExplicitNewValue(expected));\n    return sortedExpected === null || sortedExpected === void 0 ? void 0 : sortedExpected.map(convertToElement);\n  }\n\n  if (!expected) {\n    return current;\n  }\n\n  var result = [];\n\n  var _loop = function _loop(currentElement) {\n    var idxInExpected = expected.findIndex(function (el) {\n      return compareElements(currentElement, el);\n    });\n\n    if (idxInExpected !== -1) {\n      var _expected$splice$ = expected.splice(idxInExpected, 1)[0],\n          idx = _expected$splice$.idx,\n          element = _objectWithoutProperties(_expected$splice$, [\"idx\"]);\n\n      if (!element.deletionFlag) {\n        result.push(_objectSpread({\n          idx: idx\n        }, mergeXmlElements(currentElement, element)));\n      }\n    } else {\n      result.push(currentElement);\n    }\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(current), _step; !(_step = _iterator()).done;) {\n    var currentElement = _step.value;\n\n    _loop(currentElement);\n  }\n\n  result.push.apply(result, _toConsumableArray(expected.filter(function (_ref6) {\n    var deletionFlag = _ref6.deletionFlag;\n    return !deletionFlag;\n  }).map(function (_ref7) {\n    var idx = _ref7.idx,\n        el = _objectWithoutProperties(_ref7, [\"idx\"]);\n\n    return _objectSpread({\n      idx: idx\n    }, convertToElement(el));\n  })));\n  var sortedResult = sortWithExplicitIndex(result);\n  return sortedResult;\n}\n\nfunction convertToElement(_ref8) {\n  var idx = _ref8.idx,\n      expectedElement = _objectWithoutProperties(_ref8, [\"idx\"]);\n\n  if (expectedElement.deletionFlag) {\n    throw new Error('Cannot convert ExpectedElement to Element when deletionFlag is set');\n  }\n\n  if (isCommentType(expectedElement)) {\n    return _objectSpread(_objectSpread({}, expectedElement), {}, {\n      type: 'comment'\n    });\n  }\n\n  if (isTextType(expectedElement)) {\n    return _objectSpread(_objectSpread({}, expectedElement), {}, {\n      type: 'text'\n    });\n  }\n\n  if (isElementsType(expectedElement)) {\n    return {\n      elements: unboxExplicitNewValue(expectedElement.elements).filter(function (_ref9) {\n        var deletionFlag = _ref9.deletionFlag;\n        return !deletionFlag;\n      }).map(convertToElement),\n      type: 'element'\n    };\n  }\n\n  var elements = expectedElement.elements,\n      attributes = expectedElement.attributes,\n      expectedRest = _objectWithoutProperties(expectedElement, [\"elements\", \"attributes\"]);\n\n  var result = _objectSpread(_objectSpread({}, expectedRest), {}, {\n    type: 'element'\n  });\n\n  if (attributes) {\n    result.attributes = convertExpectedAttributes(attributes);\n  }\n\n  if (elements) {\n    result.elements = unboxExplicitNewValue(elements).filter(function (_ref10) {\n      var deletionFlag = _ref10.deletionFlag;\n      return !deletionFlag;\n    }).map(convertToElement);\n  }\n\n  return result;\n}\n\nfunction convertExpectedAttributes(expectedAttributes) {\n  if (expectedAttributes) {\n    var result = Object.entries(expectedAttributes).reduce(function (acc, _ref11) {\n      var _ref12 = _slicedToArray(_ref11, 2),\n          key = _ref12[0],\n          value = _ref12[1];\n\n      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, unboxExplicitNewValue(value)));\n    }, {});\n    return result;\n  }\n\n  return undefined;\n}\n\nfunction mergeAndConvertToElement(_ref13, _ref14) {\n  var currentAttributes = _ref13.attributes,\n      currentRest = _objectWithoutProperties(_ref13, [\"attributes\"]);\n\n  var expectedAttributes = _ref14.attributes,\n      expectedRest = _objectWithoutProperties(_ref14, [\"attributes\"]);\n\n  var result = _objectSpread(_objectSpread({}, currentRest), expectedRest);\n\n  var attributes = (currentAttributes || expectedAttributes) && _objectSpread(_objectSpread({}, currentAttributes), convertExpectedAttributes(expectedAttributes));\n\n  if (attributes) {\n    result.attributes = attributes;\n  }\n\n  return result;\n}\n\nfunction mergeXmlElements(current, expected) {\n  if (isCommentType(expected)) {\n    return _objectSpread(_objectSpread(_objectSpread({}, current), expected), {}, {\n      type: 'comment'\n    });\n  }\n\n  if (isTextType(expected)) {\n    return _objectSpread(_objectSpread(_objectSpread({}, current), expected), {}, {\n      type: 'text'\n    });\n  }\n\n  if (isElementsType(expected)) {\n    var _result = _objectSpread(_objectSpread({}, current), {}, {\n      type: 'element'\n    });\n\n    var _elements = mergeXmlElementsLists(current.elements, expected.elements);\n\n    if (_elements) {\n      _result.elements = _elements;\n    }\n\n    return _result;\n  }\n\n  var currentElements = current.elements,\n      currentRest = _objectWithoutProperties(current, [\"elements\"]);\n\n  var expectedElements = expected.elements,\n      expectedRest = _objectWithoutProperties(expected, [\"elements\"]);\n\n  var elements = mergeXmlElementsLists(current.elements, expected.elements);\n\n  var result = _objectSpread(_objectSpread({}, mergeAndConvertToElement(currentRest, expectedRest)), {}, {\n    type: 'element'\n  });\n\n  if (elements) {\n    result.elements = elements;\n  }\n\n  return result;\n}\n\nexports.mergeXmlElements = mergeXmlElements;\n\nfunction readXmlFile(filePath) {\n  var fallbackContent,\n      fileContent,\n      fileXml,\n      _args = arguments;\n  return _regeneratorRuntime.async(function readXmlFile$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          fallbackContent = _args.length > 1 && _args[1] !== undefined ? _args[1] : \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\";\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(file_utils_1.readFileWithFallback(filePath, typeof fallbackContent === 'string' ? fallbackContent : 'fallbackToElement'));\n\n        case 3:\n          fileContent = _context.sent;\n\n          if (!(fileContent === 'fallbackToElement' && typeof fallbackContent === 'object')) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\", fallbackContent);\n\n        case 6:\n          fileXml = xml_js_1.xml2js(fileContent);\n          return _context.abrupt(\"return\", fileXml);\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.readXmlFile = readXmlFile;\n\nfunction writeXmlFile(filePath, xml) {\n  var fileXml, correctedFile;\n  return _regeneratorRuntime.async(function writeXmlFile$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          fileXml = xml_js_1.js2xml(xml, {\n            indentAttributes: true,\n            spaces: 2\n          });\n          correctedFile = fileXml.replace(/(?<openTag><[^\\s]+)\\n *(?<firstAttribute> [^\\s]+=\".+?\")\\n *((?<secondAttribute> [^\\s]+=\".+?\")\\n *)?(?<closeTag>[/?]?>)/g, '$1$2$4$5');\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(file_utils_1.createDirAndWriteFile(filePath, correctedFile + \"\\n\"));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.writeXmlFile = writeXmlFile;\n\nfunction xmlElementsEqual(a, b) {\n  var _ref15 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref15$disregardComme = _ref15.disregardComments,\n      disregardComments = _ref15$disregardComme === void 0 ? true : _ref15$disregardComme;\n\n  var filteredA = !disregardComments ? a : removeComments(a);\n  var filteredB = !disregardComments ? b : removeComments(b);\n  return deep_equal_1.default(filteredA, filteredB);\n}\n\nexports.xmlElementsEqual = xmlElementsEqual;\n\nfunction removeComments(e) {\n  if (e.type === 'comment') {\n    return;\n  }\n\n  var result = Object.entries(e).map(function (_ref16) {\n    var _ref17 = _slicedToArray(_ref16, 2),\n        key = _ref17[0],\n        value = _ref17[1];\n\n    if (key === 'elements' && Array.isArray(value)) {\n      var filteredValue = value.map(removeComments).filter(function (el) {\n        return el !== undefined;\n      });\n      return [key, filteredValue.length > 0 ? filteredValue : undefined];\n    }\n\n    return [key, value];\n  }).filter(function (_ref18) {\n    var _ref19 = _slicedToArray(_ref18, 2),\n        _ = _ref19[0],\n        value = _ref19[1];\n\n    return value !== undefined;\n  }).reduce(function (acc, _ref20) {\n    var _ref21 = _slicedToArray(_ref20, 2),\n        key = _ref21[0],\n        value = _ref21[1];\n\n    acc[key] = value;\n    return acc;\n  }, {});\n  return result;\n}\n\nfunction writeXmlFileOrRemoveFileUponNoResources(filePath, element) {\n  var _ref22,\n      disregardComments,\n      _a,\n      _b,\n      _args3 = arguments;\n\n  return _regeneratorRuntime.async(function writeXmlFileOrRemoveFileUponNoResources$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _ref22 = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {}, disregardComments = _ref22.disregardComments;\n\n          if (!(((_a = element.elements) === null || _a === void 0 ? void 0 : _a[0].name) === 'resources' && ((_b = element.elements[0].elements) === null || _b === void 0 ? void 0 : _b.filter(function (_ref23) {\n            var type = _ref23.type;\n            return disregardComments ? type !== 'comment' : true;\n          }).length) === 0)) {\n            _context3.next = 6;\n            break;\n          }\n\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(file_utils_1.removeFileIfExists(filePath));\n\n        case 4:\n          _context3.next = 8;\n          break;\n\n        case 6:\n          _context3.next = 8;\n          return _regeneratorRuntime.awrap(writeXmlFile(filePath, element));\n\n        case 8:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.writeXmlFileOrRemoveFileUponNoResources = writeXmlFileOrRemoveFileUponNoResources;","map":{"version":3,"sources":["../../src/xml-manipulation/index.ts"],"names":[],"mappings":"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","sourcesContent":["import deepEqual from 'deep-equal';\nimport { Element, js2xml, xml2js, Attributes } from 'xml-js';\n\nimport {\n  readFileWithFallback,\n  createDirAndWriteFile,\n  removeFileIfExists,\n} from '../utils/file-utils';\n\ntype ExplicitNewValue<T> = { newValue: T };\ntype WithExplicitNewValue<T> = T | ExplicitNewValue<T>;\n\ntype ExpectedElementAttributes = Record<string, WithExplicitNewValue<string | number | undefined>>;\ntype WithExplicitIndex<T> = T & { idx?: number };\ntype WithDeletionFlag<T> = T & { deletionFlag?: boolean };\n\ntype ExpectedElements = WithExplicitNewValue<\n  WithExplicitIndex<WithDeletionFlag<ExpectedElement>>[]\n>;\n\nexport type ExpectedElementType = {\n  name: string;\n  attributes?: ExpectedElementAttributes;\n  elements?: ExpectedElements;\n};\n\nexport type ExpectedElementsType = {\n  elements: ExpectedElements;\n};\n\nexport type ExpectedCommentType = {\n  comment: string;\n};\n\nexport type ExpectedTextType = {\n  text: string | number | boolean;\n};\n\nexport type ExpectedElement =\n  | ExpectedElementType\n  | ExpectedElementsType\n  | ExpectedCommentType\n  | ExpectedTextType;\n\nfunction isElementType(el: ExpectedElement): el is ExpectedElementType {\n  return (el as ExpectedElementType).name !== undefined;\n}\n\nfunction isElementsType(el: ExpectedElement): el is ExpectedElementsType {\n  return !(el as ExpectedElementType).name && Boolean((el as ExpectedElementsType).elements);\n}\n\nfunction isCommentType(el: ExpectedElement): el is ExpectedCommentType {\n  return (el as ExpectedCommentType).comment !== undefined;\n}\n\nfunction isTextType(el: ExpectedElement): el is ExpectedTextType {\n  return (el as ExpectedTextType).text !== undefined;\n}\n\nfunction isExplicitNewValue<T>(el: WithExplicitNewValue<T>): el is ExplicitNewValue<T> {\n  // @ts-ignore\n  return typeof el === 'object' && el.hasOwnProperty('newValue');\n}\n\nfunction unboxExplicitNewValue<T>(el: WithExplicitNewValue<T>): T {\n  return isExplicitNewValue(el) ? el.newValue : el;\n}\n\nfunction compareElements(element: Element, expectedElement: ExpectedElement): boolean {\n  if (isTextType(expectedElement)) {\n    return element.type === 'text';\n  }\n\n  if (isCommentType(expectedElement)) {\n    return element.type === 'comment' && element.comment?.trim() === expectedElement.comment.trim();\n  }\n\n  if (isElementType(expectedElement) && element.type === 'element') {\n    if (expectedElement.name !== element.name) {\n      return false;\n    }\n\n    if (!element.attributes) {\n      return true;\n    }\n\n    for (const [key, value] of Object.entries(\n      (expectedElement as ExpectedElementType).attributes || {}\n    )) {\n      if (isExplicitNewValue(value)) {\n        // this attribute has to be overridden\n        continue;\n      }\n      if (element.attributes[key] !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction sortWithExplicitIndex<T>(elements?: WithExplicitIndex<T>[]): T[] | undefined {\n  if (!elements) {\n    return;\n  }\n  const result: T[] = new Array(elements.length);\n  const elementsWithExplicitIndices = elements.filter(({ idx }) => idx !== undefined);\n  const elementsWithoutExplicitIndices = elements.filter(({ idx }) => idx === undefined);\n  elementsWithoutExplicitIndices.forEach((el, idx) => (result[idx] = el));\n  elementsWithExplicitIndices.forEach(({ idx, ...el }, i) => {\n    // @ts-ignore\n    result.splice(idx ?? i, 0, el);\n  });\n  return result;\n}\n\nfunction mergeXmlElementsLists(\n  current?: Element[],\n  expected?: ExpectedElements\n): Element[] | undefined {\n  if (isExplicitNewValue(expected) || !current) {\n    const sortedExpected = sortWithExplicitIndex(unboxExplicitNewValue(expected));\n    return sortedExpected?.map(convertToElement);\n  }\n  if (!expected) {\n    return current;\n  }\n\n  const result: WithExplicitIndex<WithDeletionFlag<Element>>[] = [];\n\n  for (const currentElement of current) {\n    const idxInExpected = expected.findIndex(el => compareElements(currentElement, el));\n    if (idxInExpected !== -1) {\n      const { idx, ...element } = expected.splice(idxInExpected, 1)[0];\n      if (!element.deletionFlag) {\n        result.push({ idx, ...mergeXmlElements(currentElement, element) });\n      }\n    } else {\n      result.push(currentElement);\n    }\n  }\n  result.push(\n    ...expected\n      .filter(({ deletionFlag }) => !deletionFlag)\n      .map(({ idx, ...el }) => ({ idx, ...convertToElement(el) }))\n  );\n  const sortedResult = sortWithExplicitIndex(result);\n  return sortedResult;\n}\n\nfunction convertToElement({\n  idx,\n  ...expectedElement\n}: WithExplicitIndex<ExpectedElement>): Element {\n  // @ts-ignore\n  if (expectedElement.deletionFlag) {\n    throw new Error('Cannot convert ExpectedElement to Element when deletionFlag is set');\n  }\n\n  if (isCommentType(expectedElement)) {\n    return {\n      ...expectedElement,\n      type: 'comment',\n    };\n  }\n  if (isTextType(expectedElement)) {\n    return {\n      ...expectedElement,\n      type: 'text',\n    };\n  }\n  if (isElementsType(expectedElement)) {\n    return {\n      elements: unboxExplicitNewValue(expectedElement.elements)\n        .filter(({ deletionFlag }) => !deletionFlag)\n        .map(convertToElement),\n      type: 'element',\n    };\n  }\n  const { elements, attributes, ...expectedRest } = expectedElement;\n  const result: Element = {\n    ...expectedRest,\n    type: 'element',\n  };\n  if (attributes) {\n    result.attributes = convertExpectedAttributes(attributes);\n  }\n  if (elements) {\n    result.elements = unboxExplicitNewValue(elements)\n      .filter(({ deletionFlag }) => !deletionFlag)\n      .map(convertToElement);\n  }\n  return result;\n}\n\nfunction convertExpectedAttributes(\n  expectedAttributes?: ExpectedElementAttributes\n): Attributes | undefined {\n  if (expectedAttributes) {\n    const result = Object.entries(expectedAttributes).reduce(\n      (acc, [key, value]) => ({\n        ...acc,\n        [key]: unboxExplicitNewValue(value),\n      }),\n      {}\n    );\n    return result;\n  }\n  return undefined;\n}\n\nfunction mergeAndConvertToElement(\n  { attributes: currentAttributes, ...currentRest }: Omit<Element, 'elements'>,\n  { attributes: expectedAttributes, ...expectedRest }: Omit<ExpectedElementType, 'elements'>\n): Element {\n  const result: Element = {\n    ...currentRest,\n    ...expectedRest,\n  };\n  const attributes = (currentAttributes || expectedAttributes) && {\n    ...currentAttributes,\n    ...convertExpectedAttributes(expectedAttributes),\n  };\n  if (attributes) {\n    result.attributes = attributes;\n  }\n  return result;\n}\n\n/**\n * Assumption is that elements are `equal` semantically\n */\nexport function mergeXmlElements(current: Element, expected: ExpectedElement): Element {\n  if (isCommentType(expected)) {\n    return {\n      ...current,\n      ...expected,\n      type: 'comment',\n    };\n  }\n\n  if (isTextType(expected)) {\n    return {\n      ...current,\n      ...expected,\n      type: 'text',\n    };\n  }\n\n  if (isElementsType(expected)) {\n    const result = {\n      ...current,\n      type: 'element',\n    };\n    const elements = mergeXmlElementsLists(current.elements, expected.elements);\n    if (elements) {\n      result.elements = elements;\n    }\n    return result;\n  }\n\n  const { elements: currentElements, ...currentRest } = current;\n  const { elements: expectedElements, ...expectedRest } = expected;\n\n  const elements = mergeXmlElementsLists(current.elements, expected.elements);\n  const result = {\n    ...mergeAndConvertToElement(currentRest, expectedRest),\n    type: 'element',\n  };\n  if (elements) {\n    result.elements = elements;\n  }\n  return result;\n}\n\n/**\n * @param filePath\n * @param fallbackContent\n */\nexport async function readXmlFile(\n  filePath: string,\n  fallbackContent: Element | string = `<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n): Promise<Element> {\n  const fileContent = await readFileWithFallback(\n    filePath,\n    typeof fallbackContent === 'string' ? fallbackContent : 'fallbackToElement'\n  );\n  if (fileContent === 'fallbackToElement' && typeof fallbackContent === 'object') {\n    return fallbackContent;\n  }\n  const fileXml = xml2js(fileContent);\n  return fileXml as Element;\n}\n\nexport async function writeXmlFile(filePath: string, xml: Element) {\n  const fileXml = js2xml(xml, { indentAttributes: true, spaces: 2 });\n  const correctedFile = fileXml.replace(\n    /(?<openTag><[^\\s]+)\\n *(?<firstAttribute> [^\\s]+=\".+?\")\\n *((?<secondAttribute> [^\\s]+=\".+?\")\\n *)?(?<closeTag>[/?]?>)/g,\n    '$1$2$4$5'\n  );\n  await createDirAndWriteFile(filePath, `${correctedFile}\\n`);\n}\n\n/**\n * Checks whether two xmlElements are equal in terms of their structure\n */\nexport function xmlElementsEqual(\n  a: Element,\n  b: Element,\n  { disregardComments = true }: { disregardComments?: boolean } = {}\n): boolean {\n  const filteredA = !disregardComments ? a : removeComments(a);\n  const filteredB = !disregardComments ? b : removeComments(b);\n  return deepEqual(filteredA, filteredB);\n}\n\nfunction removeComments(e: Element): Element | undefined {\n  if (e.type === 'comment') {\n    return;\n  }\n  const result = Object.entries(e)\n    .map(([key, value]): [string, any] => {\n      if (key === 'elements' && Array.isArray(value)) {\n        const filteredValue = value\n          .map(removeComments)\n          .filter((el): el is Element => el !== undefined);\n        return [key, filteredValue.length > 0 ? filteredValue : undefined];\n      }\n      return [key, value];\n    })\n    .filter(([_, value]) => value !== undefined)\n    .reduce((acc, [key, value]) => {\n      // @ts-ignore\n      acc[key] = value;\n      return acc;\n    }, {});\n  return result;\n}\n\n/**\n * Check if given `element` has some meaningful data:\n * - if so: write it to the file\n * - if no: remove file completely\n * Function assumes that the structure of the input `element` is correct (`element.elements[name = resources]`).\n */\nexport async function writeXmlFileOrRemoveFileUponNoResources(\n  filePath: string,\n  element: Element,\n  { disregardComments }: { disregardComments?: boolean } = {}\n) {\n  if (\n    element.elements?.[0].name === 'resources' &&\n    element.elements[0].elements?.filter(({ type }) =>\n      disregardComments ? type !== 'comment' : true\n    ).length === 0\n  ) {\n    await removeFileIfExists(filePath);\n  } else {\n    await writeXmlFile(filePath, element);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}