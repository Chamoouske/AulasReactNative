{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { CodedError } from '@unimodules/core';\nvar GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nvar googleApiKey;\nexport function setGoogleApiKey(apiKey) {\n  googleApiKey = apiKey;\n}\nexport function googleGeocodeAsync(address) {\n  var result;\n  return _regeneratorRuntime.async(function googleGeocodeAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          assertGoogleApiKey();\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(requestGoogleApiAsync({\n            address: address\n          }));\n\n        case 3:\n          result = _context.sent;\n\n          if (!(result.status === 'ZERO_RESULTS')) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\", []);\n\n        case 6:\n          assertGeocodeResults(result);\n          return _context.abrupt(\"return\", result.results.map(geocodingResultToLocation));\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function googleReverseGeocodeAsync(options) {\n  var result;\n  return _regeneratorRuntime.async(function googleReverseGeocodeAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          assertGoogleApiKey();\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(requestGoogleApiAsync({\n            latlng: options.latitude + \",\" + options.longitude\n          }));\n\n        case 3:\n          result = _context2.sent;\n\n          if (!(result.status === 'ZERO_RESULTS')) {\n            _context2.next = 6;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", []);\n\n        case 6:\n          assertGeocodeResults(result);\n          return _context2.abrupt(\"return\", result.results.map(reverseGeocodingResultToAddress));\n\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction assertGeocodeResults(resultObject) {\n  var status = resultObject.status,\n      error_message = resultObject.error_message;\n\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(status, 'the request could not be processed due to a server error. The request may succeed if you try again.');\n    }\n\n    throw new CodedError(status, \"An error occurred during geocoding.\");\n  }\n}\n\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error('Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.');\n  }\n}\n\nfunction requestGoogleApiAsync(params) {\n  var query, result;\n  return _regeneratorRuntime.async(function requestGoogleApiAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          query = Object.entries(params).map(function (entry) {\n            return entry[0] + \"=\" + encodeURI(entry[1]);\n          }).join('&');\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(fetch(GOOGLE_API_URL + \"?key=\" + googleApiKey + \"&\" + query));\n\n        case 3:\n          result = _context3.sent;\n          _context3.next = 6;\n          return _regeneratorRuntime.awrap(result.json());\n\n        case 6:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 7:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction geocodingResultToLocation(result) {\n  var location = result.geometry.location;\n  return {\n    latitude: location.lat,\n    longitude: location.lng\n  };\n}\n\nfunction reverseGeocodingResultToAddress(result) {\n  var address = {};\n\n  for (var _iterator = _createForOfIteratorHelperLoose(result.address_components), _step; !(_step = _iterator()).done;) {\n    var _ref = _step.value;\n    var long_name = _ref.long_name;\n    var short_name = _ref.short_name;\n    var types = _ref.types;\n\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n\n  return address;\n}","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/expo-location/src/LocationGoogleGeocoding.ts"],"names":["CodedError","GOOGLE_API_URL","googleApiKey","setGoogleApiKey","apiKey","googleGeocodeAsync","address","assertGoogleApiKey","requestGoogleApiAsync","result","status","assertGeocodeResults","results","map","geocodingResultToLocation","googleReverseGeocodeAsync","options","latlng","latitude","longitude","reverseGeocodingResultToAddress","resultObject","error_message","Error","params","query","Object","entries","entry","encodeURI","join","fetch","json","location","geometry","lat","lng","address_components","long_name","short_name","types","includes","city","district","street","region","subregion","country","isoCountryCode","postalCode","name","formatted_address","replace"],"mappings":"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","sourcesContent":["import { CodedError } from '@unimodules/core';\n\nimport { LocationGeocodedAddress, LocationGeocodedLocation } from './Location.types';\n\nconst GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nlet googleApiKey;\n\ntype GoogleApiGeocodingAddressComponent = {\n  long_name: string;\n  short_name: string;\n  types: string[];\n};\n\ntype GoogleApiGeocodingResult = {\n  address_components: GoogleApiGeocodingAddressComponent[];\n  formatted_address: string;\n  geometry: {\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n};\n\ntype GoogleApiGeocodingResponse = {\n  results: GoogleApiGeocodingResult[];\n  status: string;\n};\n\nexport function setGoogleApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nexport async function googleGeocodeAsync(address: string): Promise<LocationGeocodedLocation[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({ address });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(geocodingResultToLocation);\n}\n\nexport async function googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<LocationGeocodedAddress[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({\n    latlng: `${options.latitude},${options.longitude}`,\n  });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(reverseGeocodingResultToAddress);\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n/**\n * Makes sure the Google API key is set.\n */\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error(\n      'Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.'\n    );\n  }\n}\n\n/**\n * Generic and handy method for sending requests to Google Maps API endpoint.\n */\nasync function requestGoogleApiAsync(\n  params: { address: string } | { latlng: string }\n): Promise<GoogleApiGeocodingResponse> {\n  const query = Object.entries(params)\n    .map(entry => `${entry[0]}=${encodeURI(entry[1])}`)\n    .join('&');\n  const result = await fetch(`${GOOGLE_API_URL}?key=${googleApiKey}&${query}`);\n  return await result.json();\n}\n\n/**\n * Converts Google's result to the location object.\n */\nfunction geocodingResultToLocation(result: GoogleApiGeocodingResult): LocationGeocodedLocation {\n  const { location } = result.geometry;\n  return {\n    latitude: location.lat,\n    longitude: location.lng,\n  };\n}\n\n/**\n * Converts Google's result to address object.\n */\nfunction reverseGeocodingResultToAddress(\n  result: GoogleApiGeocodingResult\n): LocationGeocodedAddress {\n  const address: Partial<LocationGeocodedAddress> = {};\n\n  for (const { long_name, short_name, types } of result.address_components) {\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address as LocationGeocodedAddress;\n}\n"]},"metadata":{},"sourceType":"module"}