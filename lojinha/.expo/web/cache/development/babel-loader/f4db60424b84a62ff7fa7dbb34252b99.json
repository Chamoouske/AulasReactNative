{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar resolve_from_1 = __importDefault(require(\"resolve-from\"));\n\nvar Config_1 = require(\"../Config\");\n\nvar extensions_1 = require(\"./extensions\");\n\nfunction ensureSlash(inputPath, needsSlash) {\n  var hasSlash = inputPath.endsWith('/');\n\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  } else if (!hasSlash && needsSlash) {\n    return inputPath + \"/\";\n  } else {\n    return inputPath;\n  }\n}\n\nexports.ensureSlash = ensureSlash;\n\nfunction getPossibleProjectRoot() {\n  return fs_extra_1.default.realpathSync(process.cwd());\n}\n\nexports.getPossibleProjectRoot = getPossibleProjectRoot;\n\nfunction getEntryPoint(projectRoot, entryFiles, platforms, projectConfig) {\n  var extensions = extensions_1.getManagedExtensions(platforms);\n  return getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig);\n}\n\nexports.getEntryPoint = getEntryPoint;\n\nfunction getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig) {\n  var _ref = projectConfig !== null && projectConfig !== void 0 ? projectConfig : Config_1.getConfig(projectRoot, {\n    skipSDKVersionRequirement: true\n  }),\n      exp = _ref.exp,\n      pkg = _ref.pkg;\n\n  if (exp && exp.entryPoint && typeof exp.entryPoint === 'string') {\n    var entry = getFileWithExtensions(projectRoot, exp.entryPoint, extensions);\n\n    if (!entry) {\n      entry = resolveFromSilentWithExtensions(projectRoot, exp.entryPoint, extensions);\n\n      if (!entry) {\n        return exp.entryPoint;\n      }\n    }\n\n    return entry;\n  } else if (pkg) {\n    var main = pkg.main;\n\n    if (main && typeof main === 'string') {\n      var _entry = getFileWithExtensions(projectRoot, main, extensions);\n\n      if (!_entry) {\n        _entry = resolveFromSilentWithExtensions(projectRoot, main, extensions);\n        if (!_entry) throw new Error(\"Cannot resolve entry file: The `main` field defined in your `package.json` points to a non-existent path.\");\n      }\n\n      return _entry;\n    }\n  }\n\n  for (var _iterator = _createForOfIteratorHelperLoose(entryFiles), _step; !(_step = _iterator()).done;) {\n    var fileName = _step.value;\n\n    var _entry2 = resolveFromSilentWithExtensions(projectRoot, fileName, extensions);\n\n    if (_entry2) return _entry2;\n  }\n\n  try {\n    return resolve_from_1.default(projectRoot, 'expo/AppEntry');\n  } catch (_a) {\n    throw new Error(\"The project entry file could not be resolved. Please either define it in the `package.json` (main), `app.json` (expo.entryPoint), create an `index.js`, or install the `expo` package.\");\n  }\n}\n\nexports.getEntryPointWithExtensions = getEntryPointWithExtensions;\n\nfunction resolveFromSilentWithExtensions(fromDirectory, moduleId, extensions) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(extensions), _step2; !(_step2 = _iterator2()).done;) {\n    var extension = _step2.value;\n    var modulePath = resolve_from_1.default.silent(fromDirectory, moduleId + \".\" + extension);\n\n    if (modulePath && modulePath.endsWith(extension)) {\n      return modulePath;\n    }\n  }\n\n  return resolve_from_1.default.silent(fromDirectory, moduleId) || null;\n}\n\nexports.resolveFromSilentWithExtensions = resolveFromSilentWithExtensions;\n\nfunction getFileWithExtensions(fromDirectory, moduleId, extensions) {\n  var modulePath = path_1.default.join(fromDirectory, moduleId);\n\n  if (fs_extra_1.default.existsSync(modulePath)) {\n    return modulePath;\n  }\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(extensions), _step3; !(_step3 = _iterator3()).done;) {\n    var extension = _step3.value;\n\n    var _modulePath = path_1.default.join(fromDirectory, moduleId + \".\" + extension);\n\n    if (fs_extra_1.default.existsSync(_modulePath)) {\n      return _modulePath;\n    }\n  }\n\n  return null;\n}\n\nexports.getFileWithExtensions = getFileWithExtensions;","map":{"version":3,"sources":["../../src/paths/paths.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { getConfig } from '../Config';\nimport { ProjectConfig } from '../Config.types';\nimport { getManagedExtensions } from './extensions';\n\n// https://github.com/facebook/create-react-app/blob/9750738cce89a967cc71f28390daf5d4311b193c/packages/react-scripts/config/paths.js#L22\nexport function ensureSlash(inputPath: string, needsSlash: boolean): string {\n  const hasSlash = inputPath.endsWith('/');\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  } else if (!hasSlash && needsSlash) {\n    return `${inputPath}/`;\n  } else {\n    return inputPath;\n  }\n}\n\nexport function getPossibleProjectRoot(): string {\n  return fs.realpathSync(process.cwd());\n}\n\nexport function getEntryPoint(\n  projectRoot: string,\n  entryFiles: string[],\n  platforms: string[],\n  projectConfig?: ProjectConfig\n): string | null {\n  const extensions = getManagedExtensions(platforms);\n  return getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig);\n}\n\n// Used to resolve the main entry file for a project.\nexport function getEntryPointWithExtensions(\n  projectRoot: string,\n  entryFiles: string[],\n  extensions: string[],\n  projectConfig?: ProjectConfig\n): string {\n  const { exp, pkg } = projectConfig ?? getConfig(projectRoot, { skipSDKVersionRequirement: true });\n\n  // This will first look in the `app.json`s `expo.entryPoint` field for a potential main file.\n  // We check the Expo config first in case you want your project to start differently with Expo then in a standalone environment.\n  if (exp && exp.entryPoint && typeof exp.entryPoint === 'string') {\n    // If the field exists then we want to test it against every one of the supplied extensions\n    // to ensure the bundler resolves the same way.\n    let entry = getFileWithExtensions(projectRoot, exp.entryPoint, extensions);\n    if (!entry) {\n      // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n      entry = resolveFromSilentWithExtensions(projectRoot, exp.entryPoint, extensions);\n\n      // If it doesn't resolve then just return the entryPoint as-is. This makes\n      // it possible for people who have an unconventional setup (eg: multiple\n      // apps in monorepo with metro at root) to customize entry point without\n      // us imposing our assumptions.\n      if (!entry) {\n        return exp.entryPoint;\n      }\n    }\n    return entry;\n  } else if (pkg) {\n    // If the config doesn't define a custom entry then we want to look at the `package.json`s `main` field, and try again.\n    const { main } = pkg;\n    if (main && typeof main === 'string') {\n      // Testing the main field against all of the provided extensions - for legacy reasons we can't use node module resolution as the package.json allows you to pass in a file without a relative path and expect it as a relative path.\n      let entry = getFileWithExtensions(projectRoot, main, extensions);\n      if (!entry) {\n        // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n        entry = resolveFromSilentWithExtensions(projectRoot, main, extensions);\n        if (!entry)\n          throw new Error(\n            `Cannot resolve entry file: The \\`main\\` field defined in your \\`package.json\\` points to a non-existent path.`\n          );\n      }\n      return entry;\n    }\n  }\n\n  // Now we will start looking for a default entry point using the provided `entryFiles` argument.\n  // This will add support for create-react-app (src/index.js) and react-native-cli (index.js) which don't define a main.\n  for (const fileName of entryFiles) {\n    const entry = resolveFromSilentWithExtensions(projectRoot, fileName, extensions);\n    if (entry) return entry;\n  }\n\n  try {\n    // If none of the default files exist then we will attempt to use the main Expo entry point.\n    // This requires `expo` to be installed in the project to work as it will use `node_module/expo/AppEntry.js`\n    // Doing this enables us to create a bare minimum Expo project.\n\n    // TODO(Bacon): We may want to do a check against `./App` and `expo` in the `package.json` `dependencies` as we can more accurately ensure that the project is expo-min without needing the modules installed.\n    return resolveFrom(projectRoot, 'expo/AppEntry');\n  } catch {\n    throw new Error(\n      `The project entry file could not be resolved. Please either define it in the \\`package.json\\` (main), \\`app.json\\` (expo.entryPoint), create an \\`index.js\\`, or install the \\`expo\\` package.`\n    );\n  }\n}\n\n// Resolve from but with the ability to resolve like a bundler\nexport function resolveFromSilentWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  for (const extension of extensions) {\n    const modulePath = resolveFrom.silent(fromDirectory, `${moduleId}.${extension}`);\n    if (modulePath && modulePath.endsWith(extension)) {\n      return modulePath;\n    }\n  }\n  return resolveFrom.silent(fromDirectory, moduleId) || null;\n}\n\n// Statically attempt to resolve a module but with the ability to resolve like a bundler.\n// This won't use node module resolution.\nexport function getFileWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  const modulePath = path.join(fromDirectory, moduleId);\n  if (fs.existsSync(modulePath)) {\n    return modulePath;\n  }\n  for (const extension of extensions) {\n    const modulePath = path.join(fromDirectory, `${moduleId}.${extension}`);\n    if (fs.existsSync(modulePath)) {\n      return modulePath;\n    }\n  }\n  return null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}