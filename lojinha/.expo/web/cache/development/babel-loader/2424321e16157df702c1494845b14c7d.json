{"ast":null,"code":"'use strict';\n\nvar _require = require(\"./Utils\"),\n    flatObjects = _require.flatObjects,\n    capitalizeFirstLetter = _require.capitalizeFirstLetter;\n\nvar structTemplate = \"\\nnamespace JS {\\n  namespace Native::_MODULE_NAME_:: {\\n    struct ::_STRUCT_NAME_:: {\\n\\n      struct Builder {\\n        struct Input {\\n          ::_INPUT_::\\n        };\\n\\n        /** Initialize with a set of values */\\n        Builder(const Input i);\\n        /** Initialize with an existing ::_STRUCT_NAME_:: */\\n        Builder(::_STRUCT_NAME_:: i);\\n        /** Builds the object. Generally used only by the infrastructure. */\\n        NSDictionary *buildUnsafeRawValue() const { return _factory(); };\\n      private:\\n        NSDictionary *(^_factory)(void);\\n      };\\n\\n      static ::_STRUCT_NAME_:: fromUnsafeRawValue(NSDictionary *const v) { return {v}; }\\n      NSDictionary *unsafeRawValue() const { return _v; }\\n    private:\\n      ::_STRUCT_NAME_::(NSDictionary *const v) : _v(v) {}\\n      NSDictionary *_v;\\n    };\\n  }\\n}\\n\\ninline JS::Native::_MODULE_NAME_::::::_STRUCT_NAME_::::Builder::Builder(const Input i) : _factory(^{\\n  NSMutableDictionary *d = [NSMutableDictionary new];\\n  ::_PROPERTIES_::\\n  return d;\\n}) {}\\ninline JS::Native::_MODULE_NAME_::::::_STRUCT_NAME_::::Builder::Builder(::_STRUCT_NAME_:: i) : _factory(^{\\n  return i.unsafeRawValue();\\n}) {}\";\n\nfunction getBuilderInputFieldDeclaration(property, name) {\n  function markRequiredIfNecessary(annotation) {\n    if (!property.optional) {\n      return 'RCTRequired<' + annotation + '> ' + property.name + ';';\n    }\n\n    return 'folly::Optional<' + annotation + '> ' + property.name + ';';\n  }\n\n  var typeAnnotation = property.typeAnnotation;\n\n  switch (typeAnnotation.type) {\n    case 'StringTypeAnnotation':\n      if (property.optional) {\n        return 'NSString *' + property.name + ';';\n      }\n\n      return markRequiredIfNecessary('NSString *');\n\n    case 'NumberTypeAnnotation':\n    case 'FloatTypeAnnotation':\n    case 'Int32TypeAnnotation':\n      return markRequiredIfNecessary('double');\n\n    case 'BooleanTypeAnnotation':\n      return markRequiredIfNecessary('bool');\n\n    case 'ObjectTypeAnnotation':\n      return markRequiredIfNecessary(\"JS::Native::_MODULE_NAME_::::Spec\" + name + capitalizeFirstLetter(property.name) + \"::Builder\");\n\n    case 'GenericObjectTypeAnnotation':\n    case 'AnyTypeAnnotation':\n      if (property.optional) {\n        return 'id<NSObject> _Nullable ' + property.name + ';';\n      }\n\n      return markRequiredIfNecessary('id<NSObject>');\n\n    case 'ArrayTypeAnnotation':\n      return markRequiredIfNecessary('std::vector<id<NSObject>>');\n\n    case 'FunctionTypeAnnotation':\n    default:\n      throw new Error(\"Unknown prop type, found: \" + typeAnnotation.type + \"\\\"\");\n  }\n}\n\nfunction safeGetter(name, optional) {\n  return (\"\\n  auto \" + name + \" = i.\" + name + (optional ? '' : '.get()') + \";\\n  d[@\\\"\" + name + \"\\\"] = \" + name + \";\\n  \").trim();\n}\n\nfunction arrayGetter(name, optional) {\n  return (\"\\n  auto \" + name + \" = i.\" + name + (optional ? '' : '.get()') + \";\\n  d[@\\\"\" + name + \"\\\"] = RCTConvert\" + (optional ? 'Optional' : '') + \"VecToArray(\" + name + \", ^id(id<NSObject> el_) { return el_; });\\n  \").trim();\n}\n\nfunction boolGetter(name, optional) {\n  return (\"\\n  auto \" + name + \" = i.\" + name + (optional ? '' : '.get()') + \";\\n  d[@\\\"\" + name + \"\\\"] = \" + (optional ? name + \".hasValue() ? @((BOOL)\" + name + \".value()) : nil\" : \"@(\" + name + \")\") + \";\\n  \").trim();\n}\n\nfunction numberGetter(name, optional) {\n  return (\"\\n  auto \" + name + \" = i.\" + name + (optional ? '' : '.get()') + \";\\n  d[@\\\"\" + name + \"\\\"] = \" + (optional ? name + \".hasValue() ? @((double)\" + name + \".value()) : nil\" : \"@(\" + name + \")\") + \";\\n  \").trim();\n}\n\nfunction unsafeGetter(name, optional) {\n  return (\"\\n  auto \" + name + \" = i.\" + name + (optional ? '' : '.get()') + \";\\n  d[@\\\"\" + name + \"\\\"] = \" + (optional ? name + \".hasValue() ? \" + name + \".value().buildUnsafeRawValue() : nil\" : name + \".buildUnsafeRawValue()\") + \";\\n  \").trim();\n}\n\nfunction getObjectProperty(property) {\n  var typeAnnotation = property.typeAnnotation;\n\n  switch (typeAnnotation.type) {\n    case 'NumberTypeAnnotation':\n    case 'FloatTypeAnnotation':\n    case 'Int32TypeAnnotation':\n      return numberGetter(property.name, property.optional);\n\n    case 'BooleanTypeAnnotation':\n      return boolGetter(property.name, property.optional);\n\n    case 'StringTypeAnnotation':\n    case 'GenericObjectTypeAnnotation':\n    case 'AnyTypeAnnotation':\n      return safeGetter(property.name, property.optional);\n\n    case 'ObjectTypeAnnotation':\n      return unsafeGetter(property.name, property.optional);\n\n    case 'ArrayTypeAnnotation':\n      return arrayGetter(property.name, property.optional);\n\n    case 'FunctionTypeAnnotation':\n    default:\n      throw new Error(\"Unknown prop type, found: \" + typeAnnotation.type + \"\\\"\");\n  }\n}\n\nfunction generateStructsForConstants(annotations) {\n  return flatObjects(annotations, true).reduce(function (acc, object) {\n    return acc.concat(structTemplate.replace(/::_INPUT_::/g, object.properties.map(function (property) {\n      return getBuilderInputFieldDeclaration(property, object.name);\n    }).join('\\n          ')).replace(/::_PROPERTIES_::/g, object.properties.map(function (property) {\n      return getObjectProperty(property);\n    }).join('\\n')).replace(/::_STRUCT_NAME_::/g, object.name));\n  }, []).reverse().join('\\n').replace(/SpecGetConstantsReturnType/g, 'Constants').replace(/GetConstantsReturnType/g, 'Constants');\n}\n\nmodule.exports = {\n  generateStructsForConstants: generateStructsForConstants,\n  capitalizeFirstLetter: capitalizeFirstLetter\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/generators/modules/ObjCppUtils/GenerateStructsForConstants.js"],"names":["require","flatObjects","capitalizeFirstLetter","structTemplate","getBuilderInputFieldDeclaration","property","name","markRequiredIfNecessary","annotation","optional","typeAnnotation","type","Error","safeGetter","trim","arrayGetter","boolGetter","numberGetter","unsafeGetter","getObjectProperty","generateStructsForConstants","annotations","reduce","acc","object","concat","replace","properties","map","join","reverse","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\n'use strict';\n\nimport type {ObjectParamTypeAnnotation} from '../../../CodegenSchema';\nconst {flatObjects, capitalizeFirstLetter} = require('./Utils');\n\nconst structTemplate = `\nnamespace JS {\n  namespace Native::_MODULE_NAME_:: {\n    struct ::_STRUCT_NAME_:: {\n\n      struct Builder {\n        struct Input {\n          ::_INPUT_::\n        };\n\n        /** Initialize with a set of values */\n        Builder(const Input i);\n        /** Initialize with an existing ::_STRUCT_NAME_:: */\n        Builder(::_STRUCT_NAME_:: i);\n        /** Builds the object. Generally used only by the infrastructure. */\n        NSDictionary *buildUnsafeRawValue() const { return _factory(); };\n      private:\n        NSDictionary *(^_factory)(void);\n      };\n\n      static ::_STRUCT_NAME_:: fromUnsafeRawValue(NSDictionary *const v) { return {v}; }\n      NSDictionary *unsafeRawValue() const { return _v; }\n    private:\n      ::_STRUCT_NAME_::(NSDictionary *const v) : _v(v) {}\n      NSDictionary *_v;\n    };\n  }\n}\n\ninline JS::Native::_MODULE_NAME_::::::_STRUCT_NAME_::::Builder::Builder(const Input i) : _factory(^{\n  NSMutableDictionary *d = [NSMutableDictionary new];\n  ::_PROPERTIES_::\n  return d;\n}) {}\ninline JS::Native::_MODULE_NAME_::::::_STRUCT_NAME_::::Builder::Builder(::_STRUCT_NAME_:: i) : _factory(^{\n  return i.unsafeRawValue();\n}) {}`;\n\nfunction getBuilderInputFieldDeclaration(\n  property: ObjectParamTypeAnnotation,\n  name: string,\n): string {\n  function markRequiredIfNecessary(annotation) {\n    if (!property.optional) {\n      return 'RCTRequired<' + annotation + '> ' + property.name + ';';\n    }\n    return 'folly::Optional<' + annotation + '> ' + property.name + ';';\n  }\n  const {typeAnnotation} = property;\n  switch (typeAnnotation.type) {\n    case 'StringTypeAnnotation':\n      if (property.optional) {\n        return 'NSString *' + property.name + ';';\n      }\n      return markRequiredIfNecessary('NSString *');\n    case 'NumberTypeAnnotation':\n    case 'FloatTypeAnnotation':\n    case 'Int32TypeAnnotation':\n      return markRequiredIfNecessary('double');\n    case 'BooleanTypeAnnotation':\n      return markRequiredIfNecessary('bool');\n    case 'ObjectTypeAnnotation':\n      return markRequiredIfNecessary(\n        `JS::Native::_MODULE_NAME_::::Spec${name}${capitalizeFirstLetter(\n          property.name,\n        )}::Builder`,\n      );\n    case 'GenericObjectTypeAnnotation':\n    case 'AnyTypeAnnotation':\n      if (property.optional) {\n        return 'id<NSObject> _Nullable ' + property.name + ';';\n      }\n      return markRequiredIfNecessary('id<NSObject>');\n    case 'ArrayTypeAnnotation':\n      return markRequiredIfNecessary('std::vector<id<NSObject>>');\n    case 'FunctionTypeAnnotation':\n    default:\n      throw new Error(`Unknown prop type, found: ${typeAnnotation.type}\"`);\n  }\n}\n\nfunction safeGetter(name: string, optional: boolean) {\n  return `\n  auto ${name} = i.${name}${optional ? '' : '.get()'};\n  d[@\"${name}\"] = ${name};\n  `.trim();\n}\n\nfunction arrayGetter(name: string, optional: boolean) {\n  return `\n  auto ${name} = i.${name}${optional ? '' : '.get()'};\n  d[@\"${name}\"] = RCTConvert${\n    optional ? 'Optional' : ''\n  }VecToArray(${name}, ^id(id<NSObject> el_) { return el_; });\n  `.trim();\n}\n\nfunction boolGetter(name: string, optional: boolean) {\n  return `\n  auto ${name} = i.${name}${optional ? '' : '.get()'};\n  d[@\"${name}\"] = ${\n    optional\n      ? `${name}.hasValue() ? @((BOOL)${name}.value()) : nil`\n      : `@(${name})`\n  };\n  `.trim();\n}\n\nfunction numberGetter(name: string, optional: boolean) {\n  return `\n  auto ${name} = i.${name}${optional ? '' : '.get()'};\n  d[@\"${name}\"] = ${\n    optional\n      ? `${name}.hasValue() ? @((double)${name}.value()) : nil`\n      : `@(${name})`\n  };\n  `.trim();\n}\n\nfunction unsafeGetter(name: string, optional: boolean) {\n  return `\n  auto ${name} = i.${name}${optional ? '' : '.get()'};\n  d[@\"${name}\"] = ${\n    optional\n      ? `${name}.hasValue() ? ${name}.value().buildUnsafeRawValue() : nil`\n      : `${name}.buildUnsafeRawValue()`\n  };\n  `.trim();\n}\n\nfunction getObjectProperty(property: ObjectParamTypeAnnotation): string {\n  const {typeAnnotation} = property;\n  switch (typeAnnotation.type) {\n    case 'NumberTypeAnnotation':\n    case 'FloatTypeAnnotation':\n    case 'Int32TypeAnnotation':\n      return numberGetter(property.name, property.optional);\n    case 'BooleanTypeAnnotation':\n      return boolGetter(property.name, property.optional);\n    case 'StringTypeAnnotation':\n    case 'GenericObjectTypeAnnotation':\n    case 'AnyTypeAnnotation':\n      return safeGetter(property.name, property.optional);\n    case 'ObjectTypeAnnotation':\n      return unsafeGetter(property.name, property.optional);\n    case 'ArrayTypeAnnotation':\n      return arrayGetter(property.name, property.optional);\n    case 'FunctionTypeAnnotation':\n    default:\n      throw new Error(`Unknown prop type, found: ${typeAnnotation.type}\"`);\n  }\n}\n\nfunction generateStructsForConstants(\n  annotations: $ReadOnlyArray<\n    $ReadOnly<{|\n      name: string,\n      object: $ReadOnly<{|\n        type: 'ObjectTypeAnnotation',\n        properties: $ReadOnlyArray<ObjectParamTypeAnnotation>,\n      |}>,\n    |}>,\n  >,\n): string {\n  return flatObjects(annotations, true)\n    .reduce(\n      (acc, object) =>\n        acc.concat(\n          structTemplate\n            .replace(\n              /::_INPUT_::/g,\n              object.properties\n                .map(property =>\n                  getBuilderInputFieldDeclaration(property, object.name),\n                )\n                .join('\\n          '),\n            )\n            .replace(\n              /::_PROPERTIES_::/g,\n              object.properties\n                .map(property => getObjectProperty(property))\n                .join('\\n'),\n            )\n            .replace(/::_STRUCT_NAME_::/g, object.name),\n        ),\n      [],\n    )\n    .reverse()\n    .join('\\n')\n    .replace(/SpecGetConstantsReturnType/g, 'Constants')\n    .replace(/GetConstantsReturnType/g, 'Constants');\n}\nmodule.exports = {\n  generateStructsForConstants,\n  capitalizeFirstLetter,\n};\n"]},"metadata":{},"sourceType":"script"}