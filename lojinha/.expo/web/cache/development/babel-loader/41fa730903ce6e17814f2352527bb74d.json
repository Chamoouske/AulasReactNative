{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = require(\"lodash\");\n\nvar FromJsonValidator = function () {\n  function FromJsonValidator() {\n    _classCallCheck(this, FromJsonValidator);\n\n    this.rules = [];\n  }\n\n  _createClass(FromJsonValidator, [{\n    key: \"addRule\",\n    value: function addRule(name) {\n      var validatingFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (value) {\n        return value;\n      };\n      var idx = this.rules.findIndex(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            propertyPath = _ref2[0];\n\n        return propertyPath.join('.') === name.join('.');\n      });\n\n      if (idx === -1) {\n        this.rules.push([name, validatingFunction]);\n      } else {\n        this.rules[idx] = [name, validatingFunction];\n      }\n\n      return this;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(jsonConfig) {\n      var config, errors, _iterator, _step, _ref3, _ref4, propertyPath, validatingFunc, rawValue, value;\n\n      return _regeneratorRuntime.async(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              config = {};\n              errors = [];\n              _iterator = _createForOfIteratorHelperLoose(this.rules);\n\n            case 3:\n              if ((_step = _iterator()).done) {\n                _context.next = 23;\n                break;\n              }\n\n              _ref3 = _step.value;\n              _ref4 = _slicedToArray(_ref3, 2);\n              propertyPath = _ref4[0];\n              validatingFunc = _ref4[1];\n              _context.prev = 8;\n              rawValue = lodash_1.get(jsonConfig, propertyPath);\n\n              if (!(rawValue === undefined)) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"continue\", 21);\n\n            case 12:\n              _context.next = 14;\n              return _regeneratorRuntime.awrap(validatingFunc(rawValue, config));\n\n            case 14:\n              value = _context.sent;\n              lodash_1.set(config, propertyPath, value);\n              _context.next = 21;\n              break;\n\n            case 18:\n              _context.prev = 18;\n              _context.t0 = _context[\"catch\"](8);\n              errors.push([propertyPath, _context.t0]);\n\n            case 21:\n              _context.next = 3;\n              break;\n\n            case 23:\n              if (!(errors.length > 0)) {\n                _context.next = 25;\n                break;\n              }\n\n              throw new Error(\"Validating error:\\n\" + this.formatErrors(errors));\n\n            case 25:\n              return _context.abrupt(\"return\", config);\n\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[8, 18]], Promise);\n    }\n  }, {\n    key: \"formatErrors\",\n    value: function formatErrors(errors) {\n      return errors.map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            propertyPath = _ref6[0],\n            error = _ref6[1];\n\n        return \"  '\" + propertyPath.map(function (el) {\n          return String(el);\n        }).join('.') + \"': \" + error.message;\n      }).join('\\n');\n    }\n  }]);\n\n  return FromJsonValidator;\n}();\n\nexports.default = FromJsonValidator;","map":{"version":3,"sources":["../../src/validators/FromJsonValidator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;IAaqB,iB;AAArB,+BAAA;AAAA;;AAMU,SAAA,KAAA,GAAqF,EAArF;AAyET;;;;WAlEC,iBAKE,IALF,EAsBoB;AAAA,UAhBlB,kBAgBkB,uEAAd,UAAA,KAAK;AAAA,eAAI,KAAJ;AAAA,OAAS;AAElB,UAAM,GAAG,GAAG,KAAK,KAAL,CAAW,SAAX,CAAqB;AAAA;AAAA,YAAE,YAAF;;AAAA,eAAoB,YAAY,CAAC,IAAb,CAAkB,GAAlB,MAA2B,IAAI,CAAC,IAAL,CAAU,GAAV,CAA/C;AAAA,OAArB,CAAZ;;AACA,UAAI,GAAG,KAAK,CAAC,CAAb,EAAgB;AAEd,aAAK,KAAL,CAAW,IAAX,CAAgB,CAAC,IAAD,EAAO,kBAAP,CAAhB;AACD,OAHD,MAGO;AAEL,aAAK,KAAL,CAAW,GAAX,IAAkB,CAAC,IAAD,EAAO,kBAAP,CAAlB;AACD;;AACD,aAAO,IAAP;AACD;;;WAED,kBAAe,UAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEQ,cAAA,MAFR,GAEqB,EAFrB;AAGQ,cAAA,MAHR,GAG2C,EAH3C;AAAA,0DAI+C,KAAK,KAJpD;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIc,cAAA,YAJd;AAI4B,cAAA,cAJ5B;AAAA;AAMY,cAAA,QANZ,GAMuB,QAAA,CAAA,GAAA,CAAI,UAAJ,EAAgB,YAAhB,CANvB;;AAAA,oBAOU,QAAQ,KAAK,SAPvB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,+CAW0B,cAAc,CAAC,QAAD,EAAW,MAAX,CAXxC;;AAAA;AAWY,cAAA,KAXZ;AAYM,cAAA,QAAA,CAAA,GAAA,CAAI,MAAJ,EAAY,YAAZ,EAA0B,KAA1B;AAZN;AAAA;;AAAA;AAAA;AAAA;AAcM,cAAA,MAAM,CAAC,IAAP,CAAY,CAAC,YAAD,cAAZ;;AAdN;AAAA;AAAA;;AAAA;AAAA,oBAkBM,MAAM,CAAC,MAAP,GAAgB,CAlBtB;AAAA;AAAA;AAAA;;AAAA,oBAmBU,IAAI,KAAJ,yBAAgC,KAAK,YAAL,CAAkB,MAAlB,CAAhC,CAnBV;;AAAA;AAAA,+CAqBS,MArBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAwBQ,sBAAa,MAAb,EAA6C;AACnD,aAAO,MAAM,CACV,GADI,CACA,iBAA0B;AAAA;AAAA,YAAxB,YAAwB;AAAA,YAAV,KAAU;;AAC7B,uBAAa,YAAY,CAAC,GAAb,CAAiB,UAAA,EAAE;AAAA,iBAAI,MAAM,CAAC,EAAD,CAAV;AAAA,SAAnB,EAAmC,IAAnC,CAAwC,GAAxC,CAAb,WAA+D,KAAK,CAAC,OAArE;AACD,OAHI,EAIJ,IAJI,CAIC,IAJD,CAAP;AAKD;;;;;;AA9EH,OAAA,CAAA,OAAA,GAAA,iBAAA","sourcesContent":["import { get, set } from 'lodash';\n\nimport type {\n  JsonShape,\n  OptionalPromise,\n  NonPrimitiveAndNonArrayKeys,\n  DeepRequired,\n  IsNever,\n} from './types';\n\n/**\n * This class is responsible for validating configuration object in a form of json and produce validated object based on validating `rules` added via `addRule` method.\n */\nexport default class FromJsonValidator<From extends JsonShape<To>, To extends object> {\n  /**\n   *  Records:\n   * - keys are stringified array paths to the properties\n   * - values are functions accepting\n   */\n  private rules: [PropertyKey[], (value: unknown, config: To) => OptionalPromise<unknown>][] = [];\n\n  /**\n   * Add rule that determined what property is copied from JSON object into actual validated object.\n   * @param name an array describing property path (just like in lodash.get function)\n   * @param validatingFunction optional parameter that is responsible for actual type conversion and semantic checking (e.g. check is given string is actually a path or a valid color). Not providing it results in copying over value without any semantic checking.\n   */\n  addRule<\n    TK1 extends NonPrimitiveAndNonArrayKeys<DeepRequired<To>>,\n    TK2 extends NonPrimitiveAndNonArrayKeys<DeepRequired<To>[TK1]>,\n    TK3 extends NonPrimitiveAndNonArrayKeys<DeepRequired<To>[TK1][TK2]>\n  >(\n    name: [TK1] | [TK1, TK2] | [TK1, TK2, TK3],\n    validatingFunction: (\n      value: IsNever<\n        TK3,\n        // @ts-ignore\n        IsNever<TK2, DeepRequired<From>[TK1], DeepRequired<From>[TK1][TK2]>,\n        // @ts-ignore\n        DeepRequired<From>[TK1][TK2][TK3]\n      >,\n      config: To\n    ) => OptionalPromise<\n      IsNever<\n        TK3,\n        IsNever<TK2, DeepRequired<To>[TK1], DeepRequired<To>[TK1][TK2]>,\n        DeepRequired<To>[TK1][TK2][TK3]\n      >\n      // @ts-ignore\n    > = value => value\n  ): this {\n    const idx = this.rules.findIndex(([propertyPath]) => propertyPath.join('.') === name.join('.'));\n    if (idx === -1) {\n      // @ts-ignore\n      this.rules.push([name, validatingFunction]);\n    } else {\n      // @ts-ignore\n      this.rules[idx] = [name, validatingFunction];\n    }\n    return this;\n  }\n\n  async validate(jsonConfig: From): Promise<To> {\n    // @ts-ignore\n    const config: To = {};\n    const errors: [PropertyKey[], Error][] = [];\n    for (const [propertyPath, validatingFunc] of this.rules) {\n      try {\n        const rawValue = get(jsonConfig, propertyPath);\n        if (rawValue === undefined) {\n          // No value for this propertyPath\n          continue;\n        }\n        const value = await validatingFunc(rawValue, config);\n        set(config, propertyPath, value);\n      } catch (e) {\n        errors.push([propertyPath, e]);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new Error(`Validating error:\\n${this.formatErrors(errors)}`);\n    }\n    return config;\n  }\n\n  private formatErrors(errors: [PropertyKey[], Error][]): string {\n    return errors\n      .map(([propertyPath, error]) => {\n        return `  '${propertyPath.map(el => String(el)).join('.')}': ${error.message}`;\n      })\n      .join('\\n');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}