{"ast":null,"code":"'use strict';\n\nfunction upperCaseFirst(inString) {\n  if (inString.length === 0) {\n    return inString;\n  }\n\n  return inString[0].toUpperCase() + inString.slice(1);\n}\n\nfunction toSafeCppString(input) {\n  return input.split('-').map(upperCaseFirst).join('');\n}\n\nfunction toIntEnumValueName(propName, value) {\n  return \"\" + toSafeCppString(propName) + value;\n}\n\nfunction getCppTypeForAnnotation(type) {\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n      return 'bool';\n\n    case 'StringTypeAnnotation':\n      return 'std::string';\n\n    case 'Int32TypeAnnotation':\n      return 'int';\n\n    case 'DoubleTypeAnnotation':\n      return 'double';\n\n    case 'FloatTypeAnnotation':\n      return 'Float';\n\n    default:\n      type;\n      throw new Error(\"Received invalid typeAnnotation \" + type);\n  }\n}\n\nfunction getImports(properties) {\n  var imports = new Set();\n\n  function addImportsForNativeName(name) {\n    switch (name) {\n      case 'ColorPrimitive':\n        return;\n\n      case 'PointPrimitive':\n        return;\n\n      case 'EdgeInsetsPrimitive':\n        return;\n\n      case 'ImageSourcePrimitive':\n        imports.add('#include <react/components/image/conversions.h>');\n        return;\n\n      default:\n        name;\n        throw new Error(\"Invalid name, got \" + name);\n    }\n  }\n\n  properties.forEach(function (prop) {\n    var typeAnnotation = prop.typeAnnotation;\n\n    if (typeAnnotation.type === 'NativePrimitiveTypeAnnotation') {\n      addImportsForNativeName(typeAnnotation.name);\n    }\n\n    if (typeAnnotation.type === 'ArrayTypeAnnotation' && typeAnnotation.elementType.type === 'NativePrimitiveTypeAnnotation') {\n      addImportsForNativeName(typeAnnotation.elementType.name);\n    }\n\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      var objectImports = getImports(typeAnnotation.properties);\n      objectImports.forEach(imports.add, imports);\n    }\n  });\n  return imports;\n}\n\nfunction generateEventStructName() {\n  var parts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var additional = parts.map(toSafeCppString).join('');\n  return \"\" + additional;\n}\n\nfunction generateStructName(componentName) {\n  var parts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var additional = parts.map(toSafeCppString).join('');\n  return \"\" + componentName + additional + \"Struct\";\n}\n\nfunction getEnumName(componentName, propName) {\n  var uppercasedPropName = toSafeCppString(propName);\n  return \"\" + componentName + uppercasedPropName;\n}\n\nfunction getEnumMaskName(enumName) {\n  return enumName + \"Mask\";\n}\n\nfunction convertDefaultTypeToString(componentName, prop) {\n  var typeAnnotation = prop.typeAnnotation;\n\n  switch (typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      if (typeAnnotation.default == null) {\n        return '';\n      }\n\n      return String(typeAnnotation.default);\n\n    case 'StringTypeAnnotation':\n      if (typeAnnotation.default == null) {\n        return '';\n      }\n\n      return \"\\\"\" + typeAnnotation.default + \"\\\"\";\n\n    case 'Int32TypeAnnotation':\n      return String(typeAnnotation.default);\n\n    case 'DoubleTypeAnnotation':\n      var defaultDoubleVal = typeAnnotation.default;\n      return parseInt(defaultDoubleVal, 10) === defaultDoubleVal ? typeAnnotation.default.toFixed(1) : String(typeAnnotation.default);\n\n    case 'FloatTypeAnnotation':\n      var defaultFloatVal = typeAnnotation.default;\n\n      if (defaultFloatVal == null) {\n        return '';\n      }\n\n      return parseInt(defaultFloatVal, 10) === defaultFloatVal ? defaultFloatVal.toFixed(1) : String(typeAnnotation.default);\n\n    case 'NativePrimitiveTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'ColorPrimitive':\n          return '';\n\n        case 'ImageSourcePrimitive':\n          return '';\n\n        case 'PointPrimitive':\n          return '';\n\n        case 'EdgeInsetsPrimitive':\n          return '';\n\n        default:\n          typeAnnotation.name;\n          throw new Error('Received unknown NativePrimitiveTypeAnnotation');\n      }\n\n    case 'ArrayTypeAnnotation':\n      {\n        var elementType = typeAnnotation.elementType;\n\n        switch (elementType.type) {\n          case 'StringEnumTypeAnnotation':\n            if (elementType.default == null) {\n              throw new Error('A default is required for array StringEnumTypeAnnotation');\n            }\n\n            var enumName = getEnumName(componentName, prop.name);\n            var enumMaskName = getEnumMaskName(enumName);\n            var defaultValue = enumName + \"::\" + toSafeCppString(elementType.default);\n            return \"static_cast<\" + enumMaskName + \">(\" + defaultValue + \")\";\n\n          default:\n            return '';\n        }\n      }\n\n    case 'ObjectTypeAnnotation':\n      {\n        return '';\n      }\n\n    case 'StringEnumTypeAnnotation':\n      return getEnumName(componentName, prop.name) + \"::\" + toSafeCppString(typeAnnotation.default);\n\n    case 'Int32EnumTypeAnnotation':\n      return getEnumName(componentName, prop.name) + \"::\" + toIntEnumValueName(prop.name, typeAnnotation.default);\n\n    default:\n      typeAnnotation;\n      throw new Error('Received invalid typeAnnotation');\n  }\n}\n\nmodule.exports = {\n  convertDefaultTypeToString: convertDefaultTypeToString,\n  getCppTypeForAnnotation: getCppTypeForAnnotation,\n  getEnumName: getEnumName,\n  getEnumMaskName: getEnumMaskName,\n  getImports: getImports,\n  toSafeCppString: toSafeCppString,\n  toIntEnumValueName: toIntEnumValueName,\n  generateStructName: generateStructName,\n  generateEventStructName: generateEventStructName\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/generators/components/CppHelpers.js"],"names":["upperCaseFirst","inString","length","toUpperCase","slice","toSafeCppString","input","split","map","join","toIntEnumValueName","propName","value","getCppTypeForAnnotation","type","Error","getImports","properties","imports","Set","addImportsForNativeName","name","add","forEach","prop","typeAnnotation","elementType","objectImports","generateEventStructName","parts","additional","generateStructName","componentName","getEnumName","uppercasedPropName","getEnumMaskName","enumName","convertDefaultTypeToString","default","String","defaultDoubleVal","parseInt","toFixed","defaultFloatVal","enumMaskName","defaultValue","module","exports"],"mappings":"AAUA;;AAGA,SAASA,cAAT,CAAwBC,QAAxB,EAAkD;AAChD,MAAIA,QAAQ,CAACC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,WAAOD,QAAP;AACD;;AAED,SAAOA,QAAQ,CAAC,CAAD,CAAR,CAAYE,WAAZ,KAA4BF,QAAQ,CAACG,KAAT,CAAe,CAAf,CAAnC;AACD;;AAED,SAASC,eAAT,CAAyBC,KAAzB,EAAgD;AAC9C,SAAOA,KAAK,CACTC,KADI,CACE,GADF,EAEJC,GAFI,CAEAR,cAFA,EAGJS,IAHI,CAGC,EAHD,CAAP;AAID;;AAED,SAASC,kBAAT,CAA4BC,QAA5B,EAA8CC,KAA9C,EAAqE;AACnE,cAAUP,eAAe,CAACM,QAAD,CAAzB,GAAsCC,KAAtC;AACD;;AAED,SAASC,uBAAT,CACEC,IADF,EAOU;AACR,UAAQA,IAAR;AACE,SAAK,uBAAL;AACE,aAAO,MAAP;;AACF,SAAK,sBAAL;AACE,aAAO,aAAP;;AACF,SAAK,qBAAL;AACE,aAAO,KAAP;;AACF,SAAK,sBAAL;AACE,aAAO,QAAP;;AACF,SAAK,qBAAL;AACE,aAAO,OAAP;;AACF;AACGA,MAAAA,IAAD;AACA,YAAM,IAAIC,KAAJ,sCAA6CD,IAA7C,CAAN;AAbJ;AAeD;;AAED,SAASE,UAAT,CAAoBC,UAApB,EAA4E;AAC1E,MAAMC,OAAoB,GAAG,IAAIC,GAAJ,EAA7B;;AAEA,WAASC,uBAAT,CAAiCC,IAAjC,EAAuC;AACrC,YAAQA,IAAR;AACE,WAAK,gBAAL;AACE;;AACF,WAAK,gBAAL;AACE;;AACF,WAAK,qBAAL;AACE;;AACF,WAAK,sBAAL;AACEH,QAAAA,OAAO,CAACI,GAAR,CAAY,iDAAZ;AACA;;AACF;AACGD,QAAAA,IAAD;AACA,cAAM,IAAIN,KAAJ,wBAA+BM,IAA/B,CAAN;AAZJ;AAcD;;AAEDJ,EAAAA,UAAU,CAACM,OAAX,CAAmB,UAAAC,IAAI,EAAI;AACzB,QAAMC,cAAc,GAAGD,IAAI,CAACC,cAA5B;;AAEA,QAAIA,cAAc,CAACX,IAAf,KAAwB,+BAA5B,EAA6D;AAC3DM,MAAAA,uBAAuB,CAACK,cAAc,CAACJ,IAAhB,CAAvB;AACD;;AAED,QACEI,cAAc,CAACX,IAAf,KAAwB,qBAAxB,IACAW,cAAc,CAACC,WAAf,CAA2BZ,IAA3B,KAAoC,+BAFtC,EAGE;AACAM,MAAAA,uBAAuB,CAACK,cAAc,CAACC,WAAf,CAA2BL,IAA5B,CAAvB;AACD;;AAED,QAAII,cAAc,CAACX,IAAf,KAAwB,sBAA5B,EAAoD;AAClD,UAAMa,aAAa,GAAGX,UAAU,CAACS,cAAc,CAACR,UAAhB,CAAhC;AACAU,MAAAA,aAAa,CAACJ,OAAd,CAAsBL,OAAO,CAACI,GAA9B,EAAmCJ,OAAnC;AACD;AACF,GAlBD;AAoBA,SAAOA,OAAP;AACD;;AAED,SAASU,uBAAT,GAA6E;AAAA,MAA5CC,KAA4C,uEAAZ,EAAY;AAC3E,MAAMC,UAAU,GAAGD,KAAK,CAACrB,GAAN,CAAUH,eAAV,EAA2BI,IAA3B,CAAgC,EAAhC,CAAnB;AACA,cAAUqB,UAAV;AACD;;AAED,SAASC,kBAAT,CACEC,aADF,EAGU;AAAA,MADRH,KACQ,uEADwB,EACxB;AACR,MAAMC,UAAU,GAAGD,KAAK,CAACrB,GAAN,CAAUH,eAAV,EAA2BI,IAA3B,CAAgC,EAAhC,CAAnB;AACA,cAAUuB,aAAV,GAA0BF,UAA1B;AACD;;AAED,SAASG,WAAT,CAAqBD,aAArB,EAA4CrB,QAA5C,EAAsE;AACpE,MAAMuB,kBAAkB,GAAG7B,eAAe,CAACM,QAAD,CAA1C;AACA,cAAUqB,aAAV,GAA0BE,kBAA1B;AACD;;AAED,SAASC,eAAT,CAAyBC,QAAzB,EAAmD;AACjD,SAAUA,QAAV;AACD;;AAED,SAASC,0BAAT,CACEL,aADF,EAEER,IAFF,EAGU;AACR,MAAMC,cAAc,GAAGD,IAAI,CAACC,cAA5B;;AACA,UAAQA,cAAc,CAACX,IAAvB;AACE,SAAK,uBAAL;AACE,UAAIW,cAAc,CAACa,OAAf,IAA0B,IAA9B,EAAoC;AAClC,eAAO,EAAP;AACD;;AACD,aAAOC,MAAM,CAACd,cAAc,CAACa,OAAhB,CAAb;;AACF,SAAK,sBAAL;AACE,UAAIb,cAAc,CAACa,OAAf,IAA0B,IAA9B,EAAoC;AAClC,eAAO,EAAP;AACD;;AACD,oBAAWb,cAAc,CAACa,OAA1B;;AACF,SAAK,qBAAL;AACE,aAAOC,MAAM,CAACd,cAAc,CAACa,OAAhB,CAAb;;AACF,SAAK,sBAAL;AACE,UAAME,gBAAgB,GAAGf,cAAc,CAACa,OAAxC;AACA,aAAOG,QAAQ,CAACD,gBAAD,EAAmB,EAAnB,CAAR,KAAmCA,gBAAnC,GACHf,cAAc,CAACa,OAAf,CAAuBI,OAAvB,CAA+B,CAA/B,CADG,GAEHH,MAAM,CAACd,cAAc,CAACa,OAAhB,CAFV;;AAGF,SAAK,qBAAL;AACE,UAAMK,eAAe,GAAGlB,cAAc,CAACa,OAAvC;;AACA,UAAIK,eAAe,IAAI,IAAvB,EAA6B;AAC3B,eAAO,EAAP;AACD;;AACD,aAAOF,QAAQ,CAACE,eAAD,EAAkB,EAAlB,CAAR,KAAkCA,eAAlC,GACHA,eAAe,CAACD,OAAhB,CAAwB,CAAxB,CADG,GAEHH,MAAM,CAACd,cAAc,CAACa,OAAhB,CAFV;;AAGF,SAAK,+BAAL;AACE,cAAQb,cAAc,CAACJ,IAAvB;AACE,aAAK,gBAAL;AACE,iBAAO,EAAP;;AACF,aAAK,sBAAL;AACE,iBAAO,EAAP;;AACF,aAAK,gBAAL;AACE,iBAAO,EAAP;;AACF,aAAK,qBAAL;AACE,iBAAO,EAAP;;AACF;AACGI,UAAAA,cAAc,CAACJ,IAAhB;AACA,gBAAM,IAAIN,KAAJ,CAAU,gDAAV,CAAN;AAXJ;;AAaF,SAAK,qBAAL;AAA4B;AAC1B,YAAMW,WAAW,GAAGD,cAAc,CAACC,WAAnC;;AACA,gBAAQA,WAAW,CAACZ,IAApB;AACE,eAAK,0BAAL;AACE,gBAAIY,WAAW,CAACY,OAAZ,IAAuB,IAA3B,EAAiC;AAC/B,oBAAM,IAAIvB,KAAJ,CACJ,0DADI,CAAN;AAGD;;AACD,gBAAMqB,QAAQ,GAAGH,WAAW,CAACD,aAAD,EAAgBR,IAAI,CAACH,IAArB,CAA5B;AACA,gBAAMuB,YAAY,GAAGT,eAAe,CAACC,QAAD,CAApC;AACA,gBAAMS,YAAY,GAAMT,QAAN,UAAmB/B,eAAe,CAClDqB,WAAW,CAACY,OADsC,CAApD;AAGA,oCAAsBM,YAAtB,UAAuCC,YAAvC;;AACF;AACE,mBAAO,EAAP;AAdJ;AAgBD;;AACD,SAAK,sBAAL;AAA6B;AAC3B,eAAO,EAAP;AACD;;AACD,SAAK,0BAAL;AACE,aAAUZ,WAAW,CAACD,aAAD,EAAgBR,IAAI,CAACH,IAArB,CAArB,UAAoDhB,eAAe,CACjEoB,cAAc,CAACa,OADkD,CAAnE;;AAGF,SAAK,yBAAL;AACE,aAAUL,WAAW,CAACD,aAAD,EAAgBR,IAAI,CAACH,IAArB,CAArB,UAAoDX,kBAAkB,CACpEc,IAAI,CAACH,IAD+D,EAEpEI,cAAc,CAACa,OAFqD,CAAtE;;AAIF;AACGb,MAAAA,cAAD;AACA,YAAM,IAAIV,KAAJ,CAAU,iCAAV,CAAN;AAzEJ;AA2ED;;AAED+B,MAAM,CAACC,OAAP,GAAiB;AACfV,EAAAA,0BAA0B,EAA1BA,0BADe;AAEfxB,EAAAA,uBAAuB,EAAvBA,uBAFe;AAGfoB,EAAAA,WAAW,EAAXA,WAHe;AAIfE,EAAAA,eAAe,EAAfA,eAJe;AAKfnB,EAAAA,UAAU,EAAVA,UALe;AAMfX,EAAAA,eAAe,EAAfA,eANe;AAOfK,EAAAA,kBAAkB,EAAlBA,kBAPe;AAQfqB,EAAAA,kBAAkB,EAAlBA,kBARe;AASfH,EAAAA,uBAAuB,EAAvBA;AATe,CAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\n'use strict';\nimport type {PropTypeShape} from '../../CodegenSchema';\n\nfunction upperCaseFirst(inString: string): string {\n  if (inString.length === 0) {\n    return inString;\n  }\n\n  return inString[0].toUpperCase() + inString.slice(1);\n}\n\nfunction toSafeCppString(input: string): string {\n  return input\n    .split('-')\n    .map(upperCaseFirst)\n    .join('');\n}\n\nfunction toIntEnumValueName(propName: string, value: number): string {\n  return `${toSafeCppString(propName)}${value}`;\n}\n\nfunction getCppTypeForAnnotation(\n  type:\n    | 'BooleanTypeAnnotation'\n    | 'StringTypeAnnotation'\n    | 'Int32TypeAnnotation'\n    | 'DoubleTypeAnnotation'\n    | 'FloatTypeAnnotation',\n): string {\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n      return 'bool';\n    case 'StringTypeAnnotation':\n      return 'std::string';\n    case 'Int32TypeAnnotation':\n      return 'int';\n    case 'DoubleTypeAnnotation':\n      return 'double';\n    case 'FloatTypeAnnotation':\n      return 'Float';\n    default:\n      (type: empty);\n      throw new Error(`Received invalid typeAnnotation ${type}`);\n  }\n}\n\nfunction getImports(properties: $ReadOnlyArray<PropTypeShape>): Set<string> {\n  const imports: Set<string> = new Set();\n\n  function addImportsForNativeName(name) {\n    switch (name) {\n      case 'ColorPrimitive':\n        return;\n      case 'PointPrimitive':\n        return;\n      case 'EdgeInsetsPrimitive':\n        return;\n      case 'ImageSourcePrimitive':\n        imports.add('#include <react/components/image/conversions.h>');\n        return;\n      default:\n        (name: empty);\n        throw new Error(`Invalid name, got ${name}`);\n    }\n  }\n\n  properties.forEach(prop => {\n    const typeAnnotation = prop.typeAnnotation;\n\n    if (typeAnnotation.type === 'NativePrimitiveTypeAnnotation') {\n      addImportsForNativeName(typeAnnotation.name);\n    }\n\n    if (\n      typeAnnotation.type === 'ArrayTypeAnnotation' &&\n      typeAnnotation.elementType.type === 'NativePrimitiveTypeAnnotation'\n    ) {\n      addImportsForNativeName(typeAnnotation.elementType.name);\n    }\n\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      const objectImports = getImports(typeAnnotation.properties);\n      objectImports.forEach(imports.add, imports);\n    }\n  });\n\n  return imports;\n}\n\nfunction generateEventStructName(parts: $ReadOnlyArray<string> = []): string {\n  const additional = parts.map(toSafeCppString).join('');\n  return `${additional}`;\n}\n\nfunction generateStructName(\n  componentName: string,\n  parts: $ReadOnlyArray<string> = [],\n): string {\n  const additional = parts.map(toSafeCppString).join('');\n  return `${componentName}${additional}Struct`;\n}\n\nfunction getEnumName(componentName: string, propName: string): string {\n  const uppercasedPropName = toSafeCppString(propName);\n  return `${componentName}${uppercasedPropName}`;\n}\n\nfunction getEnumMaskName(enumName: string): string {\n  return `${enumName}Mask`;\n}\n\nfunction convertDefaultTypeToString(\n  componentName: string,\n  prop: PropTypeShape,\n): string {\n  const typeAnnotation = prop.typeAnnotation;\n  switch (typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      if (typeAnnotation.default == null) {\n        return '';\n      }\n      return String(typeAnnotation.default);\n    case 'StringTypeAnnotation':\n      if (typeAnnotation.default == null) {\n        return '';\n      }\n      return `\"${typeAnnotation.default}\"`;\n    case 'Int32TypeAnnotation':\n      return String(typeAnnotation.default);\n    case 'DoubleTypeAnnotation':\n      const defaultDoubleVal = typeAnnotation.default;\n      return parseInt(defaultDoubleVal, 10) === defaultDoubleVal\n        ? typeAnnotation.default.toFixed(1)\n        : String(typeAnnotation.default);\n    case 'FloatTypeAnnotation':\n      const defaultFloatVal = typeAnnotation.default;\n      if (defaultFloatVal == null) {\n        return '';\n      }\n      return parseInt(defaultFloatVal, 10) === defaultFloatVal\n        ? defaultFloatVal.toFixed(1)\n        : String(typeAnnotation.default);\n    case 'NativePrimitiveTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'ColorPrimitive':\n          return '';\n        case 'ImageSourcePrimitive':\n          return '';\n        case 'PointPrimitive':\n          return '';\n        case 'EdgeInsetsPrimitive':\n          return '';\n        default:\n          (typeAnnotation.name: empty);\n          throw new Error('Received unknown NativePrimitiveTypeAnnotation');\n      }\n    case 'ArrayTypeAnnotation': {\n      const elementType = typeAnnotation.elementType;\n      switch (elementType.type) {\n        case 'StringEnumTypeAnnotation':\n          if (elementType.default == null) {\n            throw new Error(\n              'A default is required for array StringEnumTypeAnnotation',\n            );\n          }\n          const enumName = getEnumName(componentName, prop.name);\n          const enumMaskName = getEnumMaskName(enumName);\n          const defaultValue = `${enumName}::${toSafeCppString(\n            elementType.default,\n          )}`;\n          return `static_cast<${enumMaskName}>(${defaultValue})`;\n        default:\n          return '';\n      }\n    }\n    case 'ObjectTypeAnnotation': {\n      return '';\n    }\n    case 'StringEnumTypeAnnotation':\n      return `${getEnumName(componentName, prop.name)}::${toSafeCppString(\n        typeAnnotation.default,\n      )}`;\n    case 'Int32EnumTypeAnnotation':\n      return `${getEnumName(componentName, prop.name)}::${toIntEnumValueName(\n        prop.name,\n        typeAnnotation.default,\n      )}`;\n    default:\n      (typeAnnotation: empty);\n      throw new Error('Received invalid typeAnnotation');\n  }\n}\n\nmodule.exports = {\n  convertDefaultTypeToString,\n  getCppTypeForAnnotation,\n  getEnumName,\n  getEnumMaskName,\n  getImports,\n  toSafeCppString,\n  toIntEnumValueName,\n  generateStructName,\n  generateEventStructName,\n};\n"]},"metadata":{},"sourceType":"script"}