{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _require = require(\"./CppHelpers.js\"),\n    convertDefaultTypeToString = _require.convertDefaultTypeToString,\n    getCppTypeForAnnotation = _require.getCppTypeForAnnotation,\n    getEnumMaskName = _require.getEnumMaskName,\n    getEnumName = _require.getEnumName,\n    toSafeCppString = _require.toSafeCppString,\n    generateStructName = _require.generateStructName,\n    getImports = _require.getImports,\n    toIntEnumValueName = _require.toIntEnumValueName;\n\nvar template = \"\\n/**\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n#pragma once\\n\\n::_IMPORTS_::\\n\\nnamespace facebook {\\nnamespace react {\\n\\n::_COMPONENT_CLASSES_::\\n\\n} // namespace react\\n} // namespace facebook\\n\";\nvar classTemplate = \"\\n::_ENUMS_::\\n::_STRUCTS_::\\nclass ::_CLASSNAME_:: final::_EXTEND_CLASSES_:: {\\n public:\\n  ::_CLASSNAME_::() = default;\\n  ::_CLASSNAME_::(const ::_CLASSNAME_:: &sourceProps, const RawProps &rawProps);\\n\\n#pragma mark - Props\\n\\n  ::_PROPS_::\\n};\\n\".trim();\nvar enumTemplate = \"\\nenum class ::_ENUM_NAME_:: { ::_VALUES_:: };\\n\\nstatic inline void fromRawValue(const RawValue &value, ::_ENUM_NAME_:: &result) {\\n  auto string = (std::string)value;\\n  ::_FROM_CASES_::\\n  abort();\\n}\\n\\nstatic inline std::string toString(const ::_ENUM_NAME_:: &value) {\\n  switch (value) {\\n    ::_TO_CASES_::\\n  }\\n}\\n\".trim();\nvar intEnumTemplate = \"\\nenum class ::_ENUM_NAME_:: { ::_VALUES_:: };\\n\\nstatic inline void fromRawValue(const RawValue &value, ::_ENUM_NAME_:: &result) {\\n  assert(value.hasType<int>());\\n  auto integerValue = (int)value;\\n  switch (integerValue) {::_FROM_CASES_::\\n  }\\n  abort();\\n}\\n\\nstatic inline std::string toString(const ::_ENUM_NAME_:: &value) {\\n  switch (value) {\\n    ::_TO_CASES_::\\n  }\\n}\\n\".trim();\nvar structTemplate = \"struct ::_STRUCT_NAME_:: {\\n  ::_FIELDS_::\\n};\\n\\nstatic inline void fromRawValue(const RawValue &value, ::_STRUCT_NAME_:: &result) {\\n  auto map = (better::map<std::string, RawValue>)value;\\n\\n  ::_FROM_CASES_::\\n}\\n\\nstatic inline std::string toString(const ::_STRUCT_NAME_:: &value) {\\n  return \\\"[Object ::_STRUCT_NAME_::]\\\";\\n}\\n\".trim();\nvar arrayConversionFunction = \"static inline void fromRawValue(const RawValue &value, std::vector<::_STRUCT_NAME_::> &result) {\\n  auto items = (std::vector<RawValue>)value;\\n  for (const auto &item : items) {\\n    ::_STRUCT_NAME_:: newItem;\\n    fromRawValue(item, newItem);\\n    result.emplace_back(newItem);\\n  }\\n}\\n\";\nvar doubleArrayConversionFunction = \"static inline void fromRawValue(const RawValue &value, std::vector<std::vector<::_STRUCT_NAME_::>> &result) {\\n  auto items = (std::vector<std::vector<RawValue>>)value;\\n  for (const std::vector<RawValue> &item : items) {\\n    auto nestedArray = std::vector<::_STRUCT_NAME_::>{};\\n    for (const RawValue &nestedItem : item) {\\n      ::_STRUCT_NAME_:: newItem;\\n      fromRawValue(nestedItem, newItem);\\n      nestedArray.emplace_back(newItem);\\n    }\\n    result.emplace_back(nestedArray);\\n  }\\n}\\n\";\nvar arrayEnumTemplate = \"\\nusing ::_ENUM_MASK_:: = uint32_t;\\n\\nenum class ::_ENUM_NAME_::: ::_ENUM_MASK_:: {\\n  ::_VALUES_::\\n};\\n\\nconstexpr bool operator&(\\n  ::_ENUM_MASK_:: const lhs,\\n  enum ::_ENUM_NAME_:: const rhs) {\\n  return lhs & static_cast<::_ENUM_MASK_::>(rhs);\\n}\\n\\nconstexpr ::_ENUM_MASK_:: operator|(\\n  ::_ENUM_MASK_:: const lhs,\\n  enum ::_ENUM_NAME_:: const rhs) {\\n  return lhs | static_cast<::_ENUM_MASK_::>(rhs);\\n}\\n\\nconstexpr void operator|=(\\n  ::_ENUM_MASK_:: &lhs,\\n  enum ::_ENUM_NAME_:: const rhs) {\\n  lhs = lhs | static_cast<::_ENUM_MASK_::>(rhs);\\n}\\n\\nstatic inline void fromRawValue(const RawValue &value, ::_ENUM_MASK_:: &result) {\\n  auto items = std::vector<std::string>{value};\\n  for (const auto &item : items) {\\n    ::_FROM_CASES_::\\n    abort();\\n  }\\n}\\n\\nstatic inline std::string toString(const ::_ENUM_MASK_:: &value) {\\n    auto result = std::string{};\\n    auto separator = std::string{\\\", \\\"};\\n\\n    ::_TO_CASES_::\\n    if (!result.empty()) {\\n      result.erase(result.length() - separator.length());\\n    }\\n    return result;\\n}\\n\".trim();\n\nfunction getClassExtendString(component) {\n  var extendString = ' : ' + component.extendsProps.map(function (extendProps) {\n    switch (extendProps.type) {\n      case 'ReactNativeBuiltInType':\n        switch (extendProps.knownTypeName) {\n          case 'ReactNativeCoreViewProps':\n            return 'public ViewProps';\n\n          default:\n            extendProps.knownTypeName;\n            throw new Error('Invalid knownTypeName');\n        }\n\n      default:\n        extendProps.type;\n        throw new Error('Invalid extended type');\n    }\n  }).join(' ');\n  return extendString;\n}\n\nfunction getNativeTypeFromAnnotation(componentName, prop, nameParts) {\n  var typeAnnotation = prop.typeAnnotation;\n\n  switch (typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n    case 'FloatTypeAnnotation':\n      return getCppTypeForAnnotation(typeAnnotation.type);\n\n    case 'NativePrimitiveTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'ColorPrimitive':\n          return 'SharedColor';\n\n        case 'ImageSourcePrimitive':\n          return 'ImageSource';\n\n        case 'PointPrimitive':\n          return 'Point';\n\n        case 'EdgeInsetsPrimitive':\n          return 'EdgeInsets';\n\n        default:\n          typeAnnotation.name;\n          throw new Error('Received unknown NativePrimitiveTypeAnnotation');\n      }\n\n    case 'ArrayTypeAnnotation':\n      {\n        var arrayType = typeAnnotation.elementType.type;\n\n        if (arrayType === 'ArrayTypeAnnotation') {\n          return \"std::vector<\" + getNativeTypeFromAnnotation(componentName, {\n            typeAnnotation: typeAnnotation.elementType,\n            name: ''\n          }, nameParts.concat([prop.name])) + \">\";\n        }\n\n        if (arrayType === 'ObjectTypeAnnotation') {\n          var structName = generateStructName(componentName, nameParts.concat([prop.name]));\n          return \"std::vector<\" + structName + \">\";\n        }\n\n        if (arrayType === 'StringEnumTypeAnnotation') {\n          var enumName = getEnumName(componentName, prop.name);\n          return getEnumMaskName(enumName);\n        }\n\n        var itemAnnotation = getNativeTypeFromAnnotation(componentName, {\n          typeAnnotation: typeAnnotation.elementType,\n          name: componentName\n        }, nameParts.concat([prop.name]));\n        return \"std::vector<\" + itemAnnotation + \">\";\n      }\n\n    case 'ObjectTypeAnnotation':\n      {\n        return generateStructName(componentName, nameParts.concat([prop.name]));\n      }\n\n    case 'StringEnumTypeAnnotation':\n      return getEnumName(componentName, prop.name);\n\n    case 'Int32EnumTypeAnnotation':\n      return getEnumName(componentName, prop.name);\n\n    default:\n      typeAnnotation;\n      throw new Error(\"Received invalid typeAnnotation for \" + componentName + \" prop \" + prop.name + \", received \" + typeAnnotation.type);\n  }\n}\n\nfunction convertValueToEnumOption(value) {\n  return toSafeCppString(value);\n}\n\nfunction generateArrayEnumString(componentName, name, enumOptions) {\n  var options = enumOptions.map(function (option) {\n    return option.name;\n  });\n  var enumName = getEnumName(componentName, name);\n  var values = options.map(function (option, index) {\n    return toSafeCppString(option) + \" = 1 << \" + index;\n  }).join(',\\n  ');\n  var fromCases = options.map(function (option) {\n    return \"if (item == \\\"\" + option + \"\\\") {\\n      result |= \" + enumName + \"::\" + toSafeCppString(option) + \";\\n      continue;\\n    }\";\n  }).join('\\n    ');\n  var toCases = options.map(function (option) {\n    return \"if (value & \" + enumName + \"::\" + toSafeCppString(option) + \") {\\n      result += \\\"\" + option + \"\\\" + separator;\\n    }\";\n  }).join('\\n' + '    ');\n  return arrayEnumTemplate.replace(/::_ENUM_NAME_::/g, enumName).replace(/::_ENUM_MASK_::/g, getEnumMaskName(enumName)).replace('::_VALUES_::', values).replace('::_FROM_CASES_::', fromCases).replace('::_TO_CASES_::', toCases);\n}\n\nfunction generateStringEnum(componentName, prop) {\n  var typeAnnotation = prop.typeAnnotation;\n\n  if (typeAnnotation.type === 'StringEnumTypeAnnotation') {\n    var values = typeAnnotation.options.map(function (option) {\n      return option.name;\n    });\n    var enumName = getEnumName(componentName, prop.name);\n    var fromCases = values.map(function (value) {\n      return \"if (string == \\\"\" + value + \"\\\") { result = \" + enumName + \"::\" + convertValueToEnumOption(value) + \"; return; }\";\n    }).join('\\n' + '  ');\n    var toCases = values.map(function (value) {\n      return \"case \" + enumName + \"::\" + convertValueToEnumOption(value) + \": return \\\"\" + value + \"\\\";\";\n    }).join('\\n' + '    ');\n    return enumTemplate.replace(/::_ENUM_NAME_::/g, enumName).replace('::_VALUES_::', values.map(toSafeCppString).join(', ')).replace('::_FROM_CASES_::', fromCases).replace('::_TO_CASES_::', toCases);\n  }\n\n  return '';\n}\n\nfunction generateIntEnum(componentName, prop) {\n  var typeAnnotation = prop.typeAnnotation;\n\n  if (typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n    var values = typeAnnotation.options.map(function (option) {\n      return option.value;\n    });\n    var enumName = getEnumName(componentName, prop.name);\n    var fromCases = values.map(function (value) {\n      return \"\\n    case \" + value + \":\\n      result = \" + enumName + \"::\" + toIntEnumValueName(prop.name, value) + \";\\n      return;\";\n    }).join('');\n    var toCases = values.map(function (value) {\n      return \"case \" + enumName + \"::\" + toIntEnumValueName(prop.name, value) + \": return \\\"\" + value + \"\\\";\";\n    }).join('\\n' + '    ');\n    var valueVariables = values.map(function (val) {\n      return toIntEnumValueName(prop.name, val) + \" = \" + val;\n    }).join(', ');\n    return intEnumTemplate.replace(/::_ENUM_NAME_::/g, enumName).replace('::_VALUES_::', valueVariables).replace('::_FROM_CASES_::', fromCases).replace('::_TO_CASES_::', toCases);\n  }\n\n  return '';\n}\n\nfunction generateEnumString(componentName, component) {\n  return component.props.map(function (prop) {\n    if (prop.typeAnnotation.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.type === 'StringEnumTypeAnnotation') {\n      return generateArrayEnumString(componentName, prop.name, prop.typeAnnotation.elementType.options);\n    }\n\n    if (prop.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n      return generateStringEnum(componentName, prop);\n    }\n\n    if (prop.typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n      return generateIntEnum(componentName, prop);\n    }\n\n    if (prop.typeAnnotation.type === 'ObjectTypeAnnotation') {\n      return prop.typeAnnotation.properties.map(function (property) {\n        if (property.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n          return generateStringEnum(componentName, property);\n        } else if (property.typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n          return generateIntEnum(componentName, property);\n        }\n\n        return null;\n      }).filter(Boolean).join('\\n');\n    }\n  }).filter(Boolean).join('\\n');\n}\n\nfunction generatePropsString(componentName, props) {\n  return props.map(function (prop) {\n    var nativeType = getNativeTypeFromAnnotation(componentName, prop, []);\n    var defaultValue = convertDefaultTypeToString(componentName, prop);\n    return nativeType + \" \" + prop.name + \"{\" + defaultValue + \"};\";\n  }).join('\\n' + '  ');\n}\n\nfunction getExtendsImports(extendsProps) {\n  var imports = new Set();\n  extendsProps.forEach(function (extendProps) {\n    switch (extendProps.type) {\n      case 'ReactNativeBuiltInType':\n        switch (extendProps.knownTypeName) {\n          case 'ReactNativeCoreViewProps':\n            imports.add('#include <react/components/view/ViewProps.h>');\n            return;\n\n          default:\n            extendProps.knownTypeName;\n            throw new Error('Invalid knownTypeName');\n        }\n\n      default:\n        extendProps.type;\n        throw new Error('Invalid extended type');\n    }\n  });\n  return imports;\n}\n\nfunction getLocalImports(properties) {\n  var imports = new Set();\n\n  function addImportsForNativeName(name) {\n    switch (name) {\n      case 'ColorPrimitive':\n        imports.add('#include <react/graphics/Color.h>');\n        return;\n\n      case 'ImageSourcePrimitive':\n        imports.add('#include <react/imagemanager/primitives.h>');\n        return;\n\n      case 'PointPrimitive':\n        imports.add('#include <react/graphics/Geometry.h>');\n        return;\n\n      case 'EdgeInsetsPrimitive':\n        imports.add('#include <react/graphics/Geometry.h>');\n        return;\n\n      default:\n        name;\n        throw new Error(\"Invalid NativePrimitiveTypeAnnotation name, got \" + name);\n    }\n  }\n\n  properties.forEach(function (prop) {\n    var typeAnnotation = prop.typeAnnotation;\n\n    if (typeAnnotation.type === 'NativePrimitiveTypeAnnotation') {\n      addImportsForNativeName(typeAnnotation.name);\n    }\n\n    if (typeAnnotation.type === 'ArrayTypeAnnotation') {\n      imports.add('#include <vector>');\n\n      if (typeAnnotation.elementType.type === 'StringEnumTypeAnnotation') {\n        imports.add('#include <cinttypes>');\n      }\n    }\n\n    if (typeAnnotation.type === 'ArrayTypeAnnotation' && typeAnnotation.elementType.type === 'NativePrimitiveTypeAnnotation') {\n      addImportsForNativeName(typeAnnotation.elementType.name);\n    }\n\n    if (typeAnnotation.type === 'ArrayTypeAnnotation' && typeAnnotation.elementType.type === 'ObjectTypeAnnotation') {\n      var objectProps = typeAnnotation.elementType.properties;\n      var objectImports = getImports(objectProps);\n      var localImports = getLocalImports(objectProps);\n      objectImports.forEach(imports.add, imports);\n      localImports.forEach(imports.add, imports);\n    }\n\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      imports.add('#include <react/core/propsConversions.h>');\n\n      var _objectImports = getImports(typeAnnotation.properties);\n\n      var _localImports = getLocalImports(typeAnnotation.properties);\n\n      _objectImports.forEach(imports.add, imports);\n\n      _localImports.forEach(imports.add, imports);\n    }\n  });\n  return imports;\n}\n\nfunction generateStructsForComponent(componentName, component) {\n  var structs = generateStructs(componentName, component.props, []);\n  var structArray = Array.from(structs.values());\n\n  if (structArray.length < 1) {\n    return '';\n  }\n\n  return structArray.join('\\n\\n');\n}\n\nfunction generateStructs(componentName, properties, nameParts) {\n  var structs = new Map();\n  properties.forEach(function (prop) {\n    var typeAnnotation = prop.typeAnnotation;\n\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      var elementProperties = typeAnnotation.properties;\n      var nestedStructs = generateStructs(componentName, elementProperties, nameParts.concat([prop.name]));\n      nestedStructs.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n      generateStruct(structs, componentName, nameParts.concat([prop.name]), typeAnnotation.properties);\n    }\n\n    if (prop.typeAnnotation.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.type === 'ObjectTypeAnnotation') {\n      var _elementProperties = prop.typeAnnotation.elementType.properties;\n\n      var _nestedStructs = generateStructs(componentName, _elementProperties, nameParts.concat([prop.name]));\n\n      _nestedStructs.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n\n      generateStruct(structs, componentName, nameParts.concat([prop.name]), _elementProperties);\n      structs.set([componentName].concat(_toConsumableArray(nameParts.concat([prop.name]))).join('') + \"ArrayStruct\", arrayConversionFunction.replace(/::_STRUCT_NAME_::/g, generateStructName(componentName, nameParts.concat([prop.name]))));\n    }\n\n    if (prop.typeAnnotation.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.elementType.type === 'ObjectTypeAnnotation') {\n      var _elementProperties2 = prop.typeAnnotation.elementType.elementType.properties;\n\n      var _nestedStructs2 = generateStructs(componentName, _elementProperties2, nameParts.concat([prop.name]));\n\n      _nestedStructs2.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n\n      generateStruct(structs, componentName, nameParts.concat([prop.name]), _elementProperties2);\n      structs.set([componentName].concat(_toConsumableArray(nameParts.concat([prop.name]))).join('') + \"ArrayArrayStruct\", doubleArrayConversionFunction.replace(/::_STRUCT_NAME_::/g, generateStructName(componentName, nameParts.concat([prop.name]))));\n    }\n  });\n  return structs;\n}\n\nfunction generateStruct(structs, componentName, nameParts, properties) {\n  var structNameParts = nameParts;\n  var structName = generateStructName(componentName, structNameParts);\n  var fields = properties.map(function (property) {\n    return getNativeTypeFromAnnotation(componentName, property, structNameParts) + \" \" + property.name + \";\";\n  }).join('\\n' + '  ');\n  properties.forEach(function (property) {\n    var name = property.name;\n\n    switch (property.typeAnnotation.type) {\n      case 'BooleanTypeAnnotation':\n        return;\n\n      case 'StringTypeAnnotation':\n        return;\n\n      case 'Int32TypeAnnotation':\n        return;\n\n      case 'DoubleTypeAnnotation':\n        return;\n\n      case 'FloatTypeAnnotation':\n        return;\n\n      case 'NativePrimitiveTypeAnnotation':\n        return;\n\n      case 'ArrayTypeAnnotation':\n        return;\n\n      case 'StringEnumTypeAnnotation':\n        return;\n\n      case 'Int32EnumTypeAnnotation':\n        return;\n\n      case 'DoubleTypeAnnotation':\n        return;\n\n      case 'ObjectTypeAnnotation':\n        var props = property.typeAnnotation.properties;\n\n        if (props == null) {\n          throw new Error(\"Properties are expected for ObjectTypeAnnotation (see \" + name + \" in \" + componentName + \")\");\n        }\n\n        generateStruct(structs, componentName, nameParts.concat([name]), props);\n        return;\n\n      default:\n        property.typeAnnotation.type;\n        throw new Error(\"Received invalid component property type \" + property.typeAnnotation.type);\n    }\n  });\n  var fromCases = properties.map(function (property) {\n    var variable = property.name;\n    return \"auto \" + variable + \" = map.find(\\\"\" + property.name + \"\\\");\\n  if (\" + variable + \" != map.end()) {\\n    fromRawValue(\" + variable + \"->second, result.\" + variable + \");\\n  }\";\n  }).join('\\n  ');\n  structs.set(structName, structTemplate.replace(/::_STRUCT_NAME_::/g, structName).replace('::_FIELDS_::', fields).replace('::_FROM_CASES_::', fromCases));\n}\n\nmodule.exports = {\n  generate: function generate(libraryName, schema, moduleSpecName) {\n    var fileName = 'Props.h';\n    var allImports = new Set();\n    var componentClasses = Object.keys(schema.modules).map(function (moduleName) {\n      var components = schema.modules[moduleName].components;\n\n      if (components == null) {\n        return null;\n      }\n\n      return Object.keys(components).filter(function (componentName) {\n        var component = components[componentName];\n        return component.excludedPlatform !== 'iOS';\n      }).map(function (componentName) {\n        var component = components[componentName];\n        var newName = componentName + \"Props\";\n        var structString = generateStructsForComponent(componentName, component);\n        var enumString = generateEnumString(componentName, component);\n        var propsString = generatePropsString(componentName, component.props);\n        var extendString = getClassExtendString(component);\n        var extendsImports = getExtendsImports(component.extendsProps);\n        var imports = getLocalImports(component.props);\n        extendsImports.forEach(allImports.add, allImports);\n        imports.forEach(allImports.add, allImports);\n        var replacedTemplate = classTemplate.replace('::_ENUMS_::', enumString).replace('::_STRUCTS_::', structString).replace(/::_CLASSNAME_::/g, newName).replace('::_EXTEND_CLASSES_::', extendString).replace('::_PROPS_::', propsString).trim();\n        return replacedTemplate;\n      }).join('\\n\\n');\n    }).filter(Boolean).join('\\n\\n');\n    var replacedTemplate = template.replace(/::_COMPONENT_CLASSES_::/g, componentClasses).replace('::_IMPORTS_::', Array.from(allImports).sort().join('\\n'));\n    return new Map([[fileName, replacedTemplate]]);\n  }\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/generators/components/GeneratePropsH.js"],"names":["require","convertDefaultTypeToString","getCppTypeForAnnotation","getEnumMaskName","getEnumName","toSafeCppString","generateStructName","getImports","toIntEnumValueName","template","classTemplate","trim","enumTemplate","intEnumTemplate","structTemplate","arrayConversionFunction","doubleArrayConversionFunction","arrayEnumTemplate","getClassExtendString","component","extendString","extendsProps","map","extendProps","type","knownTypeName","Error","join","getNativeTypeFromAnnotation","componentName","prop","nameParts","typeAnnotation","name","arrayType","elementType","concat","structName","enumName","itemAnnotation","convertValueToEnumOption","value","generateArrayEnumString","enumOptions","options","option","values","index","fromCases","toCases","replace","generateStringEnum","generateIntEnum","valueVariables","val","generateEnumString","props","properties","property","filter","Boolean","generatePropsString","nativeType","defaultValue","getExtendsImports","imports","Set","forEach","add","getLocalImports","addImportsForNativeName","objectProps","objectImports","localImports","generateStructsForComponent","structs","generateStructs","structArray","Array","from","length","Map","elementProperties","nestedStructs","key","set","generateStruct","structNameParts","fields","variable","module","exports","generate","libraryName","schema","moduleSpecName","fileName","allImports","componentClasses","Object","keys","modules","moduleName","components","excludedPlatform","newName","structString","enumString","propsString","extendsImports","replacedTemplate","sort"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\n'use strict';\n\nconst {\n  convertDefaultTypeToString,\n  getCppTypeForAnnotation,\n  getEnumMaskName,\n  getEnumName,\n  toSafeCppString,\n  generateStructName,\n  getImports,\n  toIntEnumValueName,\n} = require('./CppHelpers.js');\n\nimport type {\n  ExtendsPropsShape,\n  PropTypeShape,\n  SchemaType,\n} from '../../CodegenSchema';\n\n// File path -> contents\ntype FilesOutput = Map<string, string>;\ntype StructsMap = Map<string, string>;\n\nconst template = `\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n::_IMPORTS_::\n\nnamespace facebook {\nnamespace react {\n\n::_COMPONENT_CLASSES_::\n\n} // namespace react\n} // namespace facebook\n`;\n\nconst classTemplate = `\n::_ENUMS_::\n::_STRUCTS_::\nclass ::_CLASSNAME_:: final::_EXTEND_CLASSES_:: {\n public:\n  ::_CLASSNAME_::() = default;\n  ::_CLASSNAME_::(const ::_CLASSNAME_:: &sourceProps, const RawProps &rawProps);\n\n#pragma mark - Props\n\n  ::_PROPS_::\n};\n`.trim();\n\nconst enumTemplate = `\nenum class ::_ENUM_NAME_:: { ::_VALUES_:: };\n\nstatic inline void fromRawValue(const RawValue &value, ::_ENUM_NAME_:: &result) {\n  auto string = (std::string)value;\n  ::_FROM_CASES_::\n  abort();\n}\n\nstatic inline std::string toString(const ::_ENUM_NAME_:: &value) {\n  switch (value) {\n    ::_TO_CASES_::\n  }\n}\n`.trim();\n\nconst intEnumTemplate = `\nenum class ::_ENUM_NAME_:: { ::_VALUES_:: };\n\nstatic inline void fromRawValue(const RawValue &value, ::_ENUM_NAME_:: &result) {\n  assert(value.hasType<int>());\n  auto integerValue = (int)value;\n  switch (integerValue) {::_FROM_CASES_::\n  }\n  abort();\n}\n\nstatic inline std::string toString(const ::_ENUM_NAME_:: &value) {\n  switch (value) {\n    ::_TO_CASES_::\n  }\n}\n`.trim();\n\nconst structTemplate = `struct ::_STRUCT_NAME_:: {\n  ::_FIELDS_::\n};\n\nstatic inline void fromRawValue(const RawValue &value, ::_STRUCT_NAME_:: &result) {\n  auto map = (better::map<std::string, RawValue>)value;\n\n  ::_FROM_CASES_::\n}\n\nstatic inline std::string toString(const ::_STRUCT_NAME_:: &value) {\n  return \"[Object ::_STRUCT_NAME_::]\";\n}\n`.trim();\n\nconst arrayConversionFunction = `static inline void fromRawValue(const RawValue &value, std::vector<::_STRUCT_NAME_::> &result) {\n  auto items = (std::vector<RawValue>)value;\n  for (const auto &item : items) {\n    ::_STRUCT_NAME_:: newItem;\n    fromRawValue(item, newItem);\n    result.emplace_back(newItem);\n  }\n}\n`;\n\nconst doubleArrayConversionFunction = `static inline void fromRawValue(const RawValue &value, std::vector<std::vector<::_STRUCT_NAME_::>> &result) {\n  auto items = (std::vector<std::vector<RawValue>>)value;\n  for (const std::vector<RawValue> &item : items) {\n    auto nestedArray = std::vector<::_STRUCT_NAME_::>{};\n    for (const RawValue &nestedItem : item) {\n      ::_STRUCT_NAME_:: newItem;\n      fromRawValue(nestedItem, newItem);\n      nestedArray.emplace_back(newItem);\n    }\n    result.emplace_back(nestedArray);\n  }\n}\n`;\n\nconst arrayEnumTemplate = `\nusing ::_ENUM_MASK_:: = uint32_t;\n\nenum class ::_ENUM_NAME_::: ::_ENUM_MASK_:: {\n  ::_VALUES_::\n};\n\nconstexpr bool operator&(\n  ::_ENUM_MASK_:: const lhs,\n  enum ::_ENUM_NAME_:: const rhs) {\n  return lhs & static_cast<::_ENUM_MASK_::>(rhs);\n}\n\nconstexpr ::_ENUM_MASK_:: operator|(\n  ::_ENUM_MASK_:: const lhs,\n  enum ::_ENUM_NAME_:: const rhs) {\n  return lhs | static_cast<::_ENUM_MASK_::>(rhs);\n}\n\nconstexpr void operator|=(\n  ::_ENUM_MASK_:: &lhs,\n  enum ::_ENUM_NAME_:: const rhs) {\n  lhs = lhs | static_cast<::_ENUM_MASK_::>(rhs);\n}\n\nstatic inline void fromRawValue(const RawValue &value, ::_ENUM_MASK_:: &result) {\n  auto items = std::vector<std::string>{value};\n  for (const auto &item : items) {\n    ::_FROM_CASES_::\n    abort();\n  }\n}\n\nstatic inline std::string toString(const ::_ENUM_MASK_:: &value) {\n    auto result = std::string{};\n    auto separator = std::string{\", \"};\n\n    ::_TO_CASES_::\n    if (!result.empty()) {\n      result.erase(result.length() - separator.length());\n    }\n    return result;\n}\n`.trim();\n\nfunction getClassExtendString(component): string {\n  const extendString =\n    ' : ' +\n    component.extendsProps\n      .map(extendProps => {\n        switch (extendProps.type) {\n          case 'ReactNativeBuiltInType':\n            switch (extendProps.knownTypeName) {\n              case 'ReactNativeCoreViewProps':\n                return 'public ViewProps';\n              default:\n                (extendProps.knownTypeName: empty);\n                throw new Error('Invalid knownTypeName');\n            }\n          default:\n            (extendProps.type: empty);\n            throw new Error('Invalid extended type');\n        }\n      })\n      .join(' ');\n\n  return extendString;\n}\n\nfunction getNativeTypeFromAnnotation(\n  componentName: string,\n  prop,\n  nameParts: $ReadOnlyArray<string>,\n): string {\n  const typeAnnotation = prop.typeAnnotation;\n\n  switch (typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n    case 'FloatTypeAnnotation':\n      return getCppTypeForAnnotation(typeAnnotation.type);\n    case 'NativePrimitiveTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'ColorPrimitive':\n          return 'SharedColor';\n        case 'ImageSourcePrimitive':\n          return 'ImageSource';\n        case 'PointPrimitive':\n          return 'Point';\n        case 'EdgeInsetsPrimitive':\n          return 'EdgeInsets';\n        default:\n          (typeAnnotation.name: empty);\n          throw new Error('Received unknown NativePrimitiveTypeAnnotation');\n      }\n    case 'ArrayTypeAnnotation': {\n      const arrayType = typeAnnotation.elementType.type;\n      if (arrayType === 'ArrayTypeAnnotation') {\n        return `std::vector<${getNativeTypeFromAnnotation(\n          componentName,\n          {typeAnnotation: typeAnnotation.elementType, name: ''},\n          nameParts.concat([prop.name]),\n        )}>`;\n      }\n      if (arrayType === 'ObjectTypeAnnotation') {\n        const structName = generateStructName(\n          componentName,\n          nameParts.concat([prop.name]),\n        );\n        return `std::vector<${structName}>`;\n      }\n      if (arrayType === 'StringEnumTypeAnnotation') {\n        const enumName = getEnumName(componentName, prop.name);\n        return getEnumMaskName(enumName);\n      }\n      const itemAnnotation = getNativeTypeFromAnnotation(\n        componentName,\n        {\n          typeAnnotation: typeAnnotation.elementType,\n          name: componentName,\n        },\n        nameParts.concat([prop.name]),\n      );\n      return `std::vector<${itemAnnotation}>`;\n    }\n    case 'ObjectTypeAnnotation': {\n      return generateStructName(componentName, nameParts.concat([prop.name]));\n    }\n    case 'StringEnumTypeAnnotation':\n      return getEnumName(componentName, prop.name);\n    case 'Int32EnumTypeAnnotation':\n      return getEnumName(componentName, prop.name);\n    default:\n      (typeAnnotation: empty);\n      throw new Error(\n        `Received invalid typeAnnotation for ${componentName} prop ${\n          prop.name\n        }, received ${typeAnnotation.type}`,\n      );\n  }\n}\n\nfunction convertValueToEnumOption(value: string): string {\n  return toSafeCppString(value);\n}\n\nfunction generateArrayEnumString(\n  componentName: string,\n  name: string,\n  enumOptions,\n): string {\n  const options = enumOptions.map(option => option.name);\n  const enumName = getEnumName(componentName, name);\n\n  const values = options\n    .map((option, index) => `${toSafeCppString(option)} = 1 << ${index}`)\n    .join(',\\n  ');\n\n  const fromCases = options\n    .map(\n      option =>\n        `if (item == \"${option}\") {\n      result |= ${enumName}::${toSafeCppString(option)};\n      continue;\n    }`,\n    )\n    .join('\\n    ');\n\n  const toCases = options\n    .map(\n      option =>\n        `if (value & ${enumName}::${toSafeCppString(option)}) {\n      result += \"${option}\" + separator;\n    }`,\n    )\n    .join('\\n' + '    ');\n\n  return arrayEnumTemplate\n    .replace(/::_ENUM_NAME_::/g, enumName)\n    .replace(/::_ENUM_MASK_::/g, getEnumMaskName(enumName))\n    .replace('::_VALUES_::', values)\n    .replace('::_FROM_CASES_::', fromCases)\n    .replace('::_TO_CASES_::', toCases);\n}\n\nfunction generateStringEnum(componentName, prop) {\n  const typeAnnotation = prop.typeAnnotation;\n  if (typeAnnotation.type === 'StringEnumTypeAnnotation') {\n    const values: $ReadOnlyArray<string> = typeAnnotation.options.map(\n      option => option.name,\n    );\n    const enumName = getEnumName(componentName, prop.name);\n\n    const fromCases = values\n      .map(\n        value =>\n          `if (string == \"${value}\") { result = ${enumName}::${convertValueToEnumOption(\n            value,\n          )}; return; }`,\n      )\n      .join('\\n' + '  ');\n\n    const toCases = values\n      .map(\n        value =>\n          `case ${enumName}::${convertValueToEnumOption(\n            value,\n          )}: return \"${value}\";`,\n      )\n      .join('\\n' + '    ');\n\n    return enumTemplate\n      .replace(/::_ENUM_NAME_::/g, enumName)\n      .replace('::_VALUES_::', values.map(toSafeCppString).join(', '))\n      .replace('::_FROM_CASES_::', fromCases)\n      .replace('::_TO_CASES_::', toCases);\n  }\n\n  return '';\n}\n\nfunction generateIntEnum(componentName, prop) {\n  const typeAnnotation = prop.typeAnnotation;\n  if (typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n    const values: $ReadOnlyArray<number> = typeAnnotation.options.map(\n      option => option.value,\n    );\n    const enumName = getEnumName(componentName, prop.name);\n\n    const fromCases = values\n      .map(\n        value =>\n          `\n    case ${value}:\n      result = ${enumName}::${toIntEnumValueName(prop.name, value)};\n      return;`,\n      )\n      .join('');\n\n    const toCases = values\n      .map(\n        value =>\n          `case ${enumName}::${toIntEnumValueName(\n            prop.name,\n            value,\n          )}: return \"${value}\";`,\n      )\n      .join('\\n' + '    ');\n\n    const valueVariables = values\n      .map(val => `${toIntEnumValueName(prop.name, val)} = ${val}`)\n      .join(', ');\n\n    return intEnumTemplate\n      .replace(/::_ENUM_NAME_::/g, enumName)\n      .replace('::_VALUES_::', valueVariables)\n      .replace('::_FROM_CASES_::', fromCases)\n      .replace('::_TO_CASES_::', toCases);\n  }\n\n  return '';\n}\n\nfunction generateEnumString(componentName: string, component): string {\n  return component.props\n    .map(prop => {\n      if (\n        prop.typeAnnotation.type === 'ArrayTypeAnnotation' &&\n        prop.typeAnnotation.elementType.type === 'StringEnumTypeAnnotation'\n      ) {\n        return generateArrayEnumString(\n          componentName,\n          prop.name,\n          prop.typeAnnotation.elementType.options,\n        );\n      }\n\n      if (prop.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n        return generateStringEnum(componentName, prop);\n      }\n\n      if (prop.typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n        return generateIntEnum(componentName, prop);\n      }\n\n      if (prop.typeAnnotation.type === 'ObjectTypeAnnotation') {\n        return prop.typeAnnotation.properties\n          .map(property => {\n            if (property.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n              return generateStringEnum(componentName, property);\n            } else if (\n              property.typeAnnotation.type === 'Int32EnumTypeAnnotation'\n            ) {\n              return generateIntEnum(componentName, property);\n            }\n            return null;\n          })\n          .filter(Boolean)\n          .join('\\n');\n      }\n    })\n    .filter(Boolean)\n    .join('\\n');\n}\n\nfunction generatePropsString(\n  componentName: string,\n  props: $ReadOnlyArray<PropTypeShape>,\n) {\n  return props\n    .map(prop => {\n      const nativeType = getNativeTypeFromAnnotation(componentName, prop, []);\n      const defaultValue = convertDefaultTypeToString(componentName, prop);\n\n      return `${nativeType} ${prop.name}{${defaultValue}};`;\n    })\n    .join('\\n' + '  ');\n}\n\nfunction getExtendsImports(\n  extendsProps: $ReadOnlyArray<ExtendsPropsShape>,\n): Set<string> {\n  const imports: Set<string> = new Set();\n\n  extendsProps.forEach(extendProps => {\n    switch (extendProps.type) {\n      case 'ReactNativeBuiltInType':\n        switch (extendProps.knownTypeName) {\n          case 'ReactNativeCoreViewProps':\n            imports.add('#include <react/components/view/ViewProps.h>');\n            return;\n          default:\n            (extendProps.knownTypeName: empty);\n            throw new Error('Invalid knownTypeName');\n        }\n      default:\n        (extendProps.type: empty);\n        throw new Error('Invalid extended type');\n    }\n  });\n\n  return imports;\n}\n\nfunction getLocalImports(\n  properties: $ReadOnlyArray<PropTypeShape>,\n): Set<string> {\n  const imports: Set<string> = new Set();\n\n  function addImportsForNativeName(name) {\n    switch (name) {\n      case 'ColorPrimitive':\n        imports.add('#include <react/graphics/Color.h>');\n        return;\n      case 'ImageSourcePrimitive':\n        imports.add('#include <react/imagemanager/primitives.h>');\n        return;\n      case 'PointPrimitive':\n        imports.add('#include <react/graphics/Geometry.h>');\n        return;\n      case 'EdgeInsetsPrimitive':\n        imports.add('#include <react/graphics/Geometry.h>');\n        return;\n      default:\n        (name: empty);\n        throw new Error(\n          `Invalid NativePrimitiveTypeAnnotation name, got ${name}`,\n        );\n    }\n  }\n\n  properties.forEach(prop => {\n    const typeAnnotation = prop.typeAnnotation;\n\n    if (typeAnnotation.type === 'NativePrimitiveTypeAnnotation') {\n      addImportsForNativeName(typeAnnotation.name);\n    }\n\n    if (typeAnnotation.type === 'ArrayTypeAnnotation') {\n      imports.add('#include <vector>');\n      if (typeAnnotation.elementType.type === 'StringEnumTypeAnnotation') {\n        imports.add('#include <cinttypes>');\n      }\n    }\n\n    if (\n      typeAnnotation.type === 'ArrayTypeAnnotation' &&\n      typeAnnotation.elementType.type === 'NativePrimitiveTypeAnnotation'\n    ) {\n      addImportsForNativeName(typeAnnotation.elementType.name);\n    }\n\n    if (\n      typeAnnotation.type === 'ArrayTypeAnnotation' &&\n      typeAnnotation.elementType.type === 'ObjectTypeAnnotation'\n    ) {\n      const objectProps = typeAnnotation.elementType.properties;\n      const objectImports = getImports(objectProps);\n      const localImports = getLocalImports(objectProps);\n      objectImports.forEach(imports.add, imports);\n      localImports.forEach(imports.add, imports);\n    }\n\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      imports.add('#include <react/core/propsConversions.h>');\n      const objectImports = getImports(typeAnnotation.properties);\n      const localImports = getLocalImports(typeAnnotation.properties);\n      objectImports.forEach(imports.add, imports);\n      localImports.forEach(imports.add, imports);\n    }\n  });\n\n  return imports;\n}\n\nfunction generateStructsForComponent(componentName: string, component): string {\n  const structs = generateStructs(componentName, component.props, []);\n  const structArray = Array.from(structs.values());\n  if (structArray.length < 1) {\n    return '';\n  }\n  return structArray.join('\\n\\n');\n}\n\nfunction generateStructs(\n  componentName: string,\n  properties,\n  nameParts,\n): StructsMap {\n  const structs: StructsMap = new Map();\n  properties.forEach(prop => {\n    const typeAnnotation = prop.typeAnnotation;\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      // Recursively visit all of the object properties.\n      // Note: this is depth first so that the nested structs are ordered first.\n      const elementProperties = typeAnnotation.properties;\n      const nestedStructs = generateStructs(\n        componentName,\n        elementProperties,\n        nameParts.concat([prop.name]),\n      );\n      nestedStructs.forEach(function(value, key) {\n        structs.set(key, value);\n      });\n\n      generateStruct(\n        structs,\n        componentName,\n        nameParts.concat([prop.name]),\n        typeAnnotation.properties,\n      );\n    }\n\n    if (\n      prop.typeAnnotation.type === 'ArrayTypeAnnotation' &&\n      prop.typeAnnotation.elementType.type === 'ObjectTypeAnnotation'\n    ) {\n      // Recursively visit all of the object properties.\n      // Note: this is depth first so that the nested structs are ordered first.\n      const elementProperties = prop.typeAnnotation.elementType.properties;\n      const nestedStructs = generateStructs(\n        componentName,\n        elementProperties,\n        nameParts.concat([prop.name]),\n      );\n      nestedStructs.forEach(function(value, key) {\n        structs.set(key, value);\n      });\n\n      // Generate this struct and its conversion function.\n      generateStruct(\n        structs,\n        componentName,\n        nameParts.concat([prop.name]),\n        elementProperties,\n      );\n\n      // Generate the conversion function for std:vector<Object>.\n      // Note: This needs to be at the end since it references the struct above.\n      structs.set(\n        `${[componentName, ...nameParts.concat([prop.name])].join(\n          '',\n        )}ArrayStruct`,\n        arrayConversionFunction.replace(\n          /::_STRUCT_NAME_::/g,\n          generateStructName(componentName, nameParts.concat([prop.name])),\n        ),\n      );\n    }\n    if (\n      prop.typeAnnotation.type === 'ArrayTypeAnnotation' &&\n      prop.typeAnnotation.elementType.type === 'ArrayTypeAnnotation' &&\n      prop.typeAnnotation.elementType.elementType.type ===\n        'ObjectTypeAnnotation'\n    ) {\n      // Recursively visit all of the object properties.\n      // Note: this is depth first so that the nested structs are ordered first.\n      const elementProperties =\n        prop.typeAnnotation.elementType.elementType.properties;\n      const nestedStructs = generateStructs(\n        componentName,\n        elementProperties,\n        nameParts.concat([prop.name]),\n      );\n      nestedStructs.forEach(function(value, key) {\n        structs.set(key, value);\n      });\n\n      // Generate this struct and its conversion function.\n      generateStruct(\n        structs,\n        componentName,\n        nameParts.concat([prop.name]),\n        elementProperties,\n      );\n\n      // Generate the conversion function for std:vector<Object>.\n      // Note: This needs to be at the end since it references the struct above.\n      structs.set(\n        `${[componentName, ...nameParts.concat([prop.name])].join(\n          '',\n        )}ArrayArrayStruct`,\n        doubleArrayConversionFunction.replace(\n          /::_STRUCT_NAME_::/g,\n          generateStructName(componentName, nameParts.concat([prop.name])),\n        ),\n      );\n    }\n  });\n\n  return structs;\n}\n\nfunction generateStruct(\n  structs: StructsMap,\n  componentName: string,\n  nameParts: $ReadOnlyArray<string>,\n  properties: $ReadOnlyArray<PropTypeShape>,\n): void {\n  const structNameParts = nameParts;\n  const structName = generateStructName(componentName, structNameParts);\n\n  const fields = properties\n    .map(property => {\n      return `${getNativeTypeFromAnnotation(\n        componentName,\n        property,\n        structNameParts,\n      )} ${property.name};`;\n    })\n    .join('\\n' + '  ');\n\n  properties.forEach((property: PropTypeShape) => {\n    const name = property.name;\n    switch (property.typeAnnotation.type) {\n      case 'BooleanTypeAnnotation':\n        return;\n      case 'StringTypeAnnotation':\n        return;\n      case 'Int32TypeAnnotation':\n        return;\n      case 'DoubleTypeAnnotation':\n        return;\n      case 'FloatTypeAnnotation':\n        return;\n      case 'NativePrimitiveTypeAnnotation':\n        return;\n      case 'ArrayTypeAnnotation':\n        return;\n      case 'StringEnumTypeAnnotation':\n        return;\n      case 'Int32EnumTypeAnnotation':\n        return;\n      case 'DoubleTypeAnnotation':\n        return;\n      case 'ObjectTypeAnnotation':\n        const props = property.typeAnnotation.properties;\n        if (props == null) {\n          throw new Error(\n            `Properties are expected for ObjectTypeAnnotation (see ${name} in ${componentName})`,\n          );\n        }\n        generateStruct(structs, componentName, nameParts.concat([name]), props);\n        return;\n      default:\n        (property.typeAnnotation.type: empty);\n        throw new Error(\n          `Received invalid component property type ${\n            property.typeAnnotation.type\n          }`,\n        );\n    }\n  });\n\n  const fromCases = properties\n    .map(property => {\n      const variable = property.name;\n      return `auto ${variable} = map.find(\"${property.name}\");\n  if (${variable} != map.end()) {\n    fromRawValue(${variable}->second, result.${variable});\n  }`;\n    })\n    .join('\\n  ');\n\n  structs.set(\n    structName,\n    structTemplate\n      .replace(/::_STRUCT_NAME_::/g, structName)\n      .replace('::_FIELDS_::', fields)\n      .replace('::_FROM_CASES_::', fromCases),\n  );\n}\n\nmodule.exports = {\n  generate(\n    libraryName: string,\n    schema: SchemaType,\n    moduleSpecName: string,\n  ): FilesOutput {\n    const fileName = 'Props.h';\n\n    const allImports: Set<string> = new Set();\n\n    const componentClasses = Object.keys(schema.modules)\n      .map(moduleName => {\n        const components = schema.modules[moduleName].components;\n        // No components in this module\n        if (components == null) {\n          return null;\n        }\n\n        return Object.keys(components)\n          .filter(componentName => {\n            const component = components[componentName];\n            return component.excludedPlatform !== 'iOS';\n          })\n          .map(componentName => {\n            const component = components[componentName];\n\n            const newName = `${componentName}Props`;\n            const structString = generateStructsForComponent(\n              componentName,\n              component,\n            );\n            const enumString = generateEnumString(componentName, component);\n            const propsString = generatePropsString(\n              componentName,\n              component.props,\n            );\n            const extendString = getClassExtendString(component);\n            const extendsImports = getExtendsImports(component.extendsProps);\n            const imports = getLocalImports(component.props);\n\n            extendsImports.forEach(allImports.add, allImports);\n            imports.forEach(allImports.add, allImports);\n\n            const replacedTemplate = classTemplate\n              .replace('::_ENUMS_::', enumString)\n              .replace('::_STRUCTS_::', structString)\n              .replace(/::_CLASSNAME_::/g, newName)\n              .replace('::_EXTEND_CLASSES_::', extendString)\n              .replace('::_PROPS_::', propsString)\n              .trim();\n\n            return replacedTemplate;\n          })\n          .join('\\n\\n');\n      })\n      .filter(Boolean)\n      .join('\\n\\n');\n\n    const replacedTemplate = template\n      .replace(/::_COMPONENT_CLASSES_::/g, componentClasses)\n      .replace(\n        '::_IMPORTS_::',\n        Array.from(allImports)\n          .sort()\n          .join('\\n'),\n      );\n\n    return new Map([[fileName, replacedTemplate]]);\n  },\n};\n"]},"metadata":{},"sourceType":"script"}