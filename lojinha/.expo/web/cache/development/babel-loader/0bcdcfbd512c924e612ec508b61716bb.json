{"ast":null,"code":"'use strict';\n\nvar _require = require(\"../utils.js\"),\n    getValueFromTypes = _require.getValueFromTypes;\n\nfunction getObjectProperties(name, objectParam, paramName, types) {\n  return objectParam.properties.map(function (objectTypeProperty) {\n    var optional = objectTypeProperty.optional;\n    var value = objectTypeProperty.value;\n\n    if (value.type === 'NullableTypeAnnotation') {\n      if (objectTypeProperty.value.typeAnnotation.type !== 'StringTypeAnnotation') {\n        optional = true;\n      }\n\n      value = objectTypeProperty.value.typeAnnotation;\n    }\n\n    return {\n      optional: optional,\n      name: objectTypeProperty.key.name,\n      typeAnnotation: getElementTypeForArrayOrObject(name, value, paramName, types)\n    };\n  });\n}\n\nfunction getElementTypeForArrayOrObject(name, arrayParam, paramName, types) {\n  var typeAnnotation = getValueFromTypes(arrayParam, types);\n  var type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n\n  switch (type) {\n    case 'Array':\n    case '$ReadOnlyArray':\n      if (typeAnnotation.typeParameters && typeAnnotation.typeParameters.params[0]) {\n        return {\n          type: 'ArrayTypeAnnotation',\n          elementType: getElementTypeForArrayOrObject(name, typeAnnotation.typeParameters.params[0], 'returning value', types)\n        };\n      } else {\n        throw new Error(\"Unsupported type for \" + name + \", param: \\\"\" + paramName + \"\\\": expected to find annotation for type of nested array contents\");\n      }\n\n    case 'ObjectTypeAnnotation':\n      return {\n        type: 'ObjectTypeAnnotation',\n        properties: getObjectProperties(name, typeAnnotation, paramName, types)\n      };\n\n    case '$ReadOnly':\n      if (typeAnnotation.typeParameters.params && typeAnnotation.typeParameters.params[0]) {\n        return {\n          type: 'ObjectTypeAnnotation',\n          properties: getObjectProperties(name, typeAnnotation.typeParameters.params[0], paramName, types)\n        };\n      } else {\n        throw new Error(\"Unsupported param for method \\\"\" + name + \"\\\", param \\\"\" + paramName + \"\\\". No type specified for $ReadOnly\");\n      }\n\n    case 'AnyTypeAnnotation':\n      return {\n        type: type\n      };\n\n    case 'NumberTypeAnnotation':\n    case 'BooleanTypeAnnotation':\n      return {\n        type: type\n      };\n\n    case 'StringTypeAnnotation':\n    case 'Stringish':\n      return {\n        type: 'StringTypeAnnotation'\n      };\n\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation'\n      };\n\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation'\n      };\n\n    case 'TupleTypeAnnotation':\n    case 'UnionTypeAnnotation':\n      return undefined;\n\n    default:\n      return {\n        type: 'GenericObjectTypeAnnotation'\n      };\n  }\n}\n\nfunction getTypeAnnotationForParam(name, paramAnnotation, types) {\n  var param = paramAnnotation;\n\n  if (param.name === null) {\n    throw new Error(\"Unsupported type for \" + name + \". Please provide a name for every parameter.\");\n  }\n\n  var paramName = param.name.name;\n  var nullable = false;\n\n  if (param.typeAnnotation.type === 'NullableTypeAnnotation') {\n    nullable = true;\n    param = paramAnnotation.typeAnnotation;\n  }\n\n  var typeAnnotation = getValueFromTypes(param.typeAnnotation, types);\n  var type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n\n  switch (type) {\n    case 'Array':\n    case '$ReadOnlyArray':\n      if (typeAnnotation.typeParameters && typeAnnotation.typeParameters.params[0]) {\n        return {\n          name: paramName,\n          nullable: nullable,\n          typeAnnotation: {\n            type: 'ArrayTypeAnnotation',\n            elementType: getElementTypeForArrayOrObject(name, typeAnnotation.typeParameters.params[0], paramName, types)\n          }\n        };\n      } else {\n        throw new Error(\"Unsupported type for \" + name + \", param: \\\"\" + paramName + \"\\\": expected to find annotation for type of array contents\");\n      }\n\n    case 'ObjectTypeAnnotation':\n      return {\n        nullable: nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'ObjectTypeAnnotation',\n          properties: getObjectProperties(name, typeAnnotation, paramName, types)\n        }\n      };\n\n    case '$ReadOnly':\n      if (typeAnnotation.typeParameters.params && typeAnnotation.typeParameters.params[0]) {\n        return {\n          nullable: nullable,\n          name: paramName,\n          typeAnnotation: {\n            type: 'ObjectTypeAnnotation',\n            properties: getObjectProperties(name, typeAnnotation.typeParameters.params[0], paramName, types)\n          }\n        };\n      } else {\n        throw new Error(\"Unsupported param for method \\\"\" + name + \"\\\", param \\\"\" + paramName + \"\\\". No type specified for $ReadOnly\");\n      }\n\n    case 'FunctionTypeAnnotation':\n      return {\n        name: paramName,\n        nullable: nullable,\n        typeAnnotation: {\n          type: 'FunctionTypeAnnotation'\n        }\n      };\n\n    case 'NumberTypeAnnotation':\n    case 'BooleanTypeAnnotation':\n      return {\n        nullable: nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: type\n        }\n      };\n\n    case 'StringTypeAnnotation':\n    case 'Stringish':\n      return {\n        nullable: nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation'\n        }\n      };\n\n    case 'Int32':\n      return {\n        nullable: nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'Int32TypeAnnotation'\n        }\n      };\n\n    case 'Float':\n      return {\n        nullable: nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'FloatTypeAnnotation'\n        }\n      };\n\n    default:\n      return {\n        nullable: nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'GenericObjectTypeAnnotation'\n        }\n      };\n  }\n}\n\nfunction getReturnTypeAnnotation(methodName, returnType, types) {\n  var typeAnnotation = getValueFromTypes(returnType, types);\n  var nullable = false;\n\n  if (typeAnnotation.type === 'NullableTypeAnnotation') {\n    nullable = true;\n    typeAnnotation = typeAnnotation.typeAnnotation;\n  }\n\n  var type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n\n  switch (type) {\n    case 'Promise':\n      if (typeAnnotation.typeParameters && typeAnnotation.typeParameters.params[0]) {\n        return {\n          type: 'GenericPromiseTypeAnnotation',\n          nullable: nullable\n        };\n      } else {\n        throw new Error(\"Unsupported return promise type for \" + methodName + \": expected to find annotation for type of promise content\");\n      }\n\n    case 'Array':\n    case '$ReadOnlyArray':\n      if (typeAnnotation.typeParameters && typeAnnotation.typeParameters.params[0]) {\n        return {\n          nullable: nullable,\n          type: 'ArrayTypeAnnotation',\n          elementType: getElementTypeForArrayOrObject(methodName, typeAnnotation.typeParameters.params[0], 'returning value', types)\n        };\n      } else {\n        throw new Error(\"Unsupported return type for \" + methodName + \": expected to find annotation for type of array contents\");\n      }\n\n    case 'ObjectTypeAnnotation':\n      return {\n        nullable: nullable,\n        type: 'ObjectTypeAnnotation',\n        properties: getObjectProperties(methodName, typeAnnotation, 'returning value', types)\n      };\n\n    case '$ReadOnly':\n      if (typeAnnotation.typeParameters.params && typeAnnotation.typeParameters.params[0]) {\n        return {\n          nullable: nullable,\n          type: 'ObjectTypeAnnotation',\n          properties: getObjectProperties(methodName, typeAnnotation.typeParameters.params[0], 'returning value', types)\n        };\n      } else {\n        throw new Error(\"Unsupported return type for method \\\"\" + methodName + \"\\\", No type specified for $ReadOnly\");\n      }\n\n    case 'BooleanTypeAnnotation':\n    case 'NumberTypeAnnotation':\n    case 'VoidTypeAnnotation':\n      return {\n        nullable: nullable,\n        type: type\n      };\n\n    case 'StringTypeAnnotation':\n    case 'Stringish':\n      return {\n        nullable: nullable,\n        type: 'StringTypeAnnotation'\n      };\n\n    case 'Int32':\n      return {\n        nullable: nullable,\n        type: 'Int32TypeAnnotation'\n      };\n\n    case 'Float':\n      return {\n        nullable: nullable,\n        type: 'FloatTypeAnnotation'\n      };\n\n    default:\n      return {\n        type: 'GenericObjectTypeAnnotation',\n        nullable: nullable\n      };\n  }\n}\n\nfunction buildMethodSchema(property, types) {\n  var name = property.key.name;\n  var value = getValueFromTypes(property.value, types);\n\n  if (value.type !== 'FunctionTypeAnnotation') {\n    throw new Error(\"Only methods are supported as module properties. Found \" + value.type + \" in \" + property.key.name);\n  }\n\n  var params = value.params.map(function (param) {\n    return getTypeAnnotationForParam(name, param, types);\n  });\n  var returnTypeAnnotation = getReturnTypeAnnotation(name, getValueFromTypes(value.returnType, types), types);\n  return {\n    name: name,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      returnTypeAnnotation: returnTypeAnnotation,\n      params: params,\n      optional: property.optional\n    }\n  };\n}\n\nfunction getMethods(typeDefinition, types) {\n  return typeDefinition.filter(function (property) {\n    return property.type === 'ObjectTypeProperty';\n  }).map(function (property) {\n    return buildMethodSchema(property, types);\n  }).filter(Boolean);\n}\n\nmodule.exports = {\n  getMethods: getMethods\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/parsers/flow/modules/methods.js"],"names":["require","getValueFromTypes","getObjectProperties","name","objectParam","paramName","types","properties","map","objectTypeProperty","optional","value","type","typeAnnotation","key","getElementTypeForArrayOrObject","arrayParam","id","typeParameters","params","elementType","Error","undefined","getTypeAnnotationForParam","paramAnnotation","param","nullable","getReturnTypeAnnotation","methodName","returnType","buildMethodSchema","property","returnTypeAnnotation","getMethods","typeDefinition","filter","Boolean","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport type {\n  MethodTypeShape,\n  FunctionTypeAnnotationParam,\n  FunctionTypeAnnotationReturn,\n  FunctionTypeAnnotationParamTypeAnnotation,\n  ObjectParamTypeAnnotation,\n} from '../../../CodegenSchema.js';\n\nimport type {TypeMap} from '../utils.js';\nconst {getValueFromTypes} = require('../utils.js');\n\n// $FlowFixMe there's no flowtype for ASTs\ntype MethodAST = Object;\n\nfunction getObjectProperties(\n  name: string,\n  objectParam,\n  paramName: string,\n  types: TypeMap,\n): $ReadOnlyArray<ObjectParamTypeAnnotation> {\n  return objectParam.properties.map(objectTypeProperty => {\n    let optional = objectTypeProperty.optional;\n    let value = objectTypeProperty.value;\n    if (value.type === 'NullableTypeAnnotation') {\n      if (\n        objectTypeProperty.value.typeAnnotation.type !== 'StringTypeAnnotation'\n      ) {\n        optional = true;\n      }\n      value = objectTypeProperty.value.typeAnnotation;\n    }\n    return {\n      optional,\n      name: objectTypeProperty.key.name,\n      typeAnnotation: getElementTypeForArrayOrObject(\n        name,\n        value,\n        paramName,\n        types,\n      ),\n    };\n  });\n}\n\nfunction getElementTypeForArrayOrObject(\n  name,\n  arrayParam,\n  paramName,\n  types: TypeMap,\n): FunctionTypeAnnotationParamTypeAnnotation | typeof undefined {\n  const typeAnnotation = getValueFromTypes(arrayParam, types);\n  const type =\n    typeAnnotation.type === 'GenericTypeAnnotation'\n      ? typeAnnotation.id.name\n      : typeAnnotation.type;\n\n  switch (type) {\n    case 'Array':\n    case '$ReadOnlyArray':\n      if (\n        typeAnnotation.typeParameters &&\n        typeAnnotation.typeParameters.params[0]\n      ) {\n        return {\n          type: 'ArrayTypeAnnotation',\n          elementType: getElementTypeForArrayOrObject(\n            name,\n            typeAnnotation.typeParameters.params[0],\n            'returning value',\n            types,\n          ),\n        };\n      } else {\n        throw new Error(\n          `Unsupported type for ${name}, param: \"${paramName}\": expected to find annotation for type of nested array contents`,\n        );\n      }\n    case 'ObjectTypeAnnotation':\n      return {\n        type: 'ObjectTypeAnnotation',\n        properties: getObjectProperties(name, typeAnnotation, paramName, types),\n      };\n    case '$ReadOnly':\n      if (\n        typeAnnotation.typeParameters.params &&\n        typeAnnotation.typeParameters.params[0]\n      ) {\n        return {\n          type: 'ObjectTypeAnnotation',\n          properties: getObjectProperties(\n            name,\n            typeAnnotation.typeParameters.params[0],\n            paramName,\n            types,\n          ),\n        };\n      } else {\n        throw new Error(\n          `Unsupported param for method \"${name}\", param \"${paramName}\". No type specified for $ReadOnly`,\n        );\n      }\n    case 'AnyTypeAnnotation':\n      return {\n        type,\n      };\n    case 'NumberTypeAnnotation':\n    case 'BooleanTypeAnnotation':\n      return {\n        type,\n      };\n    case 'StringTypeAnnotation':\n    case 'Stringish':\n      return {\n        type: 'StringTypeAnnotation',\n      };\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n      };\n    case 'TupleTypeAnnotation':\n    case 'UnionTypeAnnotation':\n      return undefined;\n    default:\n      return {\n        type: 'GenericObjectTypeAnnotation',\n      };\n  }\n}\n\nfunction getTypeAnnotationForParam(\n  name: string,\n  paramAnnotation,\n  types: TypeMap,\n): FunctionTypeAnnotationParam {\n  let param = paramAnnotation;\n  if (param.name === null) {\n    throw new Error(\n      `Unsupported type for ${name}. Please provide a name for every parameter.`,\n    );\n  }\n  let paramName = param.name.name;\n  let nullable = false;\n  if (param.typeAnnotation.type === 'NullableTypeAnnotation') {\n    nullable = true;\n    param = paramAnnotation.typeAnnotation;\n  }\n\n  const typeAnnotation = getValueFromTypes(param.typeAnnotation, types);\n  const type =\n    typeAnnotation.type === 'GenericTypeAnnotation'\n      ? typeAnnotation.id.name\n      : typeAnnotation.type;\n\n  switch (type) {\n    case 'Array':\n    case '$ReadOnlyArray':\n      if (\n        typeAnnotation.typeParameters &&\n        typeAnnotation.typeParameters.params[0]\n      ) {\n        return {\n          name: paramName,\n          nullable,\n          typeAnnotation: {\n            type: 'ArrayTypeAnnotation',\n            elementType: getElementTypeForArrayOrObject(\n              name,\n              typeAnnotation.typeParameters.params[0],\n              paramName,\n              types,\n            ),\n          },\n        };\n      } else {\n        throw new Error(\n          `Unsupported type for ${name}, param: \"${paramName}\": expected to find annotation for type of array contents`,\n        );\n      }\n    case 'ObjectTypeAnnotation':\n      return {\n        nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'ObjectTypeAnnotation',\n          properties: getObjectProperties(\n            name,\n            typeAnnotation,\n            paramName,\n            types,\n          ),\n        },\n      };\n    case '$ReadOnly':\n      if (\n        typeAnnotation.typeParameters.params &&\n        typeAnnotation.typeParameters.params[0]\n      ) {\n        return {\n          nullable,\n          name: paramName,\n          typeAnnotation: {\n            type: 'ObjectTypeAnnotation',\n            properties: getObjectProperties(\n              name,\n              typeAnnotation.typeParameters.params[0],\n              paramName,\n              types,\n            ),\n          },\n        };\n      } else {\n        throw new Error(\n          `Unsupported param for method \"${name}\", param \"${paramName}\". No type specified for $ReadOnly`,\n        );\n      }\n    case 'FunctionTypeAnnotation':\n      return {\n        name: paramName,\n        nullable,\n        typeAnnotation: {\n          type: 'FunctionTypeAnnotation',\n        },\n      };\n    case 'NumberTypeAnnotation':\n    case 'BooleanTypeAnnotation':\n      return {\n        nullable,\n        name: paramName,\n        typeAnnotation: {\n          type,\n        },\n      };\n\n    case 'StringTypeAnnotation':\n    case 'Stringish':\n      return {\n        nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation',\n        },\n      };\n    case 'Int32':\n      return {\n        nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'Int32TypeAnnotation',\n        },\n      };\n    case 'Float':\n      return {\n        nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'FloatTypeAnnotation',\n        },\n      };\n    default:\n      return {\n        nullable,\n        name: paramName,\n        typeAnnotation: {\n          type: 'GenericObjectTypeAnnotation',\n        },\n      };\n  }\n}\n\nfunction getReturnTypeAnnotation(\n  methodName: string,\n  returnType,\n  types: TypeMap,\n): FunctionTypeAnnotationReturn {\n  let typeAnnotation = getValueFromTypes(returnType, types);\n  let nullable = false;\n  if (typeAnnotation.type === 'NullableTypeAnnotation') {\n    nullable = true;\n    typeAnnotation = typeAnnotation.typeAnnotation;\n  }\n  let type =\n    typeAnnotation.type === 'GenericTypeAnnotation'\n      ? typeAnnotation.id.name\n      : typeAnnotation.type;\n\n  switch (type) {\n    case 'Promise':\n      if (\n        typeAnnotation.typeParameters &&\n        typeAnnotation.typeParameters.params[0]\n      ) {\n        return {\n          type: 'GenericPromiseTypeAnnotation',\n          nullable,\n        };\n      } else {\n        throw new Error(\n          `Unsupported return promise type for ${methodName}: expected to find annotation for type of promise content`,\n        );\n      }\n    case 'Array':\n    case '$ReadOnlyArray':\n      if (\n        typeAnnotation.typeParameters &&\n        typeAnnotation.typeParameters.params[0]\n      ) {\n        return {\n          nullable,\n          type: 'ArrayTypeAnnotation',\n          elementType: getElementTypeForArrayOrObject(\n            methodName,\n            typeAnnotation.typeParameters.params[0],\n            'returning value',\n            types,\n          ),\n        };\n      } else {\n        throw new Error(\n          `Unsupported return type for ${methodName}: expected to find annotation for type of array contents`,\n        );\n      }\n    case 'ObjectTypeAnnotation':\n      return {\n        nullable,\n        type: 'ObjectTypeAnnotation',\n        properties: getObjectProperties(\n          methodName,\n          typeAnnotation,\n          'returning value',\n          types,\n        ),\n      };\n    case '$ReadOnly':\n      if (\n        typeAnnotation.typeParameters.params &&\n        typeAnnotation.typeParameters.params[0]\n      ) {\n        return {\n          nullable,\n          type: 'ObjectTypeAnnotation',\n          properties: getObjectProperties(\n            methodName,\n            typeAnnotation.typeParameters.params[0],\n            'returning value',\n            types,\n          ),\n        };\n      } else {\n        throw new Error(\n          `Unsupported return type for method \"${methodName}\", No type specified for $ReadOnly`,\n        );\n      }\n    case 'BooleanTypeAnnotation':\n    case 'NumberTypeAnnotation':\n    case 'VoidTypeAnnotation':\n      return {\n        nullable,\n        type,\n      };\n    case 'StringTypeAnnotation':\n    case 'Stringish':\n      return {\n        nullable,\n        type: 'StringTypeAnnotation',\n      };\n\n    case 'Int32':\n      return {\n        nullable,\n        type: 'Int32TypeAnnotation',\n      };\n    case 'Float':\n      return {\n        nullable,\n        type: 'FloatTypeAnnotation',\n      };\n    default:\n      return {\n        type: 'GenericObjectTypeAnnotation',\n        nullable,\n      };\n  }\n}\n\nfunction buildMethodSchema(\n  property: MethodAST,\n  types: TypeMap,\n): MethodTypeShape {\n  const name: string = property.key.name;\n  const value = getValueFromTypes(property.value, types);\n  if (value.type !== 'FunctionTypeAnnotation') {\n    throw new Error(\n      `Only methods are supported as module properties. Found ${\n        value.type\n      } in ${property.key.name}`,\n    );\n  }\n  const params = value.params.map(param =>\n    getTypeAnnotationForParam(name, param, types),\n  );\n\n  const returnTypeAnnotation = getReturnTypeAnnotation(\n    name,\n    getValueFromTypes(value.returnType, types),\n    types,\n  );\n  return {\n    name,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      returnTypeAnnotation,\n      params,\n      optional: property.optional,\n    },\n  };\n}\n\nfunction getMethods(\n  typeDefinition: $ReadOnlyArray<MethodAST>,\n  types: TypeMap,\n): $ReadOnlyArray<MethodTypeShape> {\n  return typeDefinition\n    .filter(property => property.type === 'ObjectTypeProperty')\n    .map(property => buildMethodSchema(property, types))\n    .filter(Boolean);\n}\n\nmodule.exports = {\n  getMethods,\n};\n"]},"metadata":{},"sourceType":"script"}