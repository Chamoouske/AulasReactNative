{"ast":null,"code":"'use strict';\n\nvar _require = require(\"../utils.js\"),\n    getValueFromTypes = _require.getValueFromTypes;\n\nfunction buildCommandSchema(property, types) {\n  var name = property.key.name;\n  var optional = property.optional;\n  var value = getValueFromTypes(property.value, types);\n  var firstParam = value.params[0].typeAnnotation;\n\n  if (!(firstParam.id != null && firstParam.id.type === 'QualifiedTypeIdentifier' && firstParam.id.qualification.name === 'React' && firstParam.id.id.name === 'ElementRef')) {\n    throw new Error(\"The first argument of method \" + name + \" must be of type React.ElementRef<>\");\n  }\n\n  var params = value.params.slice(1).map(function (param) {\n    var paramName = param.name.name;\n    var paramValue = getValueFromTypes(param.typeAnnotation, types);\n    var type = paramValue.type === 'GenericTypeAnnotation' ? paramValue.id.name : paramValue.type;\n    var returnType;\n\n    switch (type) {\n      case 'BooleanTypeAnnotation':\n        returnType = {\n          type: 'BooleanTypeAnnotation'\n        };\n        break;\n\n      case 'Int32':\n        returnType = {\n          type: 'Int32TypeAnnotation'\n        };\n        break;\n\n      case 'Double':\n        returnType = {\n          type: 'DoubleTypeAnnotation'\n        };\n        break;\n\n      case 'Float':\n        returnType = {\n          type: 'FloatTypeAnnotation'\n        };\n        break;\n\n      default:\n        type;\n        throw new Error(\"Unsupported param type for method \\\"\" + name + \"\\\", param \\\"\" + paramName + \"\\\". Found \" + type);\n    }\n\n    return {\n      name: paramName,\n      typeAnnotation: returnType\n    };\n  });\n  return {\n    name: name,\n    optional: optional,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      params: params\n    }\n  };\n}\n\nfunction getCommands(commandTypeAST, types) {\n  return commandTypeAST.filter(function (property) {\n    return property.type === 'ObjectTypeProperty';\n  }).map(function (property) {\n    return buildCommandSchema(property, types);\n  }).filter(Boolean);\n}\n\nmodule.exports = {\n  getCommands: getCommands\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/parsers/flow/components/commands.js"],"names":["require","getValueFromTypes","buildCommandSchema","property","types","name","key","optional","value","firstParam","params","typeAnnotation","id","type","qualification","Error","slice","map","param","paramName","paramValue","returnType","getCommands","commandTypeAST","filter","Boolean","module","exports"],"mappings":"AAUA;;eAK4BA,OAAO,e;IAA5BC,iB,YAAAA,iB;;AAIP,SAASC,kBAAT,CAA4BC,QAA5B,EAAsCC,KAAtC,EAAsD;AACpD,MAAMC,IAAI,GAAGF,QAAQ,CAACG,GAAT,CAAaD,IAA1B;AACA,MAAME,QAAQ,GAAGJ,QAAQ,CAACI,QAA1B;AACA,MAAMC,KAAK,GAAGP,iBAAiB,CAACE,QAAQ,CAACK,KAAV,EAAiBJ,KAAjB,CAA/B;AAEA,MAAMK,UAAU,GAAGD,KAAK,CAACE,MAAN,CAAa,CAAb,EAAgBC,cAAnC;;AAEA,MACE,EACEF,UAAU,CAACG,EAAX,IAAiB,IAAjB,IACAH,UAAU,CAACG,EAAX,CAAcC,IAAd,KAAuB,yBADvB,IAEAJ,UAAU,CAACG,EAAX,CAAcE,aAAd,CAA4BT,IAA5B,KAAqC,OAFrC,IAGAI,UAAU,CAACG,EAAX,CAAcA,EAAd,CAAiBP,IAAjB,KAA0B,YAJ5B,CADF,EAOE;AACA,UAAM,IAAIU,KAAJ,mCAC4BV,IAD5B,yCAAN;AAGD;;AAED,MAAMK,MAAM,GAAGF,KAAK,CAACE,MAAN,CAAaM,KAAb,CAAmB,CAAnB,EAAsBC,GAAtB,CAA0B,UAAAC,KAAK,EAAI;AAChD,QAAMC,SAAS,GAAGD,KAAK,CAACb,IAAN,CAAWA,IAA7B;AACA,QAAMe,UAAU,GAAGnB,iBAAiB,CAACiB,KAAK,CAACP,cAAP,EAAuBP,KAAvB,CAApC;AACA,QAAMS,IAAI,GACRO,UAAU,CAACP,IAAX,KAAoB,uBAApB,GACIO,UAAU,CAACR,EAAX,CAAcP,IADlB,GAEIe,UAAU,CAACP,IAHjB;AAIA,QAAIQ,UAAJ;;AAEA,YAAQR,IAAR;AACE,WAAK,uBAAL;AACEQ,QAAAA,UAAU,GAAG;AACXR,UAAAA,IAAI,EAAE;AADK,SAAb;AAGA;;AACF,WAAK,OAAL;AACEQ,QAAAA,UAAU,GAAG;AACXR,UAAAA,IAAI,EAAE;AADK,SAAb;AAGA;;AACF,WAAK,QAAL;AACEQ,QAAAA,UAAU,GAAG;AACXR,UAAAA,IAAI,EAAE;AADK,SAAb;AAGA;;AACF,WAAK,OAAL;AACEQ,QAAAA,UAAU,GAAG;AACXR,UAAAA,IAAI,EAAE;AADK,SAAb;AAGA;;AACF;AACGA,QAAAA,IAAD;AACA,cAAM,IAAIE,KAAJ,0CACkCV,IADlC,oBACmDc,SADnD,kBACwEN,IADxE,CAAN;AAvBJ;;AA4BA,WAAO;AACLR,MAAAA,IAAI,EAAEc,SADD;AAELR,MAAAA,cAAc,EAAEU;AAFX,KAAP;AAID,GAzCc,CAAf;AA2CA,SAAO;AACLhB,IAAAA,IAAI,EAAJA,IADK;AAELE,IAAAA,QAAQ,EAARA,QAFK;AAGLI,IAAAA,cAAc,EAAE;AACdE,MAAAA,IAAI,EAAE,wBADQ;AAEdH,MAAAA,MAAM,EAANA;AAFc;AAHX,GAAP;AAQD;;AAED,SAASY,WAAT,CACEC,cADF,EAEEnB,KAFF,EAGoC;AAClC,SAAOmB,cAAc,CAClBC,MADI,CACG,UAAArB,QAAQ;AAAA,WAAIA,QAAQ,CAACU,IAAT,KAAkB,oBAAtB;AAAA,GADX,EAEJI,GAFI,CAEA,UAAAd,QAAQ;AAAA,WAAID,kBAAkB,CAACC,QAAD,EAAWC,KAAX,CAAtB;AAAA,GAFR,EAGJoB,MAHI,CAGGC,OAHH,CAAP;AAID;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACfL,EAAAA,WAAW,EAAXA;AADe,CAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {CommandTypeShape} from '../../../CodegenSchema.js';\nimport type {TypeMap} from '../utils.js';\n\nconst {getValueFromTypes} = require('../utils.js');\n\ntype EventTypeAST = Object;\n\nfunction buildCommandSchema(property, types: TypeMap) {\n  const name = property.key.name;\n  const optional = property.optional;\n  const value = getValueFromTypes(property.value, types);\n\n  const firstParam = value.params[0].typeAnnotation;\n\n  if (\n    !(\n      firstParam.id != null &&\n      firstParam.id.type === 'QualifiedTypeIdentifier' &&\n      firstParam.id.qualification.name === 'React' &&\n      firstParam.id.id.name === 'ElementRef'\n    )\n  ) {\n    throw new Error(\n      `The first argument of method ${name} must be of type React.ElementRef<>`,\n    );\n  }\n\n  const params = value.params.slice(1).map(param => {\n    const paramName = param.name.name;\n    const paramValue = getValueFromTypes(param.typeAnnotation, types);\n    const type =\n      paramValue.type === 'GenericTypeAnnotation'\n        ? paramValue.id.name\n        : paramValue.type;\n    let returnType;\n\n    switch (type) {\n      case 'BooleanTypeAnnotation':\n        returnType = {\n          type: 'BooleanTypeAnnotation',\n        };\n        break;\n      case 'Int32':\n        returnType = {\n          type: 'Int32TypeAnnotation',\n        };\n        break;\n      case 'Double':\n        returnType = {\n          type: 'DoubleTypeAnnotation',\n        };\n        break;\n      case 'Float':\n        returnType = {\n          type: 'FloatTypeAnnotation',\n        };\n        break;\n      default:\n        (type: empty);\n        throw new Error(\n          `Unsupported param type for method \"${name}\", param \"${paramName}\". Found ${type}`,\n        );\n    }\n\n    return {\n      name: paramName,\n      typeAnnotation: returnType,\n    };\n  });\n\n  return {\n    name,\n    optional,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      params,\n    },\n  };\n}\n\nfunction getCommands(\n  commandTypeAST: $ReadOnlyArray<EventTypeAST>,\n  types: TypeMap,\n): $ReadOnlyArray<CommandTypeShape> {\n  return commandTypeAST\n    .filter(property => property.type === 'ObjectTypeProperty')\n    .map(property => buildCommandSchema(property, types))\n    .filter(Boolean);\n}\n\nmodule.exports = {\n  getCommands,\n};\n"]},"metadata":{},"sourceType":"script"}