{"ast":null,"code":"'use strict';\n\nvar _require = require(\"../utils.js\"),\n    getValueFromTypes = _require.getValueFromTypes;\n\nfunction getPropProperties(propsTypeName, types) {\n  var typeAlias = types[propsTypeName];\n\n  try {\n    return typeAlias.right.typeParameters.params[0].properties;\n  } catch (e) {\n    throw new Error(\"Failed to find type definition for \\\"\" + propsTypeName + \"\\\", please check that you have a valid codegen flow file\");\n  }\n}\n\nfunction getTypeAnnotationForArray(name, typeAnnotation, defaultValue, types) {\n  var extractedTypeAnnotation = getValueFromTypes(typeAnnotation, types);\n\n  if (extractedTypeAnnotation.type === 'NullableTypeAnnotation') {\n    throw new Error('Nested optionals such as \"$ReadOnlyArray<?boolean>\" are not supported, please declare optionals at the top level of value definitions as in \"?$ReadOnlyArray<boolean>\"');\n  }\n\n  if (extractedTypeAnnotation.type === 'GenericTypeAnnotation' && extractedTypeAnnotation.id.name === 'WithDefault') {\n    throw new Error('Nested defaults such as \"$ReadOnlyArray<WithDefault<boolean, false>>\" are not supported, please declare defaults at the top level of value definitions as in \"WithDefault<$ReadOnlyArray<boolean>, false>\"');\n  }\n\n  if (extractedTypeAnnotation.type === 'GenericTypeAnnotation') {\n    var objectType = getValueFromTypes(extractedTypeAnnotation, types);\n\n    if (objectType.id.name === '$ReadOnly') {\n      return {\n        type: 'ObjectTypeAnnotation',\n        properties: flattenProperties(objectType.typeParameters.params[0].properties, types).map(function (prop) {\n          return buildPropSchema(prop, types);\n        }).filter(Boolean)\n      };\n    }\n\n    if (objectType.id.name === '$ReadOnlyArray') {\n      var nestedObjectType = getValueFromTypes(objectType.typeParameters.params[0], types);\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ObjectTypeAnnotation',\n          properties: flattenProperties(nestedObjectType.typeParameters.params[0].properties, types).map(function (prop) {\n            return buildPropSchema(prop, types);\n          }).filter(Boolean)\n        }\n      };\n    }\n  }\n\n  var type = extractedTypeAnnotation.type === 'GenericTypeAnnotation' ? extractedTypeAnnotation.id.name : extractedTypeAnnotation.type;\n\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ImageSourcePrimitive'\n      };\n\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ColorPrimitive'\n      };\n\n    case 'PointValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'PointPrimitive'\n      };\n\n    case 'EdgeInsetsValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'EdgeInsetsPrimitive'\n      };\n\n    case 'Stringish':\n      return {\n        type: 'StringTypeAnnotation'\n      };\n\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation'\n      };\n\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation'\n      };\n\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation'\n      };\n\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation'\n      };\n\n    case 'StringTypeAnnotation':\n      return {\n        type: 'StringTypeAnnotation'\n      };\n\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce(function (lastType, currType) {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(\"Mixed types are not supported (see \\\"\" + name + \"\\\")\");\n        }\n\n        return currType;\n      });\n\n      if (defaultValue === null) {\n        throw new Error(\"A default enum value is required for \\\"\" + name + \"\\\"\");\n      }\n\n      var unionType = typeAnnotation.types[0].type;\n\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(function (option) {\n            return {\n              name: option.value\n            };\n          })\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        throw new Error(\"Arrays of int enums are not supported (see: \\\"\" + name + \"\\\")\");\n      } else {\n        throw new Error(\"Unsupported union type for \\\"\" + name + \"\\\", recieved \\\"\" + unionType + \"\\\"\");\n      }\n\n    default:\n      type;\n      throw new Error(\"Unknown prop type for \\\"\" + name + \"\\\": \" + type);\n  }\n}\n\nfunction getTypeAnnotation(name, annotation, defaultValue, withNullDefault, types) {\n  var typeAnnotation = getValueFromTypes(annotation, types);\n\n  if (typeAnnotation.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === '$ReadOnlyArray') {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(name, typeAnnotation.typeParameters.params[0], defaultValue, types)\n    };\n  }\n\n  if (typeAnnotation.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === '$ReadOnly') {\n    return {\n      type: 'ObjectTypeAnnotation',\n      properties: flattenProperties(typeAnnotation.typeParameters.params[0].properties, types).map(function (prop) {\n        return buildPropSchema(prop, types);\n      }).filter(Boolean)\n    };\n  }\n\n  var type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ImageSourcePrimitive'\n      };\n\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ColorPrimitive'\n      };\n\n    case 'ColorArrayValue':\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'NativePrimitiveTypeAnnotation',\n          name: 'ColorPrimitive'\n        }\n      };\n\n    case 'PointValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'PointPrimitive'\n      };\n\n    case 'EdgeInsetsValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'EdgeInsetsPrimitive'\n      };\n\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n        default: defaultValue ? defaultValue : 0\n      };\n\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation',\n        default: defaultValue ? defaultValue : 0\n      };\n\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n        default: withNullDefault ? defaultValue : defaultValue ? defaultValue : 0\n      };\n\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation',\n        default: withNullDefault ? defaultValue : defaultValue == null ? false : defaultValue\n      };\n\n    case 'StringTypeAnnotation':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: defaultValue\n        };\n      }\n\n      throw new Error(\"A default string (or null) is required for \\\"\" + name + \"\\\"\");\n\n    case 'Stringish':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: defaultValue\n        };\n      }\n\n      throw new Error(\"A default string (or null) is required for \\\"\" + name + \"\\\"\");\n\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce(function (lastType, currType) {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(\"Mixed types are not supported (see \\\"\" + name + \"\\\")\");\n        }\n\n        return currType;\n      });\n\n      if (defaultValue === null) {\n        throw new Error(\"A default enum value is required for \\\"\" + name + \"\\\"\");\n      }\n\n      var unionType = typeAnnotation.types[0].type;\n\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(function (option) {\n            return {\n              name: option.value\n            };\n          })\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        return {\n          type: 'Int32EnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(function (option) {\n            return {\n              value: option.value\n            };\n          })\n        };\n      } else {\n        throw new Error(\"Unsupported union type for \\\"\" + name + \"\\\", received \\\"\" + unionType + \"\\\"\");\n      }\n\n    case 'NumberTypeAnnotation':\n      throw new Error(\"Cannot use \\\"\" + type + \"\\\" type annotation for \\\"\" + name + \"\\\": must use a specific numeric type like Int32, Double, or Float\");\n\n    default:\n      type;\n      throw new Error(\"Unknown prop type for \\\"\" + name + \"\\\": \\\"\" + type + \"\\\"\");\n  }\n}\n\nfunction buildPropSchema(property, types) {\n  var name = property.key.name;\n  var value = getValueFromTypes(property.value, types);\n  var typeAnnotation = value.type === 'NullableTypeAnnotation' ? value.typeAnnotation : value;\n  var optional = value.type === 'NullableTypeAnnotation' || property.optional || value.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault';\n\n  if (!property.optional && value.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault') {\n    throw new Error(\"key \" + name + \" must be optional if used with WithDefault<> annotation\");\n  }\n\n  if (value.type === 'NullableTypeAnnotation' && typeAnnotation.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault') {\n    throw new Error('WithDefault<> is optional and does not need to be marked as optional. Please remove the ? annotation in front of it.');\n  }\n\n  var type = typeAnnotation.type;\n\n  if (type === 'GenericTypeAnnotation' && (typeAnnotation.id.name === 'DirectEventHandler' || typeAnnotation.id.name === 'BubblingEventHandler')) {\n    return null;\n  }\n\n  if (name === 'style' && type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'ViewStyleProp') {\n    return null;\n  }\n\n  var defaultValue = null;\n  var withNullDefault = false;\n\n  if (type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault') {\n    if (typeAnnotation.typeParameters.params.length === 1) {\n      throw new Error(\"WithDefault requires two parameters, did you forget to provide a default value for \\\"\" + name + \"\\\"?\");\n    }\n\n    defaultValue = typeAnnotation.typeParameters.params[1].value;\n    var defaultValueType = typeAnnotation.typeParameters.params[1].type;\n    typeAnnotation = typeAnnotation.typeParameters.params[0];\n    type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n\n    if (defaultValueType === 'NullLiteralTypeAnnotation') {\n      defaultValue = null;\n      withNullDefault = true;\n    }\n  }\n\n  return {\n    name: name,\n    optional: optional,\n    typeAnnotation: getTypeAnnotation(name, typeAnnotation, defaultValue, withNullDefault, types)\n  };\n}\n\nfunction verifyPropNotAlreadyDefined(props, needleProp) {\n  var propName = needleProp.key.name;\n  var foundProp = props.some(function (prop) {\n    return prop.key.name === propName;\n  });\n\n  if (foundProp) {\n    throw new Error(\"A prop was already defined with the name \" + propName);\n  }\n}\n\nfunction flattenProperties(typeDefinition, types) {\n  return typeDefinition.map(function (property) {\n    if (property.type === 'ObjectTypeProperty') {\n      return property;\n    } else if (property.type === 'ObjectTypeSpreadProperty') {\n      return flattenProperties(getPropProperties(property.argument.id.name, types), types);\n    }\n  }).reduce(function (acc, item) {\n    if (Array.isArray(item)) {\n      item.forEach(function (prop) {\n        verifyPropNotAlreadyDefined(acc, prop);\n      });\n      return acc.concat(item);\n    } else {\n      verifyPropNotAlreadyDefined(acc, item);\n      acc.push(item);\n      return acc;\n    }\n  }, []).filter(Boolean);\n}\n\nfunction getProps(typeDefinition, types) {\n  return flattenProperties(typeDefinition, types).map(function (property) {\n    return buildPropSchema(property, types);\n  }).filter(Boolean);\n}\n\nmodule.exports = {\n  getProps: getProps,\n  getPropProperties: getPropProperties\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/parsers/flow/components/props.js"],"names":["require","getValueFromTypes","getPropProperties","propsTypeName","types","typeAlias","right","typeParameters","params","properties","e","Error","getTypeAnnotationForArray","name","typeAnnotation","defaultValue","extractedTypeAnnotation","type","id","objectType","flattenProperties","map","prop","buildPropSchema","filter","Boolean","nestedObjectType","elementType","reduce","lastType","currType","unionType","default","options","option","value","getTypeAnnotation","annotation","withNullDefault","property","key","optional","length","defaultValueType","verifyPropNotAlreadyDefined","props","needleProp","propName","foundProp","some","typeDefinition","argument","acc","item","Array","isArray","forEach","concat","push","getProps","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nconst {getValueFromTypes} = require('../utils.js');\n\nimport type {PropTypeShape} from '../../../CodegenSchema.js';\nimport type {TypeMap} from '../utils.js';\n\nfunction getPropProperties(propsTypeName: string, types: TypeMap): $FlowFixMe {\n  const typeAlias = types[propsTypeName];\n  try {\n    return typeAlias.right.typeParameters.params[0].properties;\n  } catch (e) {\n    throw new Error(\n      `Failed to find type definition for \"${propsTypeName}\", please check that you have a valid codegen flow file`,\n    );\n  }\n}\n\nfunction getTypeAnnotationForArray(name, typeAnnotation, defaultValue, types) {\n  const extractedTypeAnnotation = getValueFromTypes(typeAnnotation, types);\n  if (extractedTypeAnnotation.type === 'NullableTypeAnnotation') {\n    throw new Error(\n      'Nested optionals such as \"$ReadOnlyArray<?boolean>\" are not supported, please declare optionals at the top level of value definitions as in \"?$ReadOnlyArray<boolean>\"',\n    );\n  }\n\n  if (\n    extractedTypeAnnotation.type === 'GenericTypeAnnotation' &&\n    extractedTypeAnnotation.id.name === 'WithDefault'\n  ) {\n    throw new Error(\n      'Nested defaults such as \"$ReadOnlyArray<WithDefault<boolean, false>>\" are not supported, please declare defaults at the top level of value definitions as in \"WithDefault<$ReadOnlyArray<boolean>, false>\"',\n    );\n  }\n\n  if (extractedTypeAnnotation.type === 'GenericTypeAnnotation') {\n    // Resolve the type alias if it's not defined inline\n    const objectType = getValueFromTypes(extractedTypeAnnotation, types);\n\n    if (objectType.id.name === '$ReadOnly') {\n      return {\n        type: 'ObjectTypeAnnotation',\n        properties: flattenProperties(\n          objectType.typeParameters.params[0].properties,\n          types,\n        )\n          .map(prop => buildPropSchema(prop, types))\n          .filter(Boolean),\n      };\n    }\n\n    if (objectType.id.name === '$ReadOnlyArray') {\n      // We need to go yet another level deeper to resolve\n      // types that may be defined in a type alias\n      const nestedObjectType = getValueFromTypes(\n        objectType.typeParameters.params[0],\n        types,\n      );\n\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ObjectTypeAnnotation',\n          properties: flattenProperties(\n            nestedObjectType.typeParameters.params[0].properties,\n            types,\n          )\n            .map(prop => buildPropSchema(prop, types))\n            .filter(Boolean),\n        },\n      };\n    }\n  }\n\n  const type =\n    extractedTypeAnnotation.type === 'GenericTypeAnnotation'\n      ? extractedTypeAnnotation.id.name\n      : extractedTypeAnnotation.type;\n\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ImageSourcePrimitive',\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ColorPrimitive',\n      };\n    case 'PointValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'PointPrimitive',\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'EdgeInsetsPrimitive',\n      };\n    case 'Stringish':\n      return {\n        type: 'StringTypeAnnotation',\n      };\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation',\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n      };\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation',\n      };\n    case 'StringTypeAnnotation':\n      return {\n        type: 'StringTypeAnnotation',\n      };\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce((lastType, currType) => {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(`Mixed types are not supported (see \"${name}\")`);\n        }\n        return currType;\n      });\n\n      if (defaultValue === null) {\n        throw new Error(`A default enum value is required for \"${name}\"`);\n      }\n\n      const unionType = typeAnnotation.types[0].type;\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: (defaultValue: string),\n          options: typeAnnotation.types.map(option => ({name: option.value})),\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        throw new Error(\n          `Arrays of int enums are not supported (see: \"${name}\")`,\n        );\n      } else {\n        throw new Error(\n          `Unsupported union type for \"${name}\", recieved \"${unionType}\"`,\n        );\n      }\n    default:\n      (type: empty);\n      throw new Error(`Unknown prop type for \"${name}\": ${type}`);\n  }\n}\n\nfunction getTypeAnnotation(\n  name,\n  annotation,\n  defaultValue,\n  withNullDefault,\n  types,\n) {\n  const typeAnnotation = getValueFromTypes(annotation, types);\n\n  if (\n    typeAnnotation.type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === '$ReadOnlyArray'\n  ) {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(\n        name,\n        typeAnnotation.typeParameters.params[0],\n        defaultValue,\n        types,\n      ),\n    };\n  }\n\n  if (\n    typeAnnotation.type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === '$ReadOnly'\n  ) {\n    return {\n      type: 'ObjectTypeAnnotation',\n      properties: flattenProperties(\n        typeAnnotation.typeParameters.params[0].properties,\n        types,\n      )\n        .map(prop => buildPropSchema(prop, types))\n        .filter(Boolean),\n    };\n  }\n\n  const type =\n    typeAnnotation.type === 'GenericTypeAnnotation'\n      ? typeAnnotation.id.name\n      : typeAnnotation.type;\n\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ImageSourcePrimitive',\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'ColorPrimitive',\n      };\n    case 'ColorArrayValue':\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'NativePrimitiveTypeAnnotation',\n          name: 'ColorPrimitive',\n        },\n      };\n    case 'PointValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'PointPrimitive',\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'NativePrimitiveTypeAnnotation',\n        name: 'EdgeInsetsPrimitive',\n      };\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n        default: ((defaultValue ? defaultValue : 0): number),\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation',\n        default: ((defaultValue ? defaultValue : 0): number),\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n        default: withNullDefault\n          ? (defaultValue: number | null)\n          : ((defaultValue ? defaultValue : 0): number),\n      };\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation',\n        default: withNullDefault\n          ? (defaultValue: boolean | null)\n          : ((defaultValue == null ? false : defaultValue): boolean),\n      };\n    case 'StringTypeAnnotation':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: (defaultValue: string | null),\n        };\n      }\n      throw new Error(`A default string (or null) is required for \"${name}\"`);\n    case 'Stringish':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: (defaultValue: string | null),\n        };\n      }\n      throw new Error(`A default string (or null) is required for \"${name}\"`);\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce((lastType, currType) => {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(`Mixed types are not supported (see \"${name}\")`);\n        }\n        return currType;\n      });\n\n      if (defaultValue === null) {\n        throw new Error(`A default enum value is required for \"${name}\"`);\n      }\n\n      const unionType = typeAnnotation.types[0].type;\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: (defaultValue: string),\n          options: typeAnnotation.types.map(option => ({name: option.value})),\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        return {\n          type: 'Int32EnumTypeAnnotation',\n          default: (defaultValue: number),\n          options: typeAnnotation.types.map(option => ({value: option.value})),\n        };\n      } else {\n        throw new Error(\n          `Unsupported union type for \"${name}\", received \"${unionType}\"`,\n        );\n      }\n    case 'NumberTypeAnnotation':\n      throw new Error(\n        `Cannot use \"${type}\" type annotation for \"${name}\": must use a specific numeric type like Int32, Double, or Float`,\n      );\n    default:\n      (type: empty);\n      throw new Error(`Unknown prop type for \"${name}\": \"${type}\"`);\n  }\n}\n\nfunction buildPropSchema(property, types: TypeMap): ?PropTypeShape {\n  const name = property.key.name;\n\n  const value = getValueFromTypes(property.value, types);\n  let typeAnnotation =\n    value.type === 'NullableTypeAnnotation' ? value.typeAnnotation : value;\n\n  const optional =\n    value.type === 'NullableTypeAnnotation' ||\n    property.optional ||\n    (value.type === 'GenericTypeAnnotation' &&\n      typeAnnotation.id.name === 'WithDefault');\n\n  if (\n    !property.optional &&\n    value.type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === 'WithDefault'\n  ) {\n    throw new Error(\n      `key ${name} must be optional if used with WithDefault<> annotation`,\n    );\n  }\n  if (\n    value.type === 'NullableTypeAnnotation' &&\n    (typeAnnotation.type === 'GenericTypeAnnotation' &&\n      typeAnnotation.id.name === 'WithDefault')\n  ) {\n    throw new Error(\n      'WithDefault<> is optional and does not need to be marked as optional. Please remove the ? annotation in front of it.',\n    );\n  }\n\n  let type = typeAnnotation.type;\n  if (\n    type === 'GenericTypeAnnotation' &&\n    (typeAnnotation.id.name === 'DirectEventHandler' ||\n      typeAnnotation.id.name === 'BubblingEventHandler')\n  ) {\n    return null;\n  }\n\n  if (\n    name === 'style' &&\n    type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === 'ViewStyleProp'\n  ) {\n    return null;\n  }\n\n  let defaultValue = null;\n  let withNullDefault = false;\n  if (\n    type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === 'WithDefault'\n  ) {\n    if (typeAnnotation.typeParameters.params.length === 1) {\n      throw new Error(\n        `WithDefault requires two parameters, did you forget to provide a default value for \"${name}\"?`,\n      );\n    }\n\n    defaultValue = typeAnnotation.typeParameters.params[1].value;\n    const defaultValueType = typeAnnotation.typeParameters.params[1].type;\n\n    typeAnnotation = typeAnnotation.typeParameters.params[0];\n    type =\n      typeAnnotation.type === 'GenericTypeAnnotation'\n        ? typeAnnotation.id.name\n        : typeAnnotation.type;\n\n    if (defaultValueType === 'NullLiteralTypeAnnotation') {\n      defaultValue = null;\n      withNullDefault = true;\n    }\n  }\n\n  return {\n    name,\n    optional,\n    typeAnnotation: getTypeAnnotation(\n      name,\n      typeAnnotation,\n      defaultValue,\n      withNullDefault,\n      types,\n    ),\n  };\n}\n\n// $FlowFixMe there's no flowtype for ASTs\ntype PropAST = Object;\n\nfunction verifyPropNotAlreadyDefined(\n  props: $ReadOnlyArray<PropAST>,\n  needleProp: PropAST,\n) {\n  const propName = needleProp.key.name;\n  const foundProp = props.some(prop => prop.key.name === propName);\n  if (foundProp) {\n    throw new Error(`A prop was already defined with the name ${propName}`);\n  }\n}\n\nfunction flattenProperties(\n  typeDefinition: $ReadOnlyArray<PropAST>,\n  types: TypeMap,\n) {\n  return typeDefinition\n    .map(property => {\n      if (property.type === 'ObjectTypeProperty') {\n        return property;\n      } else if (property.type === 'ObjectTypeSpreadProperty') {\n        return flattenProperties(\n          getPropProperties(property.argument.id.name, types),\n          types,\n        );\n      }\n    })\n    .reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        item.forEach(prop => {\n          verifyPropNotAlreadyDefined(acc, prop);\n        });\n        return acc.concat(item);\n      } else {\n        verifyPropNotAlreadyDefined(acc, item);\n        acc.push(item);\n        return acc;\n      }\n    }, [])\n    .filter(Boolean);\n}\n\nfunction getProps(\n  typeDefinition: $ReadOnlyArray<PropAST>,\n  types: TypeMap,\n): $ReadOnlyArray<PropTypeShape> {\n  return flattenProperties(typeDefinition, types)\n    .map(property => buildPropSchema(property, types))\n    .filter(Boolean);\n}\n\nmodule.exports = {\n  getProps,\n  getPropProperties,\n};\n"]},"metadata":{},"sourceType":"script"}