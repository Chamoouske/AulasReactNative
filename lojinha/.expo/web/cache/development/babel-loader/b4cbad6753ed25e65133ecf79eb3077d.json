{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar XML_1 = require(\"../utils/XML\");\n\nvar fallbackResourceString = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><resources></resources>\";\n\nfunction readResourcesXMLAsync(_ref) {\n  var path, _ref$fallback, fallback, xml;\n\n  return _regeneratorRuntime.async(function readResourcesXMLAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          path = _ref.path, _ref$fallback = _ref.fallback, fallback = _ref$fallback === void 0 ? fallbackResourceString : _ref$fallback;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(XML_1.readXMLAsync({\n            path: path,\n            fallback: fallback\n          }));\n\n        case 3:\n          xml = _context.sent;\n\n          if (!xml.resources) {\n            xml.resources = {};\n          }\n\n          return _context.abrupt(\"return\", xml);\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.readResourcesXMLAsync = readResourcesXMLAsync;\n\nfunction ensureDefaultResourceXML(xml) {\n  if (!xml) {\n    xml = {\n      resources: {}\n    };\n  }\n\n  if (!xml.resources) {\n    xml.resources = {};\n  }\n\n  return xml;\n}\n\nexports.ensureDefaultResourceXML = ensureDefaultResourceXML;\n\nfunction buildResourceItem(_ref2) {\n  var name = _ref2.name,\n      value = _ref2.value;\n  return {\n    $: {\n      name: name\n    },\n    _: value\n  };\n}\n\nexports.buildResourceItem = buildResourceItem;\n\nfunction buildResourceGroup(parent) {\n  var _a;\n\n  return {\n    $: {\n      name: parent.name,\n      parent: parent.parent\n    },\n    item: (_a = parent.items) !== null && _a !== void 0 ? _a : []\n  };\n}\n\nexports.buildResourceGroup = buildResourceGroup;","map":{"version":3,"sources":["../../src/android/Resources.ts"],"names":[],"mappings":";;;;;;;;AAAA,IAAA,KAAA,GAAA,OAAA,gBAAA;;AA8BA,IAAM,sBAAsB,sEAA5B;;AAOO,SAAe,qBAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AACL,UAAA,IADK,QACL,IADK,uBAEL,QAFK,EAEL,QAFK,8BAEM,sBAFN;AAAA;AAAA,2CAOa,KAAA,CAAA,YAAA,CAAa;AAAE,YAAA,IAAI,EAAJ,IAAF;AAAQ,YAAA,QAAQ,EAAR;AAAR,WAAb,CAPb;;AAAA;AAOC,UAAA,GAPD;;AASL,cAAI,CAAC,GAAG,CAAC,SAAT,EAAoB;AAClB,YAAA,GAAG,CAAC,SAAJ,GAAgB,EAAhB;AACD;;AAXI,2CAYE,GAZF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAP,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AAoBA,SAAgB,wBAAhB,CAAyC,GAAzC,EAAuD;AACrD,MAAI,CAAC,GAAL,EAAU;AACR,IAAA,GAAG,GAAG;AAAE,MAAA,SAAS,EAAE;AAAb,KAAN;AACD;;AACD,MAAI,CAAC,GAAG,CAAC,SAAT,EAAoB;AAClB,IAAA,GAAG,CAAC,SAAJ,GAAgB,EAAhB;AACD;;AAED,SAAO,GAAP;AACD;;AATD,OAAA,CAAA,wBAAA,GAAA,wBAAA;;AAmBA,SAAgB,iBAAhB,QAMC;AAAA,MALC,IAKD,SALC,IAKD;AAAA,MAJC,KAID,SAJC,KAID;AACC,SAAO;AAAE,IAAA,CAAC,EAAE;AAAE,MAAA,IAAI,EAAJ;AAAF,KAAL;AAAe,IAAA,CAAC,EAAE;AAAlB,GAAP;AACD;;AARD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAUA,SAAgB,kBAAhB,CAAmC,MAAnC,EAIC;;;AACC,SAAO;AACL,IAAA,CAAC,EAAE;AAAE,MAAA,IAAI,EAAE,MAAM,CAAC,IAAf;AAAqB,MAAA,MAAM,EAAE,MAAM,CAAC;AAApC,KADE;AAEL,IAAA,IAAI,EAAA,CAAA,EAAA,GAAE,MAAM,CAAC,KAAT,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,EAAd,GAAkB;AAFjB,GAAP;AAID;;AATD,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourcesContent":["import { readXMLAsync, XMLObject } from '../utils/XML';\n\nexport type ResourceGroupXML = {\n  $: {\n    name: string;\n    parent: string;\n  };\n  item: ResourceItemXML[];\n};\n\nexport type ResourceXML = {\n  resources: {\n    color?: ResourceItemXML[];\n    string?: ResourceItemXML[];\n    style?: ResourceGroupXML[];\n    // Add more if needed...\n  };\n};\n\nexport type ResourceItemXML = {\n  _: string;\n  $: {\n    name: string;\n  };\n};\n/**\n * Name of the resource folder.\n */\nexport type ResourceKind = 'values' | 'values-night' | 'values-v23';\n\nconst fallbackResourceString = `<?xml version=\"1.0\" encoding=\"utf-8\"?><resources></resources>`;\n\n/**\n * Read an XML file while providing a default fallback for resource files.\n *\n * @param options path to the XML file, returns a fallback XML if the path doesn't exist.\n */\nexport async function readResourcesXMLAsync({\n  path,\n  fallback = fallbackResourceString,\n}: {\n  path: string;\n  fallback?: string | null;\n}): Promise<ResourceXML> {\n  const xml = await readXMLAsync({ path, fallback });\n  // Ensure the type is expected.\n  if (!xml.resources) {\n    xml.resources = {};\n  }\n  return xml as ResourceXML;\n}\n\n/**\n * Ensure the provided xml has a `resources` object (the expected shape).\n *\n * @param xml\n */\nexport function ensureDefaultResourceXML(xml: XMLObject): ResourceXML {\n  if (!xml) {\n    xml = { resources: {} };\n  }\n  if (!xml.resources) {\n    xml.resources = {};\n  }\n\n  return xml as ResourceXML;\n}\n\n/**\n * Build a `ResourceItemXML` given its `name` and `value`. This makes things a bit more readable.\n *\n * - JSON: `{ $: { name }, _: value }`\n * - XML: `<item name=\"NAME\">VALUE</item>`\n *\n * @param props name and value strings.\n */\nexport function buildResourceItem({\n  name,\n  value,\n}: {\n  name: string;\n  value: string;\n}): ResourceItemXML {\n  return { $: { name }, _: value };\n}\n\nexport function buildResourceGroup(parent: {\n  name: string;\n  parent: string;\n  items?: ResourceItemXML[];\n}): ResourceGroupXML {\n  return {\n    $: { name: parent.name, parent: parent.parent },\n    item: parent.items ?? [],\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}