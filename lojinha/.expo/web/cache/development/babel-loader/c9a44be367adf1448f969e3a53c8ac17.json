{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar find_up_1 = __importDefault(require(\"find-up\"));\n\nvar path = __importStar(require(\"path\"));\n\nvar resolve_from_1 = __importDefault(require(\"resolve-from\"));\n\nvar errors_1 = require(\"./errors\");\n\nvar modules_1 = require(\"./modules\");\n\nexports.pluginFileName = 'app.plugin.js';\n\nfunction findUpPackageJson(root) {\n  var packageJson = find_up_1.default.sync('package.json', {\n    cwd: root\n  });\n  errors_1.assert(packageJson, \"No package.json found for module \\\"\" + root + \"\\\"\");\n  return packageJson;\n}\n\nfunction resolvePluginForModule(projectRoot, modulePath) {\n  var resolved = resolve_from_1.default(projectRoot, modulePath);\n  errors_1.assert(resolved, \"Failed to resolve plugin for module \\\"\" + modulePath + \"\\\" relative to \\\"\" + projectRoot + \"\\\"\");\n\n  if (moduleNameIsDirectFileReference(modulePath)) {\n    return resolved;\n  }\n\n  return findUpPlugin(resolved);\n}\n\nfunction pathIsFilePath(name) {\n  return !!name.match(/^(\\.|~\\/|\\/)/g);\n}\n\nfunction moduleNameIsDirectFileReference(name) {\n  var _a;\n\n  if (pathIsFilePath(name)) {\n    return true;\n  }\n\n  var slashCount = (_a = name.split(path.sep)) === null || _a === void 0 ? void 0 : _a.length;\n\n  if (name.startsWith('@')) {\n    return slashCount > 2;\n  }\n\n  return slashCount > 1;\n}\n\nexports.moduleNameIsDirectFileReference = moduleNameIsDirectFileReference;\n\nfunction resolveExpoPluginFile(root) {\n  var pluginModuleFile = resolve_from_1.default.silent(root, \"./\" + exports.pluginFileName);\n\n  if (pluginModuleFile && modules_1.fileExists(pluginModuleFile)) {\n    return pluginModuleFile;\n  }\n\n  return null;\n}\n\nfunction findUpPlugin(root) {\n  var _a;\n\n  var packageJson = findUpPackageJson(root);\n  var moduleRoot = path.dirname(packageJson);\n  return (_a = resolveExpoPluginFile(moduleRoot)) !== null && _a !== void 0 ? _a : root;\n}\n\nfunction normalizeStaticPlugin(plugin) {\n  if (Array.isArray(plugin)) {\n    errors_1.assert(plugin.length > 0 && plugin.length < 3, \"Wrong number of arguments provided for static config plugin, expected either 1 or 2, got \" + plugin.length);\n    return plugin;\n  }\n\n  return [plugin, undefined];\n}\n\nexports.normalizeStaticPlugin = normalizeStaticPlugin;\n\nfunction assertInternalProjectRoot(projectRoot) {\n  errors_1.assert(projectRoot, \"Unexpected: Config `_internal.projectRoot` isn't defined by expo-cli, this is a bug.\");\n}\n\nexports.assertInternalProjectRoot = assertInternalProjectRoot;\n\nfunction resolveConfigPluginFunction(projectRoot, pluginModulePath) {\n  var moduleFilePath = resolvePluginForModule(projectRoot, pluginModulePath);\n  var result = requirePluginFile(moduleFilePath);\n  return resolveConfigPluginExport(result, moduleFilePath);\n}\n\nexports.resolveConfigPluginFunction = resolveConfigPluginFunction;\n\nfunction resolveConfigPluginExport(result, configFile) {\n  if (result.default != null) {\n    result = result.default;\n  }\n\n  if (typeof result !== 'function') {\n    throw new errors_1.PluginError(\"Plugin file \" + configFile + \" must export a function. Learn more: https://github.com/expo/expo-cli/tree/master/packages/config-plugins#creating-a-plugin\", 'INVALID_PLUGIN_TYPE');\n  }\n\n  return result;\n}\n\nexports.resolveConfigPluginExport = resolveConfigPluginExport;\n\nfunction requirePluginFile(filePath) {\n  try {\n    return require(filePath);\n  } catch (error) {\n    throw error;\n  }\n}","map":{"version":3,"sources":["../../src/utils/plugin-resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import findUp from 'find-up';\nimport * as path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { assert, PluginError } from './errors';\nimport { fileExists } from './modules';\n\n// Default plugin entry file name.\nexport const pluginFileName = 'app.plugin.js';\n\nfunction findUpPackageJson(root: string): string {\n  const packageJson = findUp.sync('package.json', { cwd: root });\n  assert(packageJson, `No package.json found for module \"${root}\"`);\n  return packageJson;\n}\n\nfunction resolvePluginForModule(projectRoot: string, modulePath: string): string {\n  const resolved = resolveFrom(projectRoot, modulePath);\n  assert(\n    resolved,\n    `Failed to resolve plugin for module \"${modulePath}\" relative to \"${projectRoot}\"`\n  );\n  // If the modulePath is something like `@bacon/package/index.js` or `expo-foo/build/app`\n  // then skip resolving the module `app.plugin.js`\n  if (moduleNameIsDirectFileReference(modulePath)) {\n    return resolved;\n  }\n  return findUpPlugin(resolved);\n}\n\n// TODO: Test windows\nfunction pathIsFilePath(name: string): boolean {\n  // Matches lines starting with: . / ~/\n  return !!name.match(/^(\\.|~\\/|\\/)/g);\n}\n\nexport function moduleNameIsDirectFileReference(name: string): boolean {\n  if (pathIsFilePath(name)) {\n    return true;\n  }\n\n  const slashCount = name.split(path.sep)?.length;\n  // Orgs (like @expo/config ) should have more than one slash to be a direct file.\n  if (name.startsWith('@')) {\n    return slashCount > 2;\n  }\n\n  // Regular packages should be considered direct reference if they have more than one slash.\n  return slashCount > 1;\n}\n\nfunction resolveExpoPluginFile(root: string): string | null {\n  // Find the expo plugin root file\n  const pluginModuleFile = resolveFrom.silent(\n    root,\n    // use ./ so it isn't resolved as a node module\n    `./${pluginFileName}`\n  );\n\n  // If the default expo plugin file exists use it.\n  if (pluginModuleFile && fileExists(pluginModuleFile)) {\n    return pluginModuleFile;\n  }\n  return null;\n}\n\nfunction findUpPlugin(root: string): string {\n  // Get the closest package.json to the node module\n  const packageJson = findUpPackageJson(root);\n  // resolve the root folder for the node module\n  const moduleRoot = path.dirname(packageJson);\n  // use whatever the initial resolved file was ex: `node_modules/my-package/index.js` or `./something.js`\n  return resolveExpoPluginFile(moduleRoot) ?? root;\n}\n\nexport function normalizeStaticPlugin(plugin: StaticPlugin | ConfigPlugin | string): StaticPlugin {\n  if (Array.isArray(plugin)) {\n    assert(\n      plugin.length > 0 && plugin.length < 3,\n      `Wrong number of arguments provided for static config plugin, expected either 1 or 2, got ${plugin.length}`\n    );\n    return plugin;\n  }\n  return [plugin, undefined];\n}\n\nexport function assertInternalProjectRoot(projectRoot?: string): asserts projectRoot {\n  assert(\n    projectRoot,\n    `Unexpected: Config \\`_internal.projectRoot\\` isn't defined by expo-cli, this is a bug.`\n  );\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunction(projectRoot: string, pluginModulePath: string) {\n  const moduleFilePath = resolvePluginForModule(projectRoot, pluginModulePath);\n  const result = requirePluginFile(moduleFilePath);\n  return resolveConfigPluginExport(result, moduleFilePath);\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n */\nexport function resolveConfigPluginExport(result: any, configFile: string): ConfigPlugin<unknown> {\n  if (result.default != null) {\n    result = result.default;\n  }\n  if (typeof result !== 'function') {\n    throw new PluginError(\n      `Plugin file ${configFile} must export a function. Learn more: https://github.com/expo/expo-cli/tree/master/packages/config-plugins#creating-a-plugin`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  return result;\n}\n\nfunction requirePluginFile(filePath: string): any {\n  try {\n    return require(filePath);\n  } catch (error) {\n    // TODO: Improve error messages\n    throw error;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}