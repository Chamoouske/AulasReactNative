{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar ConfigError = function (_Error) {\n  _inherits(ConfigError, _Error);\n\n  var _super = _createSuper(ConfigError);\n\n  function ConfigError(message, code, cause) {\n    var _this;\n\n    _classCallCheck(this, ConfigError);\n\n    _this = _super.call(this, cause ? message + \"\\n\\u2514\\u2500 Cause: \" + cause.name + \": \" + cause.message : message);\n    _this.code = code;\n    _this.cause = cause;\n    _this.name = 'ConfigError';\n    _this.isConfigError = true;\n    return _this;\n  }\n\n  return ConfigError;\n}(_wrapNativeSuper(Error));\n\nexports.ConfigError = ConfigError;\n\nfunction assert(value, message) {\n  return assert_1.default(value, message);\n}\n\nexports.assert = assert;","map":{"version":3,"sources":["../src/Errors.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;IAOa,W;;;;;AAIX,uBAAY,OAAZ,EAAoC,IAApC,EAAkE,KAAlE,EAA+E;AAAA;;AAAA;;AAC7E,8BAAM,KAAK,GAAM,OAAN,8BAA4B,KAAK,CAAC,IAAlC,UAA2C,KAAK,CAAC,OAAjD,GAA6D,OAAxE;AADkC,UAAA,IAAA,GAAA,IAAA;AAA8B,UAAA,KAAA,GAAA,KAAA;AAHzD,UAAA,IAAA,GAAO,aAAP;AACA,UAAA,aAAA,GAAgB,IAAhB;AAEsE;AAE9E;;;mBAN8B,K;;AAAjC,OAAA,CAAA,WAAA,GAAA,WAAA;;AASA,SAAgB,MAAhB,CAAuB,KAAvB,EAAmC,OAAnC,EAA2D;AAEzD,SAAO,QAAA,CAAA,OAAA,CAAW,KAAX,EAAkB,OAAlB,CAAP;AACD;;AAHD,OAAA,CAAA,MAAA,GAAA,MAAA","sourcesContent":["import nodeAssert from 'assert';\n\nimport { ConfigErrorCode } from './Config.types';\n\n/**\n * Based on `JsonFileError` from `@expo/json-file`\n */\nexport class ConfigError extends Error {\n  readonly name = 'ConfigError';\n  readonly isConfigError = true;\n\n  constructor(message: string, public code: ConfigErrorCode, public cause?: Error) {\n    super(cause ? `${message}\\n└─ Cause: ${cause.name}: ${cause.message}` : message);\n  }\n}\n\nexport function assert(value: any, message?: string | Error): asserts value {\n  // TODO: Upgrade node? TypeScript isn't properly asserting values without this wrapper.\n  return nodeAssert(value, message);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}