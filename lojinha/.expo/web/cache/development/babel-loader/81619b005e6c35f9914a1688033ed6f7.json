{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar _require = require(\"./commands\"),\n    getCommands = _require.getCommands;\n\nvar _require2 = require(\"./events\"),\n    getEvents = _require2.getEvents;\n\nvar _require3 = require(\"./props\"),\n    getProps = _require3.getProps,\n    getPropProperties = _require3.getPropProperties;\n\nvar _require4 = require(\"./options\"),\n    getCommandOptions = _require4.getCommandOptions,\n    getOptions = _require4.getOptions;\n\nvar _require5 = require(\"./extends\"),\n    getExtendsProps = _require5.getExtendsProps,\n    removeKnownExtends = _require5.removeKnownExtends;\n\nfunction findComponentConfig(ast) {\n  var foundConfigs = [];\n  var defaultExports = ast.body.filter(function (node) {\n    return node.type === 'ExportDefaultDeclaration';\n  });\n  defaultExports.forEach(function (statement) {\n    var declaration = statement.declaration;\n\n    if (declaration.type === 'TypeCastExpression') {\n      declaration = declaration.expression;\n    }\n\n    try {\n      if (declaration.callee.name === 'codegenNativeComponent') {\n        var typeArgumentParams = declaration.typeArguments.params;\n        var funcArgumentParams = declaration.arguments;\n        var nativeComponentType = {};\n        nativeComponentType.propsTypeName = typeArgumentParams[0].id.name;\n        nativeComponentType.componentName = funcArgumentParams[0].value;\n\n        if (funcArgumentParams.length > 1) {\n          nativeComponentType.optionsExpression = funcArgumentParams[1];\n        }\n\n        foundConfigs.push(nativeComponentType);\n      }\n    } catch (e) {}\n  });\n\n  if (foundConfigs.length === 0) {\n    throw new Error('Could not find component config for native component');\n  }\n\n  if (foundConfigs.length > 1) {\n    throw new Error('Only one component is supported per file');\n  }\n\n  var foundConfig = foundConfigs[0];\n  var namedExports = ast.body.filter(function (node) {\n    return node.type === 'ExportNamedDeclaration';\n  });\n  var commandsTypeNames = namedExports.map(function (statement) {\n    var callExpression;\n    var calleeName;\n\n    try {\n      callExpression = statement.declaration.declarations[0].init;\n      calleeName = callExpression.callee.name;\n    } catch (e) {\n      return;\n    }\n\n    if (calleeName !== 'codegenNativeCommands') {\n      return;\n    }\n\n    if (callExpression.arguments.length !== 1) {\n      throw new Error('codegenNativeCommands must be passed options including the supported commands');\n    }\n\n    var typeArgumentParam = callExpression.typeArguments.params[0];\n\n    if (typeArgumentParam.type !== 'GenericTypeAnnotation') {\n      throw new Error(\"codegenNativeCommands doesn't support inline definitions. Specify a file local type alias\");\n    }\n\n    return {\n      commandTypeName: typeArgumentParam.id.name,\n      commandOptionsExpression: callExpression.arguments[0]\n    };\n  }).filter(Boolean);\n\n  if (commandsTypeNames.length > 1) {\n    throw new Error('codegenNativeCommands may only be called once in a file');\n  }\n\n  return _objectSpread(_objectSpread({}, foundConfig), {}, {\n    commandTypeName: commandsTypeNames[0] == null ? null : commandsTypeNames[0].commandTypeName,\n    commandOptionsExpression: commandsTypeNames[0] == null ? null : commandsTypeNames[0].commandOptionsExpression\n  });\n}\n\nfunction getCommandProperties(commandTypeName, types, commandOptions) {\n  if (commandTypeName == null) {\n    return [];\n  }\n\n  var typeAlias = types[commandTypeName];\n\n  if (typeAlias.type !== 'InterfaceDeclaration') {\n    throw new Error(\"The type argument for codegenNativeCommands must be an interface, received \" + typeAlias.type);\n  }\n\n  var properties;\n\n  try {\n    properties = typeAlias.body.properties;\n  } catch (e) {\n    throw new Error(\"Failed to find type definition for \\\"\" + commandTypeName + \"\\\", please check that you have a valid codegen flow file\");\n  }\n\n  var flowPropertyNames = properties.map(function (property) {\n    return property && property.key && property.key.name;\n  }).filter(Boolean);\n\n  if (commandOptions == null || commandOptions.supportedCommands == null) {\n    throw new Error('codegenNativeCommands must be given an options object with supportedCommands array');\n  }\n\n  if (commandOptions.supportedCommands.length !== flowPropertyNames.length || !commandOptions.supportedCommands.every(function (supportedCommand) {\n    return flowPropertyNames.includes(supportedCommand);\n  })) {\n    throw new Error(\"codegenNativeCommands expected the same supportedCommands specified in the \" + commandTypeName + \" interface: \" + flowPropertyNames.join(', '));\n  }\n\n  return properties;\n}\n\nfunction processComponent(ast, types) {\n  var _findComponentConfig = findComponentConfig(ast),\n      componentName = _findComponentConfig.componentName,\n      propsTypeName = _findComponentConfig.propsTypeName,\n      commandTypeName = _findComponentConfig.commandTypeName,\n      commandOptionsExpression = _findComponentConfig.commandOptionsExpression,\n      optionsExpression = _findComponentConfig.optionsExpression;\n\n  var propProperties = getPropProperties(propsTypeName, types);\n  var commandOptions = getCommandOptions(commandOptionsExpression);\n  var commandProperties = getCommandProperties(commandTypeName, types, commandOptions);\n  var extendsProps = getExtendsProps(propProperties, types);\n  var options = getOptions(optionsExpression);\n  var nonExtendsProps = removeKnownExtends(propProperties, types);\n  var props = getProps(nonExtendsProps, types);\n  var events = getEvents(propProperties, types);\n  var commands = getCommands(commandProperties, types);\n  return {\n    filename: componentName,\n    componentName: componentName,\n    options: options,\n    extendsProps: extendsProps,\n    events: events,\n    props: props,\n    commands: commands\n  };\n}\n\nmodule.exports = {\n  processComponent: processComponent\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/parsers/flow/components/index.js"],"names":["require","getCommands","getEvents","getProps","getPropProperties","getCommandOptions","getOptions","getExtendsProps","removeKnownExtends","findComponentConfig","ast","foundConfigs","defaultExports","body","filter","node","type","forEach","statement","declaration","expression","callee","name","typeArgumentParams","typeArguments","params","funcArgumentParams","arguments","nativeComponentType","propsTypeName","id","componentName","value","length","optionsExpression","push","e","Error","foundConfig","namedExports","commandsTypeNames","map","callExpression","calleeName","declarations","init","typeArgumentParam","commandTypeName","commandOptionsExpression","Boolean","getCommandProperties","types","commandOptions","typeAlias","properties","flowPropertyNames","property","key","supportedCommands","every","supportedCommand","includes","join","processComponent","propProperties","commandProperties","extendsProps","options","nonExtendsProps","props","events","commands","filename","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport type {ComponentSchemaBuilderConfig} from './schema.js';\nconst {getCommands} = require('./commands');\nconst {getEvents} = require('./events');\nconst {getProps, getPropProperties} = require('./props');\nconst {getCommandOptions, getOptions} = require('./options');\nconst {getExtendsProps, removeKnownExtends} = require('./extends');\n\nfunction findComponentConfig(ast) {\n  const foundConfigs = [];\n\n  const defaultExports = ast.body.filter(\n    node => node.type === 'ExportDefaultDeclaration',\n  );\n\n  defaultExports.forEach(statement => {\n    let declaration = statement.declaration;\n\n    // codegenNativeComponent can be nested inside a cast\n    // expression so we need to go one level deeper\n    if (declaration.type === 'TypeCastExpression') {\n      declaration = declaration.expression;\n    }\n\n    try {\n      if (declaration.callee.name === 'codegenNativeComponent') {\n        const typeArgumentParams = declaration.typeArguments.params;\n        const funcArgumentParams = declaration.arguments;\n\n        const nativeComponentType = {};\n        nativeComponentType.propsTypeName = typeArgumentParams[0].id.name;\n        nativeComponentType.componentName = funcArgumentParams[0].value;\n        if (funcArgumentParams.length > 1) {\n          nativeComponentType.optionsExpression = funcArgumentParams[1];\n        }\n        foundConfigs.push(nativeComponentType);\n      }\n    } catch (e) {\n      // ignore\n    }\n  });\n\n  if (foundConfigs.length === 0) {\n    throw new Error('Could not find component config for native component');\n  }\n  if (foundConfigs.length > 1) {\n    throw new Error('Only one component is supported per file');\n  }\n\n  const foundConfig = foundConfigs[0];\n\n  const namedExports = ast.body.filter(\n    node => node.type === 'ExportNamedDeclaration',\n  );\n\n  const commandsTypeNames = namedExports\n    .map(statement => {\n      let callExpression;\n      let calleeName;\n      try {\n        callExpression = statement.declaration.declarations[0].init;\n        calleeName = callExpression.callee.name;\n      } catch (e) {\n        return;\n      }\n\n      if (calleeName !== 'codegenNativeCommands') {\n        return;\n      }\n\n      // const statement.declaration.declarations[0].init\n      if (callExpression.arguments.length !== 1) {\n        throw new Error(\n          'codegenNativeCommands must be passed options including the supported commands',\n        );\n      }\n\n      const typeArgumentParam = callExpression.typeArguments.params[0];\n\n      if (typeArgumentParam.type !== 'GenericTypeAnnotation') {\n        throw new Error(\n          \"codegenNativeCommands doesn't support inline definitions. Specify a file local type alias\",\n        );\n      }\n\n      return {\n        commandTypeName: typeArgumentParam.id.name,\n        commandOptionsExpression: callExpression.arguments[0],\n      };\n    })\n    .filter(Boolean);\n\n  if (commandsTypeNames.length > 1) {\n    throw new Error('codegenNativeCommands may only be called once in a file');\n  }\n\n  return {\n    ...foundConfig,\n    commandTypeName:\n      commandsTypeNames[0] == null\n        ? null\n        : commandsTypeNames[0].commandTypeName,\n    commandOptionsExpression:\n      commandsTypeNames[0] == null\n        ? null\n        : commandsTypeNames[0].commandOptionsExpression,\n  };\n}\n\nfunction getCommandProperties(commandTypeName, types, commandOptions) {\n  if (commandTypeName == null) {\n    return [];\n  }\n\n  const typeAlias = types[commandTypeName];\n\n  if (typeAlias.type !== 'InterfaceDeclaration') {\n    throw new Error(\n      `The type argument for codegenNativeCommands must be an interface, received ${\n        typeAlias.type\n      }`,\n    );\n  }\n\n  let properties;\n  try {\n    properties = typeAlias.body.properties;\n  } catch (e) {\n    throw new Error(\n      `Failed to find type definition for \"${commandTypeName}\", please check that you have a valid codegen flow file`,\n    );\n  }\n\n  const flowPropertyNames = properties\n    .map(property => property && property.key && property.key.name)\n    .filter(Boolean);\n\n  if (commandOptions == null || commandOptions.supportedCommands == null) {\n    throw new Error(\n      'codegenNativeCommands must be given an options object with supportedCommands array',\n    );\n  }\n\n  if (\n    commandOptions.supportedCommands.length !== flowPropertyNames.length ||\n    !commandOptions.supportedCommands.every(supportedCommand =>\n      flowPropertyNames.includes(supportedCommand),\n    )\n  ) {\n    throw new Error(\n      `codegenNativeCommands expected the same supportedCommands specified in the ${commandTypeName} interface: ${flowPropertyNames.join(\n        ', ',\n      )}`,\n    );\n  }\n\n  return properties;\n}\n\n// $FlowFixMe there's no flowtype for AST\nfunction processComponent(ast, types): ComponentSchemaBuilderConfig {\n  const {\n    componentName,\n    propsTypeName,\n    commandTypeName,\n    commandOptionsExpression,\n    optionsExpression,\n  } = findComponentConfig(ast);\n\n  const propProperties = getPropProperties(propsTypeName, types);\n  const commandOptions = getCommandOptions(commandOptionsExpression);\n\n  const commandProperties = getCommandProperties(\n    commandTypeName,\n    types,\n    commandOptions,\n  );\n\n  const extendsProps = getExtendsProps(propProperties, types);\n  const options = getOptions(optionsExpression);\n\n  const nonExtendsProps = removeKnownExtends(propProperties, types);\n  const props = getProps(nonExtendsProps, types);\n  const events = getEvents(propProperties, types);\n  const commands = getCommands(commandProperties, types);\n\n  return {\n    filename: componentName,\n    componentName,\n    options,\n    extendsProps,\n    events,\n    props,\n    commands,\n  };\n}\n\nmodule.exports = {\n  processComponent,\n};\n"]},"metadata":{},"sourceType":"script"}