{"ast":null,"code":"\"use strict\";\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar Xcodeproj_1 = require(\"../ios/utils/Xcodeproj\");\n\nvar compiler_plugins_1 = require(\"./compiler-plugins\");\n\nfunction compileModsAsync(config, props) {\n  return _regeneratorRuntime.async(function compileModsAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          config = compiler_plugins_1.withBaseMods(config);\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(evalModsAsync(config, props));\n\n        case 3:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.compileModsAsync = compileModsAsync;\n\nfunction sortMods(commands, order) {\n  var allKeys = commands.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        key = _ref2[0];\n\n    return key;\n  });\n\n  var completeOrder = _toConsumableArray(new Set([].concat(_toConsumableArray(order), _toConsumableArray(allKeys))));\n\n  var sorted = [];\n\n  var _loop = function _loop() {\n    var group = completeOrder.shift();\n    var commandSet = commands.find(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          key = _ref4[0];\n\n      return key === group;\n    });\n\n    if (commandSet) {\n      sorted.push(commandSet);\n    }\n  };\n\n  while (completeOrder.length) {\n    _loop();\n  }\n\n  return sorted;\n}\n\nvar orders = {\n  ios: ['dangerous', 'xcodeproj'],\n  android: ['dangerous']\n};\n\nfunction evalModsAsync(config, _ref5) {\n  var projectRoot, platforms, _a, _i, _Object$entries, _ref6, _ref7, platformName, platform, entries, platformProjectRoot, projectName, _iterator, _step, _ref8, _ref9, modName, mod, modRequest, results;\n\n  return _regeneratorRuntime.async(function evalModsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          projectRoot = _ref5.projectRoot, platforms = _ref5.platforms;\n          _i = 0, _Object$entries = Object.entries((_a = config.mods) !== null && _a !== void 0 ? _a : {});\n\n        case 2:\n          if (!(_i < _Object$entries.length)) {\n            _context2.next = 32;\n            break;\n          }\n\n          _ref6 = _Object$entries[_i];\n          _ref7 = _slicedToArray(_ref6, 2);\n          platformName = _ref7[0];\n          platform = _ref7[1];\n\n          if (!(platforms && !platforms.includes(platformName))) {\n            _context2.next = 9;\n            break;\n          }\n\n          return _context2.abrupt(\"continue\", 29);\n\n        case 9:\n          entries = Object.entries(platform);\n\n          if (!entries.length) {\n            _context2.next = 29;\n            break;\n          }\n\n          entries = sortMods(entries, orders[platformName]);\n          platformProjectRoot = path_1.default.join(projectRoot, platformName);\n          projectName = platformName === 'ios' ? Xcodeproj_1.getHackyProjectName(projectRoot, config) : undefined;\n          _iterator = _createForOfIteratorHelperLoose(entries);\n\n        case 15:\n          if ((_step = _iterator()).done) {\n            _context2.next = 29;\n            break;\n          }\n\n          _ref8 = _step.value;\n          _ref9 = _slicedToArray(_ref8, 2);\n          modName = _ref9[0];\n          mod = _ref9[1];\n          modRequest = {\n            projectRoot: projectRoot,\n            projectName: projectName,\n            platformProjectRoot: platformProjectRoot,\n            platform: platformName,\n            modName: modName\n          };\n          _context2.next = 23;\n          return _regeneratorRuntime.awrap(mod(_extends(_extends({}, config), {\n            modResults: null,\n            modRequest: modRequest\n          })));\n\n        case 23:\n          results = _context2.sent;\n          config = compiler_plugins_1.resolveModResults(results, platformName, modName);\n          delete config.modResults;\n          delete config.modRequest;\n\n        case 27:\n          _context2.next = 15;\n          break;\n\n        case 29:\n          _i++;\n          _context2.next = 2;\n          break;\n\n        case 32:\n          return _context2.abrupt(\"return\", config);\n\n        case 33:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.evalModsAsync = evalModsAsync;","map":{"version":3,"sources":["../../src/plugins/mod-compiler.ts"],"names":[],"mappings":"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","sourcesContent":["import path from 'path';\n\nimport { ExportedConfig, Mod, ModConfig, ModPlatform } from '../Plugin.types';\nimport { getHackyProjectName } from '../ios/utils/Xcodeproj';\nimport { resolveModResults, withBaseMods } from './compiler-plugins';\n\n/**\n *\n * @param projectRoot\n * @param config\n */\nexport async function compileModsAsync(\n  config: ExportedConfig,\n  props: { projectRoot: string; platforms?: ModPlatform[] }\n): Promise<ExportedConfig> {\n  config = withBaseMods(config);\n  return await evalModsAsync(config, props);\n}\n\nfunction sortMods(commands: [string, any][], order: string[]): [string, any][] {\n  const allKeys = commands.map(([key]) => key);\n  const completeOrder = [...new Set([...order, ...allKeys])];\n  const sorted: [string, any][] = [];\n  while (completeOrder.length) {\n    const group = completeOrder.shift()!;\n    const commandSet = commands.find(([key]) => key === group);\n    if (commandSet) {\n      sorted.push(commandSet);\n    }\n  }\n  return sorted;\n}\n\nconst orders: Record<string, string[]> = {\n  ios: [\n    // dangerous runs first\n    'dangerous',\n    // run the XcodeProject mod second because many plugins attempt to read from it.\n    'xcodeproj',\n  ],\n  android: ['dangerous'],\n};\n/**\n * A generic plugin compiler.\n *\n * @param config\n */\nexport async function evalModsAsync(\n  config: ExportedConfig,\n  { projectRoot, platforms }: { projectRoot: string; platforms?: ModPlatform[] }\n): Promise<ExportedConfig> {\n  for (const [platformName, platform] of Object.entries(config.mods ?? ({} as ModConfig))) {\n    if (platforms && !platforms.includes(platformName as any)) {\n      continue;\n    }\n\n    let entries = Object.entries(platform);\n    if (entries.length) {\n      // Move dangerous item to the first position if it exists, this ensures that all dangerous code runs first.\n      entries = sortMods(entries, orders[platformName]!);\n\n      const platformProjectRoot = path.join(projectRoot, platformName);\n      const projectName =\n        platformName === 'ios' ? getHackyProjectName(projectRoot, config) : undefined;\n\n      for (const [modName, mod] of entries) {\n        const modRequest = {\n          projectRoot,\n          projectName,\n          platformProjectRoot,\n          platform: platformName as ModPlatform,\n          modName,\n        };\n\n        const results = await (mod as Mod)({\n          ...config,\n          modResults: null,\n          modRequest,\n        });\n\n        // Sanity check to help locate non compliant mods.\n        config = resolveModResults(results, platformName, modName);\n        // @ts-ignore: data is added for modifications\n        delete config.modResults;\n        // @ts-ignore: info is added for modifications\n        delete config.modRequest;\n      }\n    }\n  }\n\n  return config;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}