{"ast":null,"code":"'use strict';\n\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _jsxFileName = \"/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/src/vendor/react-native/SectionList/index.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Platform from \"../../../exports/Platform\";\nimport * as React from 'react';\nimport ScrollView from \"../../../exports/ScrollView\";\nimport VirtualizedSectionList from \"../VirtualizedSectionList\";\n\nvar defaultProps = _objectSpread(_objectSpread({}, VirtualizedSectionList.defaultProps), {}, {\n  stickySectionHeadersEnabled: Platform.OS === 'ios'\n});\n\nvar SectionList = function (_React$PureComponent) {\n  _inherits(SectionList, _React$PureComponent);\n\n  var _super = _createSuper(SectionList);\n\n  function SectionList() {\n    var _this;\n\n    _classCallCheck(this, SectionList);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this._captureRef = function (ref) {\n      _this._wrapperListRef = ref;\n    };\n\n    return _this;\n  }\n\n  _createClass(SectionList, [{\n    key: \"scrollToLocation\",\n    value: function scrollToLocation(params) {\n      if (this._wrapperListRef != null) {\n        this._wrapperListRef.scrollToLocation(params);\n      }\n    }\n  }, {\n    key: \"recordInteraction\",\n    value: function recordInteraction() {\n      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n\n      listRef && listRef.recordInteraction();\n    }\n  }, {\n    key: \"flashScrollIndicators\",\n    value: function flashScrollIndicators() {\n      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n\n      listRef && listRef.flashScrollIndicators();\n    }\n  }, {\n    key: \"getScrollResponder\",\n    value: function getScrollResponder() {\n      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n\n      if (listRef) {\n        return listRef.getScrollResponder();\n      }\n    }\n  }, {\n    key: \"getScrollableNode\",\n    value: function getScrollableNode() {\n      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n\n      if (listRef) {\n        return listRef.getScrollableNode();\n      }\n    }\n  }, {\n    key: \"setNativeProps\",\n    value: function setNativeProps(props) {\n      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n\n      if (listRef) {\n        listRef.setNativeProps(props);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(VirtualizedSectionList, _extends({}, this.props, {\n        ref: this._captureRef,\n        getItemCount: function getItemCount(items) {\n          return items.length;\n        },\n        getItem: function getItem(items, index) {\n          return items[index];\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 309,\n          columnNumber: 7\n        }\n      }));\n    }\n  }]);\n\n  return SectionList;\n}(React.PureComponent);\n\nSectionList.defaultProps = defaultProps;\nexport default SectionList;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native-web/src/vendor/react-native/SectionList/index.js"],"names":["Platform","React","ScrollView","VirtualizedSectionList","defaultProps","stickySectionHeadersEnabled","OS","SectionList","_captureRef","ref","_wrapperListRef","params","scrollToLocation","listRef","getListRef","recordInteraction","flashScrollIndicators","getScrollResponder","getScrollableNode","props","setNativeProps","items","length","index","PureComponent"],"mappings":"AASA;;;;;;;;;;;;;;;;;;;AAEA,OAAOA,QAAP;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAOC,UAAP;AACA,OAAOC,sBAAP;;AA0JA,IAAMC,YAAY,mCACbD,sBAAsB,CAACC,YADV;AAEhBC,EAAAA,2BAA2B,EAAEL,QAAQ,CAACM,EAAT,KAAgB;AAF7B,EAAlB;;IA8DMC,W;;;;;;;;;;;;;;;;UAyFJC,W,GAAc,UAAAC,GAAG,EAAI;AAEnB,YAAKC,eAAL,GAAuBD,GAAvB;AACD,K;;;;;;;WA3ED,0BAAiBE,MAAjB,EAMG;AACD,UAAI,KAAKD,eAAL,IAAwB,IAA5B,EAAkC;AAChC,aAAKA,eAAL,CAAqBE,gBAArB,CAAsCD,MAAtC;AACD;AACF;;;WAOD,6BAAoB;AAClB,UAAME,OAAO,GAAG,KAAKH,eAAL,IAAwB,KAAKA,eAAL,CAAqBI,UAArB,EAAxC;;AACAD,MAAAA,OAAO,IAAIA,OAAO,CAACE,iBAAR,EAAX;AACD;;;WAOD,iCAAwB;AACtB,UAAMF,OAAO,GAAG,KAAKH,eAAL,IAAwB,KAAKA,eAAL,CAAqBI,UAArB,EAAxC;;AACAD,MAAAA,OAAO,IAAIA,OAAO,CAACG,qBAAR,EAAX;AACD;;;WAKD,8BAAkC;AAChC,UAAMH,OAAO,GAAG,KAAKH,eAAL,IAAwB,KAAKA,eAAL,CAAqBI,UAArB,EAAxC;;AACA,UAAID,OAAJ,EAAa;AACX,eAAOA,OAAO,CAACI,kBAAR,EAAP;AACD;AACF;;;WAED,6BAAoB;AAClB,UAAMJ,OAAO,GAAG,KAAKH,eAAL,IAAwB,KAAKA,eAAL,CAAqBI,UAArB,EAAxC;;AACA,UAAID,OAAJ,EAAa;AACX,eAAOA,OAAO,CAACK,iBAAR,EAAP;AACD;AACF;;;WAED,wBAAeC,KAAf,EAA8B;AAC5B,UAAMN,OAAO,GAAG,KAAKH,eAAL,IAAwB,KAAKA,eAAL,CAAqBI,UAArB,EAAxC;;AACA,UAAID,OAAJ,EAAa;AACXA,QAAAA,OAAO,CAACO,cAAR,CAAuBD,KAAvB;AACD;AACF;;;WAED,kBAAS;AACP,aAIE,oBAAC,sBAAD,eACM,KAAKA,KADX;AAEE,QAAA,GAAG,EAAE,KAAKX,WAFZ;AAGE,QAAA,YAAY,EAAE,sBAAAa,KAAK;AAAA,iBAAIA,KAAK,CAACC,MAAV;AAAA,SAHrB;AAIE,QAAA,OAAO,EAAE,iBAACD,KAAD,EAAQE,KAAR;AAAA,iBAAkBF,KAAK,CAACE,KAAD,CAAvB;AAAA,SAJX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAJF;AAWD;;;;EArFmDtB,KAAK,CAACuB,a;;AAAtDjB,W,CAKGH,Y,GAA6BA,Y;AA0FtC,eAAeG,WAAf","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nimport Platform from '../../../exports/Platform';\nimport * as React from 'react';\nimport ScrollView from '../../../exports/ScrollView';\nimport VirtualizedSectionList from '../VirtualizedSectionList';\n\nimport type {ViewToken} from '../ViewabilityHelper';\nimport type {\n  SectionBase as _SectionBase,\n  Props as VirtualizedSectionListProps,\n} from '../VirtualizedSectionList';\n\ntype Item = any;\n\nexport type SectionBase<SectionItemT> = _SectionBase<SectionItemT>;\n\ntype RequiredProps<SectionT: SectionBase<any>> = {\n  /**\n   * The actual data to render, akin to the `data` prop in [`<FlatList>`](/react-native/docs/flatlist.html).\n   *\n   * General shape:\n   *\n   *     sections: $ReadOnlyArray<{\n   *       data: $ReadOnlyArray<SectionItem>,\n   *       renderItem?: ({item: SectionItem, ...}) => ?React.Element<*>,\n   *       ItemSeparatorComponent?: ?ReactClass<{highlighted: boolean, ...}>,\n   *     }>\n   */\n  sections: $ReadOnlyArray<SectionT>,\n};\n\ntype OptionalProps<SectionT: SectionBase<any>> = {\n  /**\n   * Default renderer for every item in every section. Can be over-ridden on a per-section basis.\n   */\n  renderItem?: (info: {\n    item: Item,\n    index: number,\n    section: SectionT,\n    separators: {\n      highlight: () => void,\n      unhighlight: () => void,\n      updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n    },\n  }) => ?React.Element<any>,\n  /**\n   * Rendered in between each item, but not at the top or bottom. By default, `highlighted`,\n   * `section`, and `[leading/trailing][Item/Separator]` props are provided. `renderItem` provides\n   * `separators.highlight`/`unhighlight` which will update the `highlighted` prop, but you can also\n   * add custom props with `separators.updateProps`.\n   */\n  ItemSeparatorComponent?: ?React.ComponentType<any>,\n  /**\n   * Rendered at the very beginning of the list. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListHeaderComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Rendered when the list is empty. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListEmptyComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Rendered at the very end of the list. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListFooterComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Rendered at the top and bottom of each section (note this is different from\n   * `ItemSeparatorComponent` which is only rendered between items). These are intended to separate\n   * sections from the headers above and below and typically have the same highlight response as\n   * `ItemSeparatorComponent`. Also receives `highlighted`, `[leading/trailing][Item/Separator]`,\n   * and any custom props from `separators.updateProps`.\n   */\n  SectionSeparatorComponent?: ?React.ComponentType<any>,\n  /**\n   * A marker property for telling the list to re-render (since it implements `PureComponent`). If\n   * any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the\n   * `data` prop, stick it here and treat it immutably.\n   */\n  extraData?: any,\n  /**\n   * How many items to render in the initial batch. This should be enough to fill the screen but not\n   * much more. Note these items will never be unmounted as part of the windowed rendering in order\n   * to improve perceived performance of scroll-to-top actions.\n   */\n  initialNumToRender: number,\n  /**\n   * Reverses the direction of scroll. Uses scale transforms of -1.\n   */\n  inverted?: ?boolean,\n  /**\n   * Used to extract a unique key for a given item at the specified index. Key is used for caching\n   * and as the react key to track item re-ordering. The default extractor checks item.key, then\n   * falls back to using the index, like react does. Note that this sets keys for each item, but\n   * each overall section still needs its own key.\n   */\n  keyExtractor: (item: Item, index: number) => string,\n  /**\n   * Called once when the scroll position gets within `onEndReachedThreshold` of the rendered\n   * content.\n   */\n  onEndReached?: ?(info: {distanceFromEnd: number}) => void,\n  /**\n   * How far from the end (in units of visible length of the list) the bottom edge of the\n   * list must be from the end of the content to trigger the `onEndReached` callback.\n   * Thus a value of 0.5 will trigger `onEndReached` when the end of the content is\n   * within half the visible length of the list.\n   */\n  onEndReachedThreshold?: ?number,\n  /**\n   * If provided, a standard RefreshControl will be added for \"Pull to Refresh\" functionality. Make\n   * sure to also set the `refreshing` prop correctly.\n   */\n  onRefresh?: ?() => void,\n  /**\n   * Called when the viewability of rows changes, as defined by the\n   * `viewabilityConfig` prop.\n   */\n  onViewableItemsChanged?: ?(info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n  }) => void,\n  /**\n   * Set this true while waiting for new data from a refresh.\n   */\n  refreshing?: ?boolean,\n  /**\n   * Note: may have bugs (missing content) in some circumstances - use at your own risk.\n   *\n   * This may improve scroll performance for large lists.\n   */\n  removeClippedSubviews?: boolean,\n  /**\n   * Rendered at the top of each section. These stick to the top of the `ScrollView` by default on\n   * iOS. See `stickySectionHeadersEnabled`.\n   */\n  renderSectionHeader?: ?(info: {section: SectionT}) => ?React.Element<any>,\n  /**\n   * Rendered at the bottom of each section.\n   */\n  renderSectionFooter?: ?(info: {section: SectionT}) => ?React.Element<any>,\n  /**\n   * Makes section headers stick to the top of the screen until the next one pushes it off. Only\n   * enabled by default on iOS because that is the platform standard there.\n   */\n  stickySectionHeadersEnabled?: boolean,\n\n  /**\n   * The legacy implementation is no longer supported.\n   */\n  legacyImplementation?: empty,\n};\n\nexport type Props<SectionT> = RequiredProps<SectionT> &\n  OptionalProps<SectionT> &\n  VirtualizedSectionListProps<SectionT>;\n\nconst defaultProps = {\n  ...VirtualizedSectionList.defaultProps,\n  stickySectionHeadersEnabled: Platform.OS === 'ios',\n};\n\ntype DefaultProps = typeof defaultProps;\n\n/**\n * A performant interface for rendering sectioned lists, supporting the most handy features:\n *\n *  - Fully cross-platform.\n *  - Configurable viewability callbacks.\n *  - List header support.\n *  - List footer support.\n *  - Item separator support.\n *  - Section header support.\n *  - Section separator support.\n *  - Heterogeneous data and item rendering support.\n *  - Pull to Refresh.\n *  - Scroll loading.\n *\n * If you don't need section support and want a simpler interface, use\n * [`<FlatList>`](/react-native/docs/flatlist.html).\n *\n * Simple Examples:\n *\n *     <SectionList\n *       renderItem={({item}) => <ListItem title={item} />}\n *       renderSectionHeader={({section}) => <Header title={section.title} />}\n *       sections={[ // homogeneous rendering between sections\n *         {data: [...], title: ...},\n *         {data: [...], title: ...},\n *         {data: [...], title: ...},\n *       ]}\n *     />\n *\n *     <SectionList\n *       sections={[ // heterogeneous rendering between sections\n *         {data: [...], renderItem: ...},\n *         {data: [...], renderItem: ...},\n *         {data: [...], renderItem: ...},\n *       ]}\n *     />\n *\n * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist.html),\n * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed\n * here, along with the following caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate and momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n *\n */\nclass SectionList<SectionT: SectionBase<any>> extends React.PureComponent<\n  Props<SectionT>,\n  void,\n> {\n  props: Props<SectionT>;\n  static defaultProps: DefaultProps = defaultProps;\n\n  /**\n   * Scrolls to the item at the specified `sectionIndex` and `itemIndex` (within the section)\n   * positioned in the viewable area such that `viewPosition` 0 places it at the top (and may be\n   * covered by a sticky header), 1 at the bottom, and 0.5 centered in the middle. `viewOffset` is a\n   * fixed number of pixels to offset the final target position, e.g. to compensate for sticky\n   * headers.\n   *\n   * Note: cannot scroll to locations outside the render window without specifying the\n   * `getItemLayout` prop.\n   */\n  scrollToLocation(params: {\n    animated?: ?boolean,\n    itemIndex: number,\n    sectionIndex: number,\n    viewOffset?: number,\n    viewPosition?: number,\n  }) {\n    if (this._wrapperListRef != null) {\n      this._wrapperListRef.scrollToLocation(params);\n    }\n  }\n\n  /**\n   * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.\n   * if `waitForInteractions` is true and the user has not scrolled. This is typically called by\n   * taps on items or by navigation actions.\n   */\n  recordInteraction() {\n    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    listRef && listRef.recordInteraction();\n  }\n\n  /**\n   * Displays the scroll indicators momentarily.\n   *\n   * @platform ios\n   */\n  flashScrollIndicators() {\n    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    listRef && listRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   */\n  getScrollResponder(): ?ScrollView {\n    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    if (listRef) {\n      return listRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode() {\n    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    if (listRef) {\n      return listRef.getScrollableNode();\n    }\n  }\n\n  setNativeProps(props: Object) {\n    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();\n    if (listRef) {\n      listRef.setNativeProps(props);\n    }\n  }\n\n  render() {\n    return (\n      /* $FlowFixMe(>=0.66.0 site=react_native_fb) This comment suppresses an\n       * error found when Flow v0.66 was deployed. To see the error delete this\n       * comment and run Flow. */\n      <VirtualizedSectionList\n        {...this.props}\n        ref={this._captureRef}\n        getItemCount={items => items.length}\n        getItem={(items, index) => items[index]}\n      />\n    );\n  }\n\n  _wrapperListRef: ?React.ElementRef<typeof VirtualizedSectionList>;\n  // $FlowFixMe\n  _captureRef = ref => {\n    // $FlowFixMe\n    this._wrapperListRef = ref;\n  };\n}\n\nexport default SectionList;\n"]},"metadata":{},"sourceType":"module"}