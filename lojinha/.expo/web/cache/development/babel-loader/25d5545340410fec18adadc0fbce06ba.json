{"ast":null,"code":"var _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar lodashTemplate = require('lodash.template');\n\nvar fromPairs = require('lodash.frompairs');\n\nvar fs = require('fs');\n\nfunction extractGlyphMapFromCss(files, selectorPattern) {\n  var styleRulePattern = '(\\\\.[A-Za-z0-9_.:, \\\\n\\\\t-]+)\\\\{[^}]*content: ?[\"\\\\\\'](?:\\\\\\\\([A-Fa-f0-9]+)|([^\"\\\\\\']+))[\"\\\\\\'][^}]*\\\\}';\n  var allStyleRules = new RegExp(styleRulePattern, 'g');\n  var singleStyleRules = new RegExp(styleRulePattern);\n  var allSelectors = new RegExp(selectorPattern, 'g');\n  var singleSelector = new RegExp(selectorPattern);\n\n  var extractGlyphFromRule = function extractGlyphFromRule(rule) {\n    var ruleParts = rule.match(singleStyleRules);\n\n    if (ruleParts[2]) {\n      return parseInt(ruleParts[2], 16);\n    }\n\n    if (ruleParts[3].length > 1) {\n      return ruleParts[3];\n    }\n\n    return ruleParts[3].charCodeAt();\n  };\n\n  var extractSelectorsFromRule = function extractSelectorsFromRule(rule) {\n    var ruleParts = rule.match(singleStyleRules);\n    var selectors = ruleParts[1].match(allSelectors) || [];\n    return selectors.map(function (selector) {\n      return selector.match(singleSelector)[1];\n    });\n  };\n\n  return (typeof files === 'string' ? [files] : files).map(function (fileName) {\n    return fs.readFileSync(fileName, {\n      encoding: 'utf8'\n    });\n  }).map(function (contents) {\n    return contents.match(allStyleRules) || [];\n  }).reduce(function (acc, rules) {\n    return acc.concat(rules);\n  }, []).map(function (rule) {\n    var glyph = extractGlyphFromRule(rule);\n    var selectors = extractSelectorsFromRule(rule);\n    return selectors.map(function (selector) {\n      return [selector, glyph];\n    });\n  }).reduce(function (acc, glyphs) {\n    return _extends(acc, fromPairs(glyphs));\n  }, {});\n}\n\nfunction escapeRegExp(str) {\n  return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\n\nfunction generateIconSetFromCss(cssFiles, selectorPrefix, template) {\n  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var glyphMap = extractGlyphMapFromCss(cssFiles, escapeRegExp(selectorPrefix) + \"([A-Za-z0-9_-]+)::?before\");\n  var content = JSON.stringify(glyphMap, null, '  ');\n\n  if (template) {\n    return lodashTemplate(template)(_objectSpread({\n      glyphMap: content\n    }, data));\n  }\n\n  return content;\n}\n\nmodule.exports = generateIconSetFromCss;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/lib/generate-icon-set-from-css.js"],"names":["lodashTemplate","require","fromPairs","fs","extractGlyphMapFromCss","files","selectorPattern","styleRulePattern","allStyleRules","RegExp","singleStyleRules","allSelectors","singleSelector","extractGlyphFromRule","rule","ruleParts","match","parseInt","length","charCodeAt","extractSelectorsFromRule","selectors","map","selector","fileName","readFileSync","encoding","contents","reduce","acc","rules","concat","glyph","glyphs","escapeRegExp","str","replace","generateIconSetFromCss","cssFiles","selectorPrefix","template","data","glyphMap","content","JSON","stringify","module","exports"],"mappings":"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","sourcesContent":["const lodashTemplate = require('lodash.template');\nconst fromPairs = require('lodash.frompairs');\nconst fs = require('fs');\n\nfunction extractGlyphMapFromCss(files, selectorPattern) {\n  const styleRulePattern =\n    '(\\\\.[A-Za-z0-9_.:, \\\\n\\\\t-]+)\\\\{[^}]*content: ?[\"\\\\\\'](?:\\\\\\\\([A-Fa-f0-9]+)|([^\"\\\\\\']+))[\"\\\\\\'][^}]*\\\\}';\n  const allStyleRules = new RegExp(styleRulePattern, 'g');\n  const singleStyleRules = new RegExp(styleRulePattern);\n  const allSelectors = new RegExp(selectorPattern, 'g');\n  const singleSelector = new RegExp(selectorPattern);\n\n  const extractGlyphFromRule = rule => {\n    const ruleParts = rule.match(singleStyleRules);\n    if (ruleParts[2]) {\n      // Hex value in CSS\n      return parseInt(ruleParts[2], 16);\n    }\n    if (ruleParts[3].length > 1) {\n      // String value in CSS that we'll keep as a string because it's not a single character\n      return ruleParts[3];\n    }\n    // String value in CSS that we'll convert to a charcode\n    return ruleParts[3].charCodeAt();\n  };\n\n  const extractSelectorsFromRule = rule => {\n    const ruleParts = rule.match(singleStyleRules);\n    const selectors = ruleParts[1].match(allSelectors) || [];\n    return selectors.map(selector => selector.match(singleSelector)[1]);\n  };\n\n  return (typeof files === 'string' ? [files] : files)\n    .map(fileName => fs.readFileSync(fileName, { encoding: 'utf8' }))\n    .map(contents => contents.match(allStyleRules) || [])\n    .reduce((acc, rules) => acc.concat(rules), [])\n    .map(rule => {\n      const glyph = extractGlyphFromRule(rule);\n      const selectors = extractSelectorsFromRule(rule);\n      return selectors.map(selector => [selector, glyph]);\n    })\n    .reduce((acc, glyphs) => Object.assign(acc, fromPairs(glyphs)), {});\n}\n\nfunction escapeRegExp(str) {\n  return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\n\nfunction generateIconSetFromCss(cssFiles, selectorPrefix, template, data = {}) {\n  const glyphMap = extractGlyphMapFromCss(\n    cssFiles,\n    `${escapeRegExp(selectorPrefix)}([A-Za-z0-9_-]+)::?before`\n  );\n  const content = JSON.stringify(glyphMap, null, '  ');\n  if (template) {\n    return lodashTemplate(template)({ glyphMap: content, ...data });\n  }\n  return content;\n}\n\nmodule.exports = generateIconSetFromCss;\n"]},"metadata":{},"sourceType":"script"}