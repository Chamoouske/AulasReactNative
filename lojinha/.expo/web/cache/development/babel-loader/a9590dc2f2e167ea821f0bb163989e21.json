{"ast":null,"code":"'use strict';\n\nvar flowParser = require('flow-parser');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar _require = require(\"./modules/schema\"),\n    buildModuleSchema = _require.buildModuleSchema;\n\nvar _require2 = require(\"./components/schema\"),\n    buildComponentSchema = _require2.buildComponentSchema;\n\nvar _require3 = require(\"./components\"),\n    processComponent = _require3.processComponent;\n\nvar _require4 = require(\"./modules\"),\n    processModule = _require4.processModule;\n\nfunction getTypes(ast) {\n  return ast.body.reduce(function (types, node) {\n    if (node.type === 'ExportNamedDeclaration') {\n      if (node.declaration && node.declaration.type !== 'VariableDeclaration') {\n        types[node.declaration.id.name] = node.declaration;\n      }\n    } else if (node.type === 'TypeAlias' || node.type === 'InterfaceDeclaration') {\n      types[node.id.name] = node;\n    }\n\n    return types;\n  }, {});\n}\n\nfunction getConfigType(ast, types) {\n  var defaultExports = ast.body.filter(function (node) {\n    return node.type === 'ExportDefaultDeclaration';\n  });\n  var isComponent = false;\n\n  if (defaultExports.length > 0) {\n    var declaration = defaultExports[0].declaration;\n\n    if (declaration.type === 'TypeCastExpression') {\n      declaration = declaration.expression;\n    }\n\n    isComponent = declaration && declaration.callee && declaration.callee.name === 'codegenNativeComponent';\n  }\n\n  var typesExtendingTurboModule = Object.keys(types).map(function (typeName) {\n    return types[typeName];\n  }).filter(function (type) {\n    return type.extends && type.extends[0] && type.extends[0].id.name === 'TurboModule';\n  });\n\n  if (typesExtendingTurboModule.length > 1) {\n    throw new Error('Found two types extending \"TurboModule\" is one file. Split them into separated files.');\n  }\n\n  var isModule = typesExtendingTurboModule.length === 1;\n\n  if (isModule && isComponent) {\n    throw new Error('Found type extending \"TurboModule\" and exported \"codegenNativeComponent\" declaration in one file. Split them into separated files.');\n  }\n\n  if (isModule) {\n    return 'module';\n  } else if (isComponent) {\n    return 'component';\n  } else {\n    throw new Error(\"Default export for module specified incorrectly. It should containts\\n    either type extending \\\"TurboModule\\\" or \\\"codegenNativeComponent\\\".\");\n  }\n}\n\nfunction buildSchema(contents, filename) {\n  var ast = flowParser.parse(contents);\n  var types = getTypes(ast);\n  var configType = getConfigType(ast, types);\n\n  if (configType === 'component') {\n    return buildComponentSchema(processComponent(ast, types));\n  } else {\n    if (filename === undefined || filename === null) {\n      throw new Error('Filepath expected while parasing a module');\n    }\n\n    var moduleName = path.basename(filename).slice(6, -3);\n    return buildModuleSchema(processModule(types), moduleName);\n  }\n}\n\nfunction parseFile(filename) {\n  var contents = fs.readFileSync(filename, 'utf8');\n  return buildSchema(contents, filename);\n}\n\nfunction parseModuleFixture(filename) {\n  var contents = fs.readFileSync(filename, 'utf8');\n  return buildSchema(contents, 'path/NativeSampleTurboModule.js');\n}\n\nfunction parseString(contents) {\n  return buildSchema(contents);\n}\n\nmodule.exports = {\n  parseFile: parseFile,\n  parseModuleFixture: parseModuleFixture,\n  parseString: parseString\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/parsers/flow/index.js"],"names":["flowParser","require","fs","path","buildModuleSchema","buildComponentSchema","processComponent","processModule","getTypes","ast","body","reduce","types","node","type","declaration","id","name","getConfigType","defaultExports","filter","isComponent","length","expression","callee","typesExtendingTurboModule","Object","keys","map","typeName","extends","Error","isModule","buildSchema","contents","filename","parse","configType","undefined","moduleName","basename","slice","parseFile","readFileSync","parseModuleFixture","parseString","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport type {SchemaType} from '../../CodegenSchema.js';\n// $FlowFixMe there's no flowtype flow-parser\nconst flowParser = require('flow-parser');\nconst fs = require('fs');\nconst path = require('path');\nconst {buildModuleSchema} = require('./modules/schema');\nconst {buildComponentSchema} = require('./components/schema');\nconst {processComponent} = require('./components');\nconst {processModule} = require('./modules');\n\nfunction getTypes(ast) {\n  return ast.body.reduce((types, node) => {\n    if (node.type === 'ExportNamedDeclaration') {\n      if (node.declaration && node.declaration.type !== 'VariableDeclaration') {\n        types[node.declaration.id.name] = node.declaration;\n      }\n    } else if (\n      node.type === 'TypeAlias' ||\n      node.type === 'InterfaceDeclaration'\n    ) {\n      types[node.id.name] = node;\n    }\n    return types;\n  }, {});\n}\n\nfunction getConfigType(ast, types): 'module' | 'component' {\n  const defaultExports = ast.body.filter(\n    node => node.type === 'ExportDefaultDeclaration',\n  );\n\n  let isComponent = false;\n\n  if (defaultExports.length > 0) {\n    let declaration = defaultExports[0].declaration;\n    // codegenNativeComponent can be nested inside a cast\n    // expression so we need to go one level deeper\n    if (declaration.type === 'TypeCastExpression') {\n      declaration = declaration.expression;\n    }\n\n    isComponent =\n      declaration &&\n      declaration.callee &&\n      declaration.callee.name === 'codegenNativeComponent';\n  }\n\n  const typesExtendingTurboModule = Object.keys(types)\n    .map(typeName => types[typeName])\n    .filter(\n      type =>\n        type.extends &&\n        type.extends[0] &&\n        type.extends[0].id.name === 'TurboModule',\n    );\n\n  if (typesExtendingTurboModule.length > 1) {\n    throw new Error(\n      'Found two types extending \"TurboModule\" is one file. Split them into separated files.',\n    );\n  }\n\n  const isModule = typesExtendingTurboModule.length === 1;\n\n  if (isModule && isComponent) {\n    throw new Error(\n      'Found type extending \"TurboModule\" and exported \"codegenNativeComponent\" declaration in one file. Split them into separated files.',\n    );\n  }\n\n  if (isModule) {\n    return 'module';\n  } else if (isComponent) {\n    return 'component';\n  } else {\n    throw new Error(\n      `Default export for module specified incorrectly. It should containts\n    either type extending \"TurboModule\" or \"codegenNativeComponent\".`,\n    );\n  }\n}\n\nfunction buildSchema(contents: string, filename: ?string): ?SchemaType {\n  const ast = flowParser.parse(contents);\n\n  const types = getTypes(ast);\n\n  const configType = getConfigType(ast, types);\n\n  if (configType === 'component') {\n    return buildComponentSchema(processComponent(ast, types));\n  } else {\n    if (filename === undefined || filename === null) {\n      throw new Error('Filepath expected while parasing a module');\n    }\n    const moduleName = path.basename(filename).slice(6, -3);\n    return buildModuleSchema(processModule(types), moduleName);\n  }\n}\n\nfunction parseFile(filename: string): ?SchemaType {\n  const contents = fs.readFileSync(filename, 'utf8');\n\n  return buildSchema(contents, filename);\n}\n\nfunction parseModuleFixture(filename: string): ?SchemaType {\n  const contents = fs.readFileSync(filename, 'utf8');\n\n  return buildSchema(contents, 'path/NativeSampleTurboModule.js');\n}\n\nfunction parseString(contents: string): ?SchemaType {\n  return buildSchema(contents);\n}\n\nmodule.exports = {\n  parseFile,\n  parseModuleFixture,\n  parseString,\n};\n"]},"metadata":{},"sourceType":"script"}