{"ast":null,"code":"'use strict';\n\nfunction getOrdinalNumber(num) {\n  switch (num) {\n    case 1:\n      return '1st';\n\n    case 2:\n      return '2nd';\n\n    case 3:\n      return '3rd';\n  }\n\n  if (num <= 20) {\n    return num + \"th\";\n  }\n\n  return 'unknown';\n}\n\nvar protocolTemplate = \"\\n@protocol RCT::_COMPONENT_NAME_::ViewProtocol <NSObject>\\n::_METHODS_::\\n@end\\n\".trim();\nvar commandHandlerIfCaseConvertArgTemplate = \"\\n  NSObject *arg::_ARG_NUMBER_:: = args[::_ARG_NUMBER_::];\\n#if RCT_DEBUG\\n  if (!RCTValidateTypeOfViewCommandArgument(arg::_ARG_NUMBER_::, ::_EXPECTED_KIND_::, @\\\"::_EXPECTED_KIND_STRING_::\\\", @\\\"::_COMPONENT_NAME_::\\\", commandName, @\\\"::_ARG_NUMBER_STR_::\\\")) {\\n    return;\\n  }\\n#endif\\n  ::_ARG_CONVERSION_::\\n\".trim();\nvar commandHandlerIfCaseTemplate = \"\\nif ([commandName isEqualToString:@\\\"::_COMMAND_NAME_::\\\"]) {\\n#if RCT_DEBUG\\n  if ([args count] != ::_NUM_ARGS_::) {\\n    RCTLogError(@\\\"%@ command %@ received %d arguments, expected %d.\\\", @\\\"::_COMPONENT_NAME_::\\\", commandName, (int)[args count], ::_NUM_ARGS_::);\\n    return;\\n  }\\n#endif\\n\\n  ::_CONVERT_ARGS_::\\n\\n  ::_COMMAND_CALL_::\\n  return;\\n}\\n\".trim();\nvar commandHandlerTemplate = \"\\nRCT_EXTERN inline void RCT::_COMPONENT_NAME_::HandleCommand(\\n  id<RCT::_COMPONENT_NAME_::ViewProtocol> componentView,\\n  NSString const *commandName,\\n  NSArray const *args)\\n{\\n  ::_IF_CASES_::\\n\\n#if RCT_DEBUG\\n  RCTLogError(@\\\"%@ received command %@, which is not a supported command.\\\", @\\\"::_COMPONENT_NAME_::\\\", commandName);\\n#endif\\n}\\n\".trim();\nvar template = \"\\n/**\\n* Copyright (c) Facebook, Inc. and its affiliates.\\n*\\n* This source code is licensed under the MIT license found in the\\n* LICENSE file in the root directory of this source tree.\\n*/\\n\\n#import <Foundation/Foundation.h>\\n#import <React/RCTDefines.h>\\n#import <React/RCTLog.h>\\n\\nNS_ASSUME_NONNULL_BEGIN\\n\\n::_COMPONENT_CONTENT_::\\n\\nNS_ASSUME_NONNULL_END\\n\".trim();\n\nfunction getObjCParamType(param) {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return 'BOOL';\n\n    case 'DoubleTypeAnnotation':\n      return 'double';\n\n    case 'FloatTypeAnnotation':\n      return 'float';\n\n    case 'Int32TypeAnnotation':\n      return 'NSInteger';\n\n    case 'StringTypeAnnotation':\n      return 'NSString *';\n\n    default:\n      param.typeAnnotation.type;\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction getObjCExpectedKindParamType(param) {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return '[NSNumber class]';\n\n    case 'DoubleTypeAnnotation':\n      return '[NSNumber class]';\n\n    case 'FloatTypeAnnotation':\n      return '[NSNumber class]';\n\n    case 'Int32TypeAnnotation':\n      return '[NSNumber class]';\n\n    case 'StringTypeAnnotation':\n      return '[NSString class]';\n\n    default:\n      param.typeAnnotation.type;\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction getReadableExpectedKindParamType(param) {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return 'boolean';\n\n    case 'DoubleTypeAnnotation':\n      return 'double';\n\n    case 'FloatTypeAnnotation':\n      return 'float';\n\n    case 'Int32TypeAnnotation':\n      return 'number';\n\n    case 'StringTypeAnnotation':\n      return 'string';\n\n    default:\n      param.typeAnnotation.type;\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction getObjCRightHandAssignmentParamType(param, index) {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return \"[(NSNumber *)arg\" + index + \" boolValue]\";\n\n    case 'DoubleTypeAnnotation':\n      return \"[(NSNumber *)arg\" + index + \" doubleValue]\";\n\n    case 'FloatTypeAnnotation':\n      return \"[(NSNumber *)arg\" + index + \" floatValue]\";\n\n    case 'Int32TypeAnnotation':\n      return \"[(NSNumber *)arg\" + index + \" intValue]\";\n\n    case 'StringTypeAnnotation':\n      return \"(NSString *)arg\" + index;\n\n    default:\n      param.typeAnnotation.type;\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction generateProtocol(component, componentName) {\n  var commands = component.commands.map(function (command) {\n    var params = command.typeAnnotation.params;\n    var paramString = params.length === 0 ? '' : params.map(function (param, index) {\n      var objCType = getObjCParamType(param);\n      return (index === 0 ? '' : param.name) + \":(\" + objCType + \")\" + param.name;\n    }).join(' ');\n    return \"- (void)\" + command.name + paramString + \";\";\n  }).join('\\n').trim();\n  return protocolTemplate.replace(/::_COMPONENT_NAME_::/g, componentName).replace('::_METHODS_::', commands);\n}\n\nfunction generateConvertAndValidateParam(param, index, componentName) {\n  var leftSideType = getObjCParamType(param);\n  var expectedKind = getObjCExpectedKindParamType(param);\n  var expectedKindString = getReadableExpectedKindParamType(param);\n  var argConversion = leftSideType + \" \" + param.name + \" = \" + getObjCRightHandAssignmentParamType(param, index) + \";\";\n  return commandHandlerIfCaseConvertArgTemplate.replace(/::_COMPONENT_NAME_::/g, componentName).replace('::_ARG_CONVERSION_::', argConversion).replace(/::_ARG_NUMBER_::/g, '' + index).replace('::_ARG_NUMBER_STR_::', getOrdinalNumber(index + 1)).replace('::_EXPECTED_KIND_::', expectedKind).replace('::_EXPECTED_KIND_STRING_::', expectedKindString);\n}\n\nfunction generateCommandIfCase(command, componentName) {\n  var params = command.typeAnnotation.params;\n  var convertArgs = params.map(function (param, index) {\n    return generateConvertAndValidateParam(param, index, componentName);\n  }).join('\\n\\n').trim();\n  var commandCallArgs = params.length === 0 ? '' : params.map(function (param, index) {\n    return (index === 0 ? '' : param.name) + \":\" + param.name;\n  }).join(' ');\n  var commandCall = \"[componentView \" + command.name + commandCallArgs + \"];\";\n  return commandHandlerIfCaseTemplate.replace(/::_COMPONENT_NAME_::/g, componentName).replace(/::_COMMAND_NAME_::/g, command.name).replace(/::_NUM_ARGS_::/g, '' + params.length).replace('::_CONVERT_ARGS_::', convertArgs).replace('::_COMMAND_CALL_::', commandCall);\n}\n\nfunction generateCommandHandler(component, componentName) {\n  if (component.commands.length === 0) {\n    return null;\n  }\n\n  var ifCases = component.commands.map(function (command) {\n    return generateCommandIfCase(command, componentName);\n  }).join('\\n\\n');\n  return commandHandlerTemplate.replace(/::_COMPONENT_NAME_::/g, componentName).replace('::_IF_CASES_::', ifCases);\n}\n\nmodule.exports = {\n  generate: function generate(libraryName, schema, moduleSpecName) {\n    var fileName = 'RCTComponentViewHelpers.h';\n    var componentContent = Object.keys(schema.modules).map(function (moduleName) {\n      var components = schema.modules[moduleName].components;\n\n      if (components == null) {\n        return null;\n      }\n\n      return Object.keys(components).filter(function (componentName) {\n        var component = components[componentName];\n        return component.excludedPlatform !== 'iOS';\n      }).map(function (componentName) {\n        return [generateProtocol(components[componentName], componentName), generateCommandHandler(components[componentName], componentName)].join('\\n\\n').trim();\n      }).join('\\n\\n');\n    }).filter(Boolean).join('\\n\\n');\n    var replacedTemplate = template.replace('::_COMPONENT_CONTENT_::', componentContent);\n    return new Map([[fileName, replacedTemplate]]);\n  }\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/generators/components/GenerateComponentHObjCpp.js"],"names":["getOrdinalNumber","num","protocolTemplate","trim","commandHandlerIfCaseConvertArgTemplate","commandHandlerIfCaseTemplate","commandHandlerTemplate","template","getObjCParamType","param","typeAnnotation","type","Error","getObjCExpectedKindParamType","getReadableExpectedKindParamType","getObjCRightHandAssignmentParamType","index","generateProtocol","component","componentName","commands","map","command","params","paramString","length","objCType","name","join","replace","generateConvertAndValidateParam","leftSideType","expectedKind","expectedKindString","argConversion","generateCommandIfCase","convertArgs","commandCallArgs","commandCall","generateCommandHandler","ifCases","module","exports","generate","libraryName","schema","moduleSpecName","fileName","componentContent","Object","keys","modules","moduleName","components","filter","excludedPlatform","Boolean","replacedTemplate","Map"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\n'use strict';\n\nimport type {\n  CommandTypeShape,\n  ComponentShape,\n  SchemaType,\n  CommandsFunctionTypeParamAnnotation,\n} from '../../CodegenSchema';\n\ntype FilesOutput = Map<string, string>;\n\nfunction getOrdinalNumber(num: number): string {\n  switch (num) {\n    case 1:\n      return '1st';\n    case 2:\n      return '2nd';\n    case 3:\n      return '3rd';\n  }\n\n  if (num <= 20) {\n    return `${num}th`;\n  }\n\n  return 'unknown';\n}\n\nconst protocolTemplate = `\n@protocol RCT::_COMPONENT_NAME_::ViewProtocol <NSObject>\n::_METHODS_::\n@end\n`.trim();\n\nconst commandHandlerIfCaseConvertArgTemplate = `\n  NSObject *arg::_ARG_NUMBER_:: = args[::_ARG_NUMBER_::];\n#if RCT_DEBUG\n  if (!RCTValidateTypeOfViewCommandArgument(arg::_ARG_NUMBER_::, ::_EXPECTED_KIND_::, @\"::_EXPECTED_KIND_STRING_::\", @\"::_COMPONENT_NAME_::\", commandName, @\"::_ARG_NUMBER_STR_::\")) {\n    return;\n  }\n#endif\n  ::_ARG_CONVERSION_::\n`.trim();\n\nconst commandHandlerIfCaseTemplate = `\nif ([commandName isEqualToString:@\"::_COMMAND_NAME_::\"]) {\n#if RCT_DEBUG\n  if ([args count] != ::_NUM_ARGS_::) {\n    RCTLogError(@\"%@ command %@ received %d arguments, expected %d.\", @\"::_COMPONENT_NAME_::\", commandName, (int)[args count], ::_NUM_ARGS_::);\n    return;\n  }\n#endif\n\n  ::_CONVERT_ARGS_::\n\n  ::_COMMAND_CALL_::\n  return;\n}\n`.trim();\n\nconst commandHandlerTemplate = `\nRCT_EXTERN inline void RCT::_COMPONENT_NAME_::HandleCommand(\n  id<RCT::_COMPONENT_NAME_::ViewProtocol> componentView,\n  NSString const *commandName,\n  NSArray const *args)\n{\n  ::_IF_CASES_::\n\n#if RCT_DEBUG\n  RCTLogError(@\"%@ received command %@, which is not a supported command.\", @\"::_COMPONENT_NAME_::\", commandName);\n#endif\n}\n`.trim();\n\nconst template = `\n/**\n* Copyright (c) Facebook, Inc. and its affiliates.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n#import <Foundation/Foundation.h>\n#import <React/RCTDefines.h>\n#import <React/RCTLog.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n::_COMPONENT_CONTENT_::\n\nNS_ASSUME_NONNULL_END\n`.trim();\n\nfunction getObjCParamType(param: CommandsFunctionTypeParamAnnotation): string {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return 'BOOL';\n    case 'DoubleTypeAnnotation':\n      return 'double';\n    case 'FloatTypeAnnotation':\n      return 'float';\n    case 'Int32TypeAnnotation':\n      return 'NSInteger';\n    case 'StringTypeAnnotation':\n      return 'NSString *';\n    default:\n      (param.typeAnnotation.type: empty);\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction getObjCExpectedKindParamType(\n  param: CommandsFunctionTypeParamAnnotation,\n): string {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return '[NSNumber class]';\n    case 'DoubleTypeAnnotation':\n      return '[NSNumber class]';\n    case 'FloatTypeAnnotation':\n      return '[NSNumber class]';\n    case 'Int32TypeAnnotation':\n      return '[NSNumber class]';\n    case 'StringTypeAnnotation':\n      return '[NSString class]';\n    default:\n      (param.typeAnnotation.type: empty);\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction getReadableExpectedKindParamType(\n  param: CommandsFunctionTypeParamAnnotation,\n): string {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return 'boolean';\n    case 'DoubleTypeAnnotation':\n      return 'double';\n    case 'FloatTypeAnnotation':\n      return 'float';\n    case 'Int32TypeAnnotation':\n      return 'number';\n    case 'StringTypeAnnotation':\n      return 'string';\n    default:\n      (param.typeAnnotation.type: empty);\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction getObjCRightHandAssignmentParamType(\n  param: CommandsFunctionTypeParamAnnotation,\n  index: number,\n): string {\n  switch (param.typeAnnotation.type) {\n    case 'BooleanTypeAnnotation':\n      return `[(NSNumber *)arg${index} boolValue]`;\n    case 'DoubleTypeAnnotation':\n      return `[(NSNumber *)arg${index} doubleValue]`;\n    case 'FloatTypeAnnotation':\n      return `[(NSNumber *)arg${index} floatValue]`;\n    case 'Int32TypeAnnotation':\n      return `[(NSNumber *)arg${index} intValue]`;\n    case 'StringTypeAnnotation':\n      return `(NSString *)arg${index}`;\n    default:\n      (param.typeAnnotation.type: empty);\n      throw new Error('Received invalid param type annotation');\n  }\n}\n\nfunction generateProtocol(\n  component: ComponentShape,\n  componentName: string,\n): string {\n  const commands = component.commands\n    .map(command => {\n      const params = command.typeAnnotation.params;\n      const paramString =\n        params.length === 0\n          ? ''\n          : params\n              .map((param, index) => {\n                const objCType = getObjCParamType(param);\n\n                return `${index === 0 ? '' : param.name}:(${objCType})${\n                  param.name\n                }`;\n              })\n              .join(' ');\n      return `- (void)${command.name}${paramString};`;\n    })\n    .join('\\n')\n    .trim();\n\n  return protocolTemplate\n    .replace(/::_COMPONENT_NAME_::/g, componentName)\n    .replace('::_METHODS_::', commands);\n}\n\nfunction generateConvertAndValidateParam(\n  param: CommandsFunctionTypeParamAnnotation,\n  index: number,\n  componentName: string,\n): string {\n  const leftSideType = getObjCParamType(param);\n  const expectedKind = getObjCExpectedKindParamType(param);\n  const expectedKindString = getReadableExpectedKindParamType(param);\n  const argConversion = `${leftSideType} ${\n    param.name\n  } = ${getObjCRightHandAssignmentParamType(param, index)};`;\n\n  return commandHandlerIfCaseConvertArgTemplate\n    .replace(/::_COMPONENT_NAME_::/g, componentName)\n    .replace('::_ARG_CONVERSION_::', argConversion)\n    .replace(/::_ARG_NUMBER_::/g, '' + index)\n    .replace('::_ARG_NUMBER_STR_::', getOrdinalNumber(index + 1))\n    .replace('::_EXPECTED_KIND_::', expectedKind)\n    .replace('::_EXPECTED_KIND_STRING_::', expectedKindString);\n}\n\nfunction generateCommandIfCase(\n  command: CommandTypeShape,\n  componentName: string,\n) {\n  const params = command.typeAnnotation.params;\n\n  const convertArgs = params\n    .map((param, index) =>\n      generateConvertAndValidateParam(param, index, componentName),\n    )\n    .join('\\n\\n')\n    .trim();\n\n  const commandCallArgs =\n    params.length === 0\n      ? ''\n      : params\n          .map((param, index) => {\n            return `${index === 0 ? '' : param.name}:${param.name}`;\n          })\n          .join(' ');\n  const commandCall = `[componentView ${command.name}${commandCallArgs}];`;\n\n  return commandHandlerIfCaseTemplate\n    .replace(/::_COMPONENT_NAME_::/g, componentName)\n    .replace(/::_COMMAND_NAME_::/g, command.name)\n    .replace(/::_NUM_ARGS_::/g, '' + params.length)\n    .replace('::_CONVERT_ARGS_::', convertArgs)\n    .replace('::_COMMAND_CALL_::', commandCall);\n}\n\nfunction generateCommandHandler(\n  component: ComponentShape,\n  componentName: string,\n): ?string {\n  if (component.commands.length === 0) {\n    return null;\n  }\n\n  const ifCases = component.commands\n    .map(command => generateCommandIfCase(command, componentName))\n    .join('\\n\\n');\n\n  return commandHandlerTemplate\n    .replace(/::_COMPONENT_NAME_::/g, componentName)\n    .replace('::_IF_CASES_::', ifCases);\n}\n\nmodule.exports = {\n  generate(\n    libraryName: string,\n    schema: SchemaType,\n    moduleSpecName: string,\n  ): FilesOutput {\n    const fileName = 'RCTComponentViewHelpers.h';\n\n    const componentContent = Object.keys(schema.modules)\n      .map(moduleName => {\n        const components = schema.modules[moduleName].components;\n        // No components in this module\n        if (components == null) {\n          return null;\n        }\n\n        return Object.keys(components)\n          .filter(componentName => {\n            const component = components[componentName];\n            return component.excludedPlatform !== 'iOS';\n          })\n          .map(componentName => {\n            return [\n              generateProtocol(components[componentName], componentName),\n              generateCommandHandler(components[componentName], componentName),\n            ]\n              .join('\\n\\n')\n              .trim();\n          })\n          .join('\\n\\n');\n      })\n      .filter(Boolean)\n      .join('\\n\\n');\n\n    const replacedTemplate = template.replace(\n      '::_COMPONENT_CONTENT_::',\n      componentContent,\n    );\n\n    return new Map([[fileName, replacedTemplate]]);\n  },\n};\n"]},"metadata":{},"sourceType":"script"}