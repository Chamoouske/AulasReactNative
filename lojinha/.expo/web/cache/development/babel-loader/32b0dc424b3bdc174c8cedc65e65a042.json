{"ast":null,"code":"'use strict';\n\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport invariant from 'assert';\n\nvar Node = function Node(id) {\n  _classCallCheck(this, Node);\n\n  this.id = id;\n  this.children = new Set();\n  this.state = 'none';\n};\n\nexport var Graph = function () {\n  function Graph() {\n    _classCallCheck(this, Graph);\n\n    this.nodes = new Map();\n  }\n\n  _createClass(Graph, [{\n    key: \"addNode\",\n    value: function addNode(nodeId) {\n      var node = this.nodes.get(nodeId);\n\n      if (!node) {\n        node = new Node(nodeId);\n        this.nodes.set(nodeId, node);\n      }\n\n      return node;\n    }\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(srcId, dstId) {\n      var src = this.addNode(srcId);\n      var dst = this.addNode(dstId);\n      src.children.add(dst);\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(rootIds) {\n      for (var _iterator = _createForOfIteratorHelperLoose(this.nodes.values()), _step; !(_step = _iterator()).done;) {\n        var node = _step.value;\n        node.state = 'none';\n      }\n\n      var root = new Node('root');\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(rootIds), _step2; !(_step2 = _iterator2()).done;) {\n        var id = _step2.value;\n\n        var _node = this.nodes.get(id);\n\n        invariant(_node != null, \"No node \" + id + \" in graph\");\n        root.children.add(_node);\n      }\n\n      var output = [];\n      postorder(root, output);\n      output.splice(-1);\n      return output;\n    }\n  }]);\n\n  return Graph;\n}();\n\nfunction postorder(node, output) {\n  if (node.state === 'visited') {\n    return;\n  }\n\n  invariant(node.state !== 'visiting', \"Not a DAG: cycle involving \" + node.id);\n  node.state = 'visiting';\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(node.children), _step3; !(_step3 = _iterator3()).done;) {\n    var child = _step3.value;\n    postorder(child, output);\n  }\n\n  node.state = 'visited';\n  output.push(node.id);\n}","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/ReactCommon/hermes/inspector/tools/msggen/src/Graph.js"],"names":["invariant","Node","id","children","Set","state","Graph","nodes","Map","nodeId","node","get","set","srcId","dstId","src","addNode","dst","add","rootIds","values","root","output","postorder","splice","child","push"],"mappings":"AAUA;;;;;;;;;;;AAEA,OAAOA,SAAP,MAAsB,QAAtB;;IAIMC,I,GAKJ,cAAYC,EAAZ,EAAwB;AAAA;;AACtB,OAAKA,EAAL,GAAUA,EAAV;AACA,OAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACA,OAAKC,KAAL,GAAa,MAAb;AACD,C;;AAGH,WAAaC,KAAb;AAGE,mBAAc;AAAA;;AACZ,SAAKC,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACD;;AALH;AAAA;AAAA,WAOE,iBAAQC,MAAR,EAA8B;AAC5B,UAAIC,IAAI,GAAG,KAAKH,KAAL,CAAWI,GAAX,CAAeF,MAAf,CAAX;;AACA,UAAI,CAACC,IAAL,EAAW;AACTA,QAAAA,IAAI,GAAG,IAAIT,IAAJ,CAASQ,MAAT,CAAP;AACA,aAAKF,KAAL,CAAWK,GAAX,CAAeH,MAAf,EAAuBC,IAAvB;AACD;;AACD,aAAOA,IAAP;AACD;AAdH;AAAA;AAAA,WAgBE,iBAAQG,KAAR,EAAuBC,KAAvB,EAAsC;AACpC,UAAMC,GAAG,GAAG,KAAKC,OAAL,CAAaH,KAAb,CAAZ;AACA,UAAMI,GAAG,GAAG,KAAKD,OAAL,CAAaF,KAAb,CAAZ;AACAC,MAAAA,GAAG,CAACZ,QAAJ,CAAae,GAAb,CAAiBD,GAAjB;AACD;AApBH;AAAA;AAAA,WAyBE,kBAASE,OAAT,EAAgD;AAE9C,2DAAmB,KAAKZ,KAAL,CAAWa,MAAX,EAAnB,wCAAwC;AAAA,YAA7BV,IAA6B;AACtCA,QAAAA,IAAI,CAACL,KAAL,GAAa,MAAb;AACD;;AAGD,UAAMgB,IAAI,GAAG,IAAIpB,IAAJ,CAAS,MAAT,CAAb;;AACA,4DAAiBkB,OAAjB,2CAA0B;AAAA,YAAfjB,EAAe;;AACxB,YAAMQ,KAAI,GAAG,KAAKH,KAAL,CAAWI,GAAX,CAAeT,EAAf,CAAb;;AACAF,QAAAA,SAAS,CAACU,KAAI,IAAI,IAAT,eAA0BR,EAA1B,eAAT;AACAmB,QAAAA,IAAI,CAAClB,QAAL,CAAce,GAAd,CAAkBR,KAAlB;AACD;;AAED,UAAMY,MAAM,GAAG,EAAf;AACAC,MAAAA,SAAS,CAACF,IAAD,EAAOC,MAAP,CAAT;AAGAA,MAAAA,MAAM,CAACE,MAAP,CAAc,CAAC,CAAf;AAEA,aAAOF,MAAP;AACD;AA9CH;;AAAA;AAAA;;AAiDA,SAASC,SAAT,CAAmBb,IAAnB,EAA+BY,MAA/B,EAAsD;AACpD,MAAIZ,IAAI,CAACL,KAAL,KAAe,SAAnB,EAA8B;AAC5B;AACD;;AAEDL,EAAAA,SAAS,CAACU,IAAI,CAACL,KAAL,KAAe,UAAhB,kCAA0DK,IAAI,CAACR,EAA/D,CAAT;AAEAQ,EAAAA,IAAI,CAACL,KAAL,GAAa,UAAb;;AACA,wDAAoBK,IAAI,CAACP,QAAzB,2CAAmC;AAAA,QAAxBsB,KAAwB;AACjCF,IAAAA,SAAS,CAACE,KAAD,EAAQH,MAAR,CAAT;AACD;;AAEDZ,EAAAA,IAAI,CAACL,KAAL,GAAa,SAAb;AACAiB,EAAAA,MAAM,CAACI,IAAP,CAAYhB,IAAI,CAACR,EAAjB;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport invariant from 'assert';\n\ntype NodeId = string;\n\nclass Node {\n  id: NodeId;\n  children: Set<Node>;\n  state: 'none' | 'visiting' | 'visited';\n\n  constructor(id: NodeId) {\n    this.id = id;\n    this.children = new Set();\n    this.state = 'none';\n  }\n}\n\nexport class Graph {\n  nodes: Map<NodeId, Node>;\n\n  constructor() {\n    this.nodes = new Map();\n  }\n\n  addNode(nodeId: NodeId): Node {\n    let node = this.nodes.get(nodeId);\n    if (!node) {\n      node = new Node(nodeId);\n      this.nodes.set(nodeId, node);\n    }\n    return node;\n  }\n\n  addEdge(srcId: NodeId, dstId: NodeId) {\n    const src = this.addNode(srcId);\n    const dst = this.addNode(dstId);\n    src.children.add(dst);\n  }\n\n  // traverse returns all nodes in the graph reachable from the given rootIds.\n  // the returned nodes are topologically sorted, with the deepest nodes\n  // returned first.\n  traverse(rootIds: Array<NodeId>): Array<NodeId> {\n    // clear marks\n    for (const node of this.nodes.values()) {\n      node.state = 'none';\n    }\n\n    // make a fake root node that points to all the provided rootIds\n    const root = new Node('root');\n    for (const id of rootIds) {\n      const node = this.nodes.get(id);\n      invariant(node != null, `No node ${id} in graph`);\n      root.children.add(node);\n    }\n\n    const output = [];\n    postorder(root, output);\n\n    // remove fake root node\n    output.splice(-1);\n\n    return output;\n  }\n}\n\nfunction postorder(node: Node, output: Array<NodeId>) {\n  if (node.state === 'visited') {\n    return;\n  }\n\n  invariant(node.state !== 'visiting', `Not a DAG: cycle involving ${node.id}`);\n\n  node.state = 'visiting';\n  for (const child of node.children) {\n    postorder(child, output);\n  }\n\n  node.state = 'visited';\n  output.push(node.id);\n}\n"]},"metadata":{},"sourceType":"module"}