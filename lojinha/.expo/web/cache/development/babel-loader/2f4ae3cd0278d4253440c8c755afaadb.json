{"ast":null,"code":"'use strict';\n\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { jsTypeToCppType, toCppNamespace, toCppType } from \"./Converters\";\nexport var Property = function () {\n  function Property(domain, obj) {\n    _classCallCheck(this, Property);\n\n    this.domain = domain;\n    this.name = obj.name;\n    this.description = obj.description;\n    this.exported = obj.exported;\n    this.experimental = obj.experimental;\n    this.optional = obj.optional;\n  }\n\n  _createClass(Property, [{\n    key: \"getRefDebuggerName\",\n    value: function getRefDebuggerName() {\n      throw new Error('subclass must implement');\n    }\n  }, {\n    key: \"getFullCppType\",\n    value: function getFullCppType() {\n      throw new Error('subclass must implement');\n    }\n  }, {\n    key: \"getCppIdentifier\",\n    value: function getCppIdentifier() {\n      if (this.name === 'this') {\n        return 'thisObj';\n      }\n\n      return this.name;\n    }\n  }, {\n    key: \"getInitializer\",\n    value: function getInitializer() {\n      throw new Error('subclass must implement');\n    }\n  }], [{\n    key: \"create\",\n    value: function create(domain, obj) {\n      if (obj.$ref) {\n        return new RefProperty(domain, obj);\n      } else if (obj.type === 'array') {\n        return new ArrayProperty(domain, obj);\n      }\n\n      return new PrimitiveProperty(domain, obj);\n    }\n  }, {\n    key: \"createArray\",\n    value: function createArray(domain, elements, ignoreExperimental) {\n      var props = elements.map(function (elem) {\n        return Property.create(domain, elem);\n      });\n\n      if (ignoreExperimental) {\n        props = props.filter(function (prop) {\n          return !prop.experimental;\n        });\n      }\n\n      return props;\n    }\n  }]);\n\n  return Property;\n}();\n\nfunction maybeWrapOptional(type, optional, recursive) {\n  if (optional) {\n    return recursive ? \"std::unique_ptr<\" + type + \">\" : \"folly::Optional<\" + type + \">\";\n  }\n\n  return type;\n}\n\nfunction toDomainAndId(curDomain, absOrRelRef) {\n  var domain = '',\n      id = '';\n  var i = absOrRelRef.indexOf('.');\n\n  if (i === -1) {\n    domain = curDomain;\n    id = absOrRelRef;\n  } else {\n    domain = absOrRelRef.substr(0, i);\n    id = absOrRelRef.substr(i + 1);\n  }\n\n  return [domain, id];\n}\n\nfunction toFullCppType(curDomain, absOrRelRef) {\n  var _toDomainAndId = toDomainAndId(curDomain, absOrRelRef),\n      _toDomainAndId2 = _slicedToArray(_toDomainAndId, 2),\n      domain = _toDomainAndId2[0],\n      id = _toDomainAndId2[1];\n\n  return toCppNamespace(domain) + \"::\" + toCppType(id);\n}\n\nvar PrimitiveProperty = function (_Property) {\n  _inherits(PrimitiveProperty, _Property);\n\n  var _super = _createSuper(PrimitiveProperty);\n\n  function PrimitiveProperty(domain, obj) {\n    var _this;\n\n    _classCallCheck(this, PrimitiveProperty);\n\n    _this = _super.call(this, domain, obj);\n    _this.type = obj.type;\n    return _this;\n  }\n\n  _createClass(PrimitiveProperty, [{\n    key: \"getRefDebuggerName\",\n    value: function getRefDebuggerName() {\n      return undefined;\n    }\n  }, {\n    key: \"getFullCppType\",\n    value: function getFullCppType() {\n      return maybeWrapOptional(jsTypeToCppType(this.type), this.optional);\n    }\n  }, {\n    key: \"getInitializer\",\n    value: function getInitializer() {\n      if (this.optional) {\n        return '';\n      }\n\n      var type = this.type;\n\n      if (type === 'boolean' || type === 'integer' || type === 'number') {\n        return '{}';\n      }\n\n      return '';\n    }\n  }]);\n\n  return PrimitiveProperty;\n}(Property);\n\nvar RefProperty = function (_Property2) {\n  _inherits(RefProperty, _Property2);\n\n  var _super2 = _createSuper(RefProperty);\n\n  function RefProperty(domain, obj) {\n    var _this2;\n\n    _classCallCheck(this, RefProperty);\n\n    _this2 = _super2.call(this, domain, obj);\n    _this2.$ref = obj.$ref;\n    return _this2;\n  }\n\n  _createClass(RefProperty, [{\n    key: \"getRefDebuggerName\",\n    value: function getRefDebuggerName() {\n      var _toDomainAndId3 = toDomainAndId(this.domain, this.$ref),\n          _toDomainAndId4 = _slicedToArray(_toDomainAndId3, 2),\n          domain = _toDomainAndId4[0],\n          id = _toDomainAndId4[1];\n\n      return domain + \".\" + id;\n    }\n  }, {\n    key: \"getFullCppType\",\n    value: function getFullCppType() {\n      var fullCppType = toFullCppType(this.domain, this.$ref);\n      return maybeWrapOptional(\"\" + fullCppType, this.optional, this.recursive);\n    }\n  }, {\n    key: \"getInitializer\",\n    value: function getInitializer() {\n      return this.optional ? '' : '{}';\n    }\n  }]);\n\n  return RefProperty;\n}(Property);\n\nvar ArrayProperty = function (_Property3) {\n  _inherits(ArrayProperty, _Property3);\n\n  var _super3 = _createSuper(ArrayProperty);\n\n  function ArrayProperty(domain, obj) {\n    var _this3;\n\n    _classCallCheck(this, ArrayProperty);\n\n    _this3 = _super3.call(this, domain, obj);\n    _this3.type = obj.type;\n    _this3.items = obj.items;\n    return _this3;\n  }\n\n  _createClass(ArrayProperty, [{\n    key: \"getRefDebuggerName\",\n    value: function getRefDebuggerName() {\n      if (this.items && this.items.$ref && !this.items.recursive) {\n        var _toDomainAndId5 = toDomainAndId(this.domain, this.items.$ref),\n            _toDomainAndId6 = _slicedToArray(_toDomainAndId5, 2),\n            domain = _toDomainAndId6[0],\n            id = _toDomainAndId6[1];\n\n        return domain + \".\" + id;\n      }\n    }\n  }, {\n    key: \"getFullCppType\",\n    value: function getFullCppType() {\n      var elemType = 'folly::dynamic';\n      var recursive = false;\n\n      if (this.items) {\n        if (this.items.type) {\n          elemType = jsTypeToCppType(this.items.type);\n        } else if (this.items.$ref) {\n          elemType = toFullCppType(this.domain, this.items.$ref);\n          recursive = this.items.recursive;\n        }\n      }\n\n      return maybeWrapOptional(\"std::vector<\" + elemType + \">\", this.optional, recursive);\n    }\n  }, {\n    key: \"getInitializer\",\n    value: function getInitializer() {\n      return '';\n    }\n  }]);\n\n  return ArrayProperty;\n}(Property);","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/ReactCommon/hermes/inspector/tools/msggen/src/Property.js"],"names":["jsTypeToCppType","toCppNamespace","toCppType","Property","domain","obj","name","description","exported","experimental","optional","Error","$ref","RefProperty","type","ArrayProperty","PrimitiveProperty","elements","ignoreExperimental","props","map","elem","create","filter","prop","maybeWrapOptional","recursive","toDomainAndId","curDomain","absOrRelRef","id","i","indexOf","substr","toFullCppType","undefined","fullCppType","items","elemType"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport {\n  jsTypeToCppType,\n  toCppNamespace,\n  toCppType,\n  type JsTypeString,\n} from './Converters';\n\nexport class Property {\n  domain: string;\n  name: string;\n  description: ?string;\n  exported: ?boolean;\n  experimental: ?boolean;\n  optional: ?boolean;\n\n  static create(domain: string, obj: any): Property {\n    if (obj.$ref) {\n      return new RefProperty(domain, obj);\n    } else if (obj.type === 'array') {\n      return new ArrayProperty(domain, obj);\n    }\n    return new PrimitiveProperty(domain, obj);\n  }\n\n  static createArray(\n    domain: string,\n    elements: Array<any>,\n    ignoreExperimental: boolean,\n  ): Array<Property> {\n    let props = elements.map(elem => Property.create(domain, elem));\n    if (ignoreExperimental) {\n      props = props.filter(prop => !prop.experimental);\n    }\n    return props;\n  }\n\n  constructor(domain: string, obj: any) {\n    this.domain = domain;\n    this.name = obj.name;\n    this.description = obj.description;\n    this.exported = obj.exported;\n    this.experimental = obj.experimental;\n    this.optional = obj.optional;\n  }\n\n  getRefDebuggerName(): ?string {\n    throw new Error('subclass must implement');\n  }\n\n  getFullCppType(): string {\n    throw new Error('subclass must implement');\n  }\n\n  getCppIdentifier(): string {\n    // need to munge identifier if it matches a C++ keyword like \"this\"\n    if (this.name === 'this') {\n      return 'thisObj';\n    }\n    return this.name;\n  }\n\n  getInitializer(): string {\n    throw new Error('subclass must implement');\n  }\n}\n\nfunction maybeWrapOptional(\n  type: string,\n  optional: ?boolean,\n  recursive: ?boolean,\n) {\n  if (optional) {\n    return recursive ? `std::unique_ptr<${type}>` : `folly::Optional<${type}>`;\n  }\n  return type;\n}\n\nfunction toDomainAndId(\n  curDomain: string,\n  absOrRelRef: string,\n): [string, string] {\n  let [domain, id] = ['', ''];\n\n  // absOrRelRef can be:\n  // 1) absolute ref with a \".\" referencing a type from another namespace, like\n  //    \"Runtime.ExceptionDetails\"\n  // 2) relative ref without a \".\" referencing a type in current domain, like\n  //    \"Domain\"\n  const i = absOrRelRef.indexOf('.');\n  if (i === -1) {\n    domain = curDomain;\n    id = absOrRelRef;\n  } else {\n    domain = absOrRelRef.substr(0, i);\n    id = absOrRelRef.substr(i + 1);\n  }\n\n  return [domain, id];\n}\n\nfunction toFullCppType(curDomain: string, absOrRelRef: string) {\n  const [domain, id] = toDomainAndId(curDomain, absOrRelRef);\n  return `${toCppNamespace(domain)}::${toCppType(id)}`;\n}\n\nclass PrimitiveProperty extends Property {\n  type: JsTypeString;\n\n  constructor(domain: string, obj: any) {\n    super(domain, obj);\n    this.type = obj.type;\n  }\n\n  getRefDebuggerName(): ?string {\n    return undefined;\n  }\n\n  getFullCppType(): string {\n    return maybeWrapOptional(jsTypeToCppType(this.type), this.optional);\n  }\n\n  getInitializer(): string {\n    // folly::Optional doesn't need to be explicitly zero-init\n    if (this.optional) {\n      return '';\n    }\n\n    // we want to explicitly zero-init bool, int, and double\n    const type = this.type;\n    if (type === 'boolean' || type === 'integer' || type === 'number') {\n      return '{}';\n    }\n\n    // everything else (folly::dynamic and std::string) has sensible default\n    // constructor, no need to explicitly zero-init\n    return '';\n  }\n}\n\nclass RefProperty extends Property {\n  $ref: string;\n  recursive: ?boolean;\n\n  constructor(domain: string, obj: any) {\n    super(domain, obj);\n    this.$ref = obj.$ref;\n  }\n\n  getRefDebuggerName(): ?string {\n    const [domain, id] = toDomainAndId(this.domain, this.$ref);\n    return `${domain}.${id}`;\n  }\n\n  getFullCppType(): string {\n    const fullCppType = toFullCppType(this.domain, this.$ref);\n    return maybeWrapOptional(`${fullCppType}`, this.optional, this.recursive);\n  }\n\n  getInitializer(): string {\n    // must zero-init non-optional ref props since the ref could just be an\n    // alias to a C++ primitive type like int which we always want to zero-init\n    return this.optional ? '' : '{}';\n  }\n}\n\nclass ArrayProperty extends Property {\n  type: 'array';\n  items:\n    | {|type: JsTypeString, recursive: false|}\n    | {|$ref: string, recursive: ?boolean|};\n\n  constructor(domain: string, obj: any) {\n    super(domain, obj);\n    this.type = obj.type;\n    this.items = obj.items;\n  }\n\n  getRefDebuggerName(): ?string {\n    if (this.items && this.items.$ref && !this.items.recursive) {\n      const [domain, id] = toDomainAndId(this.domain, this.items.$ref);\n      return `${domain}.${id}`;\n    }\n  }\n\n  getFullCppType(): string {\n    let elemType: string = 'folly::dynamic';\n    let recursive = false;\n\n    if (this.items) {\n      if (this.items.type) {\n        elemType = jsTypeToCppType(this.items.type);\n      } else if (this.items.$ref) {\n        elemType = toFullCppType(this.domain, this.items.$ref);\n        recursive = this.items.recursive;\n      }\n    }\n\n    return maybeWrapOptional(\n      `std::vector<${elemType}>`,\n      this.optional,\n      recursive,\n    );\n  }\n\n  getInitializer(): string {\n    return '';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}