{"ast":null,"code":"import { PermissionStatus } from \"./Permissions.types\";\nexport function coalesceStatuses(permissions) {\n  var statuses = Object.keys(permissions).map(function (type) {\n    return permissions[type].status;\n  });\n  statuses.sort(function (status1, status2) {\n    return _getStatusWeight(status1) - _getStatusWeight(status2);\n  });\n  return statuses[statuses.length - 1];\n}\n\nfunction _getStatusWeight(status) {\n  switch (status) {\n    case PermissionStatus.GRANTED:\n      return 0;\n\n    case PermissionStatus.DENIED:\n      return 1;\n\n    case PermissionStatus.UNDETERMINED:\n      return 2;\n\n    default:\n      return 100;\n  }\n}\n\nexport function coalesceExpirations(permissions) {\n  var maxExpiration = 9007199254740991;\n  var expirations = Object.keys(permissions).map(function (type) {\n    return permissions[type].expires;\n  });\n  expirations.sort(function (e1, e2) {\n    return (e1 == null || e1 === 'never' ? maxExpiration : e1) - (e2 == null || e2 === 'never' ? maxExpiration : e2);\n  });\n  return expirations[0];\n}\nexport function coalesceCanAskAgain(permissions) {\n  return Object.keys(permissions).reduce(function (canAskAgain, type) {\n    return canAskAgain && permissions[type].canAskAgain;\n  }, true);\n}\nexport function coalesceGranted(permissions) {\n  return Object.keys(permissions).reduce(function (granted, type) {\n    return granted && permissions[type].granted;\n  }, true);\n}","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/expo-permissions/src/CoalescedPermissions.ts"],"names":["PermissionStatus","coalesceStatuses","permissions","statuses","Object","keys","map","type","status","sort","status1","status2","_getStatusWeight","length","GRANTED","DENIED","UNDETERMINED","coalesceExpirations","maxExpiration","expirations","expires","e1","e2","coalesceCanAskAgain","reduce","canAskAgain","coalesceGranted","granted"],"mappings":"AAAA,SAA8CA,gBAA9C;AAEA,OAAO,SAASC,gBAAT,CAA0BC,WAA1B,EAAwE;AAC7E,MAAMC,QAAQ,GAAGC,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyBI,GAAzB,CAA6B,UAAAC,IAAI;AAAA,WAAIL,WAAW,CAACK,IAAD,CAAX,CAAkBC,MAAtB;AAAA,GAAjC,CAAjB;AACAL,EAAAA,QAAQ,CAACM,IAAT,CAAc,UAACC,OAAD,EAAUC,OAAV;AAAA,WAAsBC,gBAAgB,CAACF,OAAD,CAAhB,GAA4BE,gBAAgB,CAACD,OAAD,CAAlE;AAAA,GAAd;AAEA,SAAOR,QAAQ,CAACA,QAAQ,CAACU,MAAT,GAAkB,CAAnB,CAAf;AACD;;AAED,SAASD,gBAAT,CAA0BJ,MAA1B,EAA4D;AAI1D,UAAQA,MAAR;AACE,SAAKR,gBAAgB,CAACc,OAAtB;AACE,aAAO,CAAP;;AACF,SAAKd,gBAAgB,CAACe,MAAtB;AACE,aAAO,CAAP;;AACF,SAAKf,gBAAgB,CAACgB,YAAtB;AACE,aAAO,CAAP;;AACF;AACE,aAAO,GAAP;AARJ;AAUD;;AAED,OAAO,SAASC,mBAAT,CAA6Bf,WAA7B,EAA+E;AACpF,MAAMgB,aAAa,GAAG,gBAAtB;AACA,MAAMC,WAAW,GAAGf,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyBI,GAAzB,CAA6B,UAAAC,IAAI;AAAA,WAAIL,WAAW,CAACK,IAAD,CAAX,CAAkBa,OAAtB;AAAA,GAAjC,CAApB;AACAD,EAAAA,WAAW,CAACV,IAAZ,CACE,UAACY,EAAD,EAAKC,EAAL;AAAA,WACE,CAACD,EAAE,IAAI,IAAN,IAAcA,EAAE,KAAK,OAArB,GAA+BH,aAA/B,GAA+CG,EAAhD,KACCC,EAAE,IAAI,IAAN,IAAcA,EAAE,KAAK,OAArB,GAA+BJ,aAA/B,GAA+CI,EADhD,CADF;AAAA,GADF;AAMA,SAAOH,WAAW,CAAC,CAAD,CAAlB;AACD;AAED,OAAO,SAASI,mBAAT,CAA6BrB,WAA7B,EAAkE;AACvE,SAAOE,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyBsB,MAAzB,CACL,UAACC,WAAD,EAAclB,IAAd;AAAA,WAAuBkB,WAAW,IAAIvB,WAAW,CAACK,IAAD,CAAX,CAAkBkB,WAAxD;AAAA,GADK,EAEL,IAFK,CAAP;AAID;AAED,OAAO,SAASC,eAAT,CAAyBxB,WAAzB,EAA8D;AACnE,SAAOE,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyBsB,MAAzB,CACL,UAACG,OAAD,EAAUpB,IAAV;AAAA,WAAmBoB,OAAO,IAAIzB,WAAW,CAACK,IAAD,CAAX,CAAkBoB,OAAhD;AAAA,GADK,EAEL,IAFK,CAAP;AAID","sourcesContent":["import { PermissionExpiration, PermissionMap, PermissionStatus } from './Permissions.types';\n\nexport function coalesceStatuses(permissions: PermissionMap): PermissionStatus {\n  const statuses = Object.keys(permissions).map(type => permissions[type].status);\n  statuses.sort((status1, status2) => _getStatusWeight(status1) - _getStatusWeight(status2));\n  // We choose the \"heaviest\" status with the most implications\n  return statuses[statuses.length - 1];\n}\n\nfunction _getStatusWeight(status: PermissionStatus): number {\n  // In terms of weight, we treat UNDETERMINED > DENIED > GRANTED since UNDETERMINED requires the\n  // most amount of further handling (prompting for permission and then checking that permission)\n  // and GRANTED requires the least\n  switch (status) {\n    case PermissionStatus.GRANTED:\n      return 0;\n    case PermissionStatus.DENIED:\n      return 1;\n    case PermissionStatus.UNDETERMINED:\n      return 2;\n    default:\n      return 100;\n  }\n}\n\nexport function coalesceExpirations(permissions: PermissionMap): PermissionExpiration {\n  const maxExpiration = 9007199254740991; // Number.MAX_SAFE_INTEGER\n  const expirations = Object.keys(permissions).map(type => permissions[type].expires);\n  expirations.sort(\n    (e1, e2) =>\n      (e1 == null || e1 === 'never' ? maxExpiration : e1) -\n      (e2 == null || e2 === 'never' ? maxExpiration : e2)\n  );\n  // We choose the earliest expiration\n  return expirations[0];\n}\n\nexport function coalesceCanAskAgain(permissions: PermissionMap): boolean {\n  return Object.keys(permissions).reduce<boolean>(\n    (canAskAgain, type) => canAskAgain && permissions[type].canAskAgain,\n    true\n  );\n}\n\nexport function coalesceGranted(permissions: PermissionMap): boolean {\n  return Object.keys(permissions).reduce<boolean>(\n    (granted, type) => granted && permissions[type].granted,\n    true\n  );\n}\n"]},"metadata":{},"sourceType":"module"}