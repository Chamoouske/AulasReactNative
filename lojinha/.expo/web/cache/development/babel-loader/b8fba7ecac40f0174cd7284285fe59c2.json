{"ast":null,"code":"'use strict';\n\nimport { expectCodeIsEqual, FakeWritable } from \"../src/TestHelpers\";\nimport { emitNotificationDef, emitRequestDef, emitResponseDef, emitTypeDef } from \"../src/ImplementationWriter\";\nimport { Event } from \"../src/Event\";\nimport { Command } from \"../src/Command\";\nimport { Type } from \"../src/Type\";\nvar stream = null;\nbeforeEach(function () {\n  stream = new FakeWritable();\n});\ntest('emits type def', function () {\n  var obj = {\n    'id': 'Location',\n    'type': 'object',\n    'properties': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Script identifier as reported in the <code>Debugger.scriptParsed</code>.'\n    }, {\n      'name': 'lineNumber',\n      'type': 'integer',\n      'description': 'Line number in the script (0-based).'\n    }, {\n      'name': 'columnNumber',\n      'type': 'integer',\n      'optional': true,\n      'description': 'Column number in the script (0-based).'\n    }],\n    'description': 'Location in the source code.'\n  };\n  var type = Type.create('Debugger', obj);\n  emitTypeDef(stream, type);\n  expectCodeIsEqual(stream.get(), \"\\n    debugger::Location::Location(const dynamic &obj) {\\n      assign(scriptId, obj, \\\"scriptId\\\");\\n      assign(lineNumber, obj, \\\"lineNumber\\\");\\n      assign(columnNumber, obj, \\\"columnNumber\\\");\\n    }\\n\\n    dynamic debugger::Location::toDynamic() const {\\n      dynamic obj = dynamic::object;\\n      put(obj, \\\"scriptId\\\", scriptId);\\n      put(obj, \\\"lineNumber\\\", lineNumber);\\n      put(obj, \\\"columnNumber\\\", columnNumber);\\n      return obj;\\n    }\\n  \");\n});\ntest('emits request def', function () {\n  var obj = {\n    'name': 'getScriptSource',\n    'parameters': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Id of the script to get source for.'\n    }],\n    'returns': [{\n      'name': 'scriptSource',\n      'type': 'string',\n      'description': 'Script source.'\n    }],\n    'description': 'Returns source for the script with given id.'\n  };\n  var command = Command.create('Debugger', obj);\n  emitRequestDef(stream, command);\n  expectCodeIsEqual(stream.get(), \"\\n    debugger::GetScriptSourceRequest::GetScriptSourceRequest()\\n      : Request(\\\"Debugger.getScriptSource\\\") {}\\n\\n    debugger::GetScriptSourceRequest::GetScriptSourceRequest(const dynamic &obj)\\n        : Request(\\\"Debugger.getScriptSource\\\") {\\n      assign(id, obj, \\\"id\\\");\\n      assign(method, obj, \\\"method\\\");\\n\\n      dynamic params = obj.at(\\\"params\\\");\\n      assign(scriptId, params, \\\"scriptId\\\");\\n    }\\n\\n    dynamic debugger::GetScriptSourceRequest::toDynamic() const {\\n      dynamic params = dynamic::object;\\n      put(params, \\\"scriptId\\\", scriptId);\\n\\n      dynamic obj = dynamic::object;\\n      put(obj, \\\"id\\\", id);\\n      put(obj, \\\"method\\\", method);\\n      put(obj, \\\"params\\\", std::move(params));\\n      return obj;\\n    }\\n\\n    void debugger::GetScriptSourceRequest::accept(RequestHandler &handler) const {\\n      handler.handle(*this);\\n    }\\n  \");\n});\ntest('emits response def', function () {\n  var obj = {\n    'name': 'getScriptSource',\n    'parameters': [{\n      'name': 'scriptId',\n      '$ref': 'Runtime.ScriptId',\n      'description': 'Id of the script to get source for.'\n    }],\n    'returns': [{\n      'name': 'scriptSource',\n      'type': 'string',\n      'description': 'Script source.'\n    }],\n    'description': 'Returns source for the script with given id.'\n  };\n  var command = Command.create('Debugger', obj);\n  emitResponseDef(stream, command);\n  expectCodeIsEqual(stream.get(), \"\\n    debugger::GetScriptSourceResponse::GetScriptSourceResponse(const dynamic &obj) {\\n      assign(id, obj, \\\"id\\\");\\n\\n      dynamic res = obj.at(\\\"result\\\");\\n      assign(scriptSource, res, \\\"scriptSource\\\");\\n    }\\n\\n    dynamic debugger::GetScriptSourceResponse::toDynamic() const {\\n      dynamic res = dynamic::object;\\n      put(res, \\\"scriptSource\\\", scriptSource);\\n\\n      dynamic obj = dynamic::object;\\n      put(obj, \\\"id\\\", id);\\n      put(obj, \\\"result\\\", std::move(res));\\n      return obj;\\n    }\\n  \");\n});\ntest('emits notification def', function () {\n  var obj = {\n    'name': 'messageAdded',\n    'parameters': [{\n      'name': 'message',\n      '$ref': 'ConsoleMessage',\n      'description': 'Console message that has been added.'\n    }],\n    'description': 'Issued when new console message is added.'\n  };\n  var event = Event.create('Console', obj);\n  emitNotificationDef(stream, event);\n  expectCodeIsEqual(stream.get(), \"\\n    console::MessageAddedNotification::MessageAddedNotification()\\n        : Notification(\\\"Console.messageAdded\\\") {}\\n\\n    console::MessageAddedNotification::MessageAddedNotification(const dynamic &obj)\\n        : Notification(\\\"Console.messageAdded\\\") {\\n      assign(method, obj, \\\"method\\\");\\n\\n      dynamic params = obj.at(\\\"params\\\");\\n      assign(message, params, \\\"message\\\");\\n    }\\n\\n    dynamic console::MessageAddedNotification::toDynamic() const {\\n      dynamic params = dynamic::object;\\n      put(params, \\\"message\\\", message);\\n\\n      dynamic obj = dynamic::object;\\n      put(obj, \\\"method\\\", method);\\n      put(obj, \\\"params\\\", std::move(params));\\n      return obj;\\n    }\\n  \");\n});","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/ReactCommon/hermes/inspector/tools/msggen/__tests__/ImplementationWriterTest.js"],"names":["expectCodeIsEqual","FakeWritable","emitNotificationDef","emitRequestDef","emitResponseDef","emitTypeDef","Event","Command","Type","stream","beforeEach","test","obj","type","create","get","command","event"],"mappings":"AAOA;;AAEA,SAASA,iBAAT,EAA4BC,YAA5B;AACA,SACEC,mBADF,EAEEC,cAFF,EAGEC,eAHF,EAIEC,WAJF;AAMA,SAASC,KAAT;AACA,SAASC,OAAT;AACA,SAASC,IAAT;AAEA,IAAIC,MAAM,GAAG,IAAb;AAEAC,UAAU,CAAC,YAAM;AACfD,EAAAA,MAAM,GAAG,IAAIR,YAAJ,EAAT;AACD,CAFS,CAAV;AAIAU,IAAI,CAAC,gBAAD,EAAmB,YAAM;AAC3B,MAAIC,GAAG,GAAG;AACR,UAAM,UADE;AAER,YAAQ,QAFA;AAGR,kBAAc,CACV;AAAE,cAAQ,UAAV;AAAsB,cAAQ,kBAA9B;AAAkD,qBAAe;AAAjE,KADU,EAEV;AAAE,cAAQ,YAAV;AAAwB,cAAQ,SAAhC;AAA2C,qBAAe;AAA1D,KAFU,EAGV;AAAE,cAAQ,cAAV;AAA0B,cAAQ,SAAlC;AAA6C,kBAAY,IAAzD;AAA+D,qBAAe;AAA9E,KAHU,CAHN;AAQR,mBAAe;AARP,GAAV;AAUA,MAAIC,IAAI,GAAGL,IAAI,CAACM,MAAL,CAAY,UAAZ,EAAwBF,GAAxB,CAAX;AAEAP,EAAAA,WAAW,CAACI,MAAD,EAASI,IAAT,CAAX;AAEAb,EAAAA,iBAAiB,CAACS,MAAM,CAACM,GAAP,EAAD,sdAAjB;AAeD,CA9BG,CAAJ;AAgCAJ,IAAI,CAAC,mBAAD,EAAsB,YAAM;AAC9B,MAAIC,GAAG,GAAG;AACR,YAAQ,iBADA;AAER,kBAAc,CACZ;AAAE,cAAQ,UAAV;AAAsB,cAAQ,kBAA9B;AAAkD,qBAAe;AAAjE,KADY,CAFN;AAKR,eAAW,CACT;AAAE,cAAQ,cAAV;AAA0B,cAAQ,QAAlC;AAA4C,qBAAe;AAA3D,KADS,CALH;AAQR,mBAAe;AARP,GAAV;AAUA,MAAII,OAAO,GAAGT,OAAO,CAACO,MAAR,CAAe,UAAf,EAA2BF,GAA3B,CAAd;AAEAT,EAAAA,cAAc,CAACM,MAAD,EAASO,OAAT,CAAd;AAEAhB,EAAAA,iBAAiB,CAACS,MAAM,CAACM,GAAP,EAAD,u3BAAjB;AA4BD,CA3CG,CAAJ;AA6CAJ,IAAI,CAAC,oBAAD,EAAuB,YAAM;AAC/B,MAAIC,GAAG,GAAG;AACR,YAAQ,iBADA;AAER,kBAAc,CACZ;AAAE,cAAQ,UAAV;AAAsB,cAAQ,kBAA9B;AAAkD,qBAAe;AAAjE,KADY,CAFN;AAKR,eAAW,CACT;AAAE,cAAQ,cAAV;AAA0B,cAAQ,QAAlC;AAA4C,qBAAe;AAA3D,KADS,CALH;AAQR,mBAAe;AARP,GAAV;AAUA,MAAII,OAAO,GAAGT,OAAO,CAACO,MAAR,CAAe,UAAf,EAA2BF,GAA3B,CAAd;AAEAR,EAAAA,eAAe,CAACK,MAAD,EAASO,OAAT,CAAf;AAEAhB,EAAAA,iBAAiB,CAACS,MAAM,CAACM,GAAP,EAAD,8gBAAjB;AAkBD,CAjCG,CAAJ;AAmCAJ,IAAI,CAAC,wBAAD,EAA2B,YAAM;AACnC,MAAIC,GAAG,GAAG;AACR,YAAQ,cADA;AAER,kBAAc,CACZ;AAAE,cAAQ,SAAV;AAAqB,cAAQ,gBAA7B;AAA+C,qBAAe;AAA9D,KADY,CAFN;AAKR,mBAAe;AALP,GAAV;AAOA,MAAIK,KAAK,GAAGX,KAAK,CAACQ,MAAN,CAAa,SAAb,EAAwBF,GAAxB,CAAZ;AAEAV,EAAAA,mBAAmB,CAACO,MAAD,EAASQ,KAAT,CAAnB;AAEAjB,EAAAA,iBAAiB,CAACS,MAAM,CAACM,GAAP,EAAD,ssBAAjB;AAsBD,CAlCG,CAAJ","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nimport { expectCodeIsEqual, FakeWritable } from '../src/TestHelpers';\nimport {\n  emitNotificationDef,\n  emitRequestDef,\n  emitResponseDef,\n  emitTypeDef,\n} from '../src/ImplementationWriter';\nimport { Event } from '../src/Event';\nimport { Command } from '../src/Command';\nimport { Type } from '../src/Type';\n\nlet stream = null;\n\nbeforeEach(() => {\n  stream = new FakeWritable();\n});\n\ntest('emits type def', () => {\n  let obj = {\n    'id': 'Location',\n    'type': 'object',\n    'properties': [\n        { 'name': 'scriptId', '$ref': 'Runtime.ScriptId', 'description': 'Script identifier as reported in the <code>Debugger.scriptParsed</code>.' },\n        { 'name': 'lineNumber', 'type': 'integer', 'description': 'Line number in the script (0-based).' },\n        { 'name': 'columnNumber', 'type': 'integer', 'optional': true, 'description': 'Column number in the script (0-based).' },\n    ],\n    'description': 'Location in the source code.',\n  };\n  let type = Type.create('Debugger', obj);\n\n  emitTypeDef(stream, type);\n\n  expectCodeIsEqual(stream.get(), `\n    debugger::Location::Location(const dynamic &obj) {\n      assign(scriptId, obj, \"scriptId\");\n      assign(lineNumber, obj, \"lineNumber\");\n      assign(columnNumber, obj, \"columnNumber\");\n    }\n\n    dynamic debugger::Location::toDynamic() const {\n      dynamic obj = dynamic::object;\n      put(obj, \"scriptId\", scriptId);\n      put(obj, \"lineNumber\", lineNumber);\n      put(obj, \"columnNumber\", columnNumber);\n      return obj;\n    }\n  `);\n});\n\ntest('emits request def', () => {\n  let obj = {\n    'name': 'getScriptSource',\n    'parameters': [\n      { 'name': 'scriptId', '$ref': 'Runtime.ScriptId', 'description': 'Id of the script to get source for.' },\n    ],\n    'returns': [\n      { 'name': 'scriptSource', 'type': 'string', 'description': 'Script source.' },\n    ],\n    'description': 'Returns source for the script with given id.',\n  };\n  let command = Command.create('Debugger', obj);\n\n  emitRequestDef(stream, command);\n\n  expectCodeIsEqual(stream.get(), `\n    debugger::GetScriptSourceRequest::GetScriptSourceRequest()\n      : Request(\"Debugger.getScriptSource\") {}\n\n    debugger::GetScriptSourceRequest::GetScriptSourceRequest(const dynamic &obj)\n        : Request(\"Debugger.getScriptSource\") {\n      assign(id, obj, \"id\");\n      assign(method, obj, \"method\");\n\n      dynamic params = obj.at(\"params\");\n      assign(scriptId, params, \"scriptId\");\n    }\n\n    dynamic debugger::GetScriptSourceRequest::toDynamic() const {\n      dynamic params = dynamic::object;\n      put(params, \"scriptId\", scriptId);\n\n      dynamic obj = dynamic::object;\n      put(obj, \"id\", id);\n      put(obj, \"method\", method);\n      put(obj, \"params\", std::move(params));\n      return obj;\n    }\n\n    void debugger::GetScriptSourceRequest::accept(RequestHandler &handler) const {\n      handler.handle(*this);\n    }\n  `);\n});\n\ntest('emits response def', () => {\n  let obj = {\n    'name': 'getScriptSource',\n    'parameters': [\n      { 'name': 'scriptId', '$ref': 'Runtime.ScriptId', 'description': 'Id of the script to get source for.' },\n    ],\n    'returns': [\n      { 'name': 'scriptSource', 'type': 'string', 'description': 'Script source.' },\n    ],\n    'description': 'Returns source for the script with given id.',\n  };\n  let command = Command.create('Debugger', obj);\n\n  emitResponseDef(stream, command);\n\n  expectCodeIsEqual(stream.get(), `\n    debugger::GetScriptSourceResponse::GetScriptSourceResponse(const dynamic &obj) {\n      assign(id, obj, \"id\");\n\n      dynamic res = obj.at(\"result\");\n      assign(scriptSource, res, \"scriptSource\");\n    }\n\n    dynamic debugger::GetScriptSourceResponse::toDynamic() const {\n      dynamic res = dynamic::object;\n      put(res, \"scriptSource\", scriptSource);\n\n      dynamic obj = dynamic::object;\n      put(obj, \"id\", id);\n      put(obj, \"result\", std::move(res));\n      return obj;\n    }\n  `);\n});\n\ntest('emits notification def', () => {\n  let obj = {\n    'name': 'messageAdded',\n    'parameters': [\n      { 'name': 'message', '$ref': 'ConsoleMessage', 'description': 'Console message that has been added.' },\n    ],\n    'description': 'Issued when new console message is added.',\n  };\n  let event = Event.create('Console', obj);\n\n  emitNotificationDef(stream, event);\n\n  expectCodeIsEqual(stream.get(), `\n    console::MessageAddedNotification::MessageAddedNotification()\n        : Notification(\"Console.messageAdded\") {}\n\n    console::MessageAddedNotification::MessageAddedNotification(const dynamic &obj)\n        : Notification(\"Console.messageAdded\") {\n      assign(method, obj, \"method\");\n\n      dynamic params = obj.at(\"params\");\n      assign(message, params, \"message\");\n    }\n\n    dynamic console::MessageAddedNotification::toDynamic() const {\n      dynamic params = dynamic::object;\n      put(params, \"message\", message);\n\n      dynamic obj = dynamic::object;\n      put(obj, \"method\", method);\n      put(obj, \"params\", std::move(params));\n      return obj;\n    }\n  `);\n});\n"]},"metadata":{},"sourceType":"module"}