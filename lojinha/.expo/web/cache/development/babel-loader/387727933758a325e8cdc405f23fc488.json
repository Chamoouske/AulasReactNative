{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar json_file_1 = __importDefault(require(\"@expo/json-file\"));\n\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nvar glob_1 = require(\"glob\");\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar resolve_from_1 = __importDefault(require(\"resolve-from\"));\n\nvar semver_1 = __importDefault(require(\"semver\"));\n\nvar slugify_1 = __importDefault(require(\"slugify\"));\n\nvar Errors_1 = require(\"./Errors\");\n\nvar Project_1 = require(\"./Project\");\n\nvar getConfig_1 = require(\"./getConfig\");\n\nvar withConfigPlugins_1 = require(\"./plugins/withConfigPlugins\");\n\nvar withInternal_1 = require(\"./plugins/withInternal\");\n\nvar resolvePackageJson_1 = require(\"./resolvePackageJson\");\n\nfunction reduceExpoObject(config) {\n  var _a;\n\n  if (!config) return config === undefined ? null : config;\n\n  var _b = (_a = config.expo) !== null && _a !== void 0 ? _a : config,\n      mods = _b.mods,\n      expo = __rest(_b, [\"mods\"]);\n\n  return {\n    expo: expo,\n    mods: mods\n  };\n}\n\nfunction getSupportedPlatforms(projectRoot) {\n  var platforms = [];\n\n  if (resolve_from_1.default.silent(projectRoot, 'react-native')) {\n    platforms.push('ios', 'android');\n  }\n\n  if (resolve_from_1.default.silent(projectRoot, 'react-native-web')) {\n    platforms.push('web');\n  }\n\n  return platforms;\n}\n\nfunction getConfig(projectRoot) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var paths = getConfigFilePaths(projectRoot);\n  var rawStaticConfig = paths.staticConfigPath ? getConfig_1.getStaticConfig(paths.staticConfigPath) : null;\n  var rootConfig = rawStaticConfig || {};\n  var staticConfig = reduceExpoObject(rawStaticConfig) || {};\n\n  var _getPackageJsonAndPat = getPackageJsonAndPath(projectRoot),\n      _getPackageJsonAndPat2 = _slicedToArray(_getPackageJsonAndPat, 2),\n      packageJson = _getPackageJsonAndPat2[0],\n      packageJsonPath = _getPackageJsonAndPat2[1];\n\n  function fillAndReturnConfig(config, dynamicConfigObjectType) {\n    var _a, _b, _c;\n\n    var configWithDefaultValues = _extends(_extends({}, ensureConfigHasDefaultValues({\n      projectRoot: projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: options.skipSDKVersionRequirement,\n      paths: paths,\n      packageJsonPath: packageJsonPath\n    })), {\n      mods: config.mods,\n      dynamicConfigObjectType: dynamicConfigObjectType,\n      rootConfig: rootConfig,\n      dynamicConfigPath: paths.dynamicConfigPath,\n      staticConfigPath: paths.staticConfigPath\n    });\n\n    if (options.isModdedConfig) {\n      configWithDefaultValues.exp.mods = (_a = config.mods) !== null && _a !== void 0 ? _a : null;\n    }\n\n    configWithDefaultValues.exp = withConfigPlugins_1.withConfigPlugins(configWithDefaultValues.exp);\n\n    if (!options.isModdedConfig) {\n      delete configWithDefaultValues.exp.mods;\n    }\n\n    if (options.isPublicConfig) {\n      delete configWithDefaultValues.exp._internal;\n\n      if (configWithDefaultValues.exp.hooks) {\n        delete configWithDefaultValues.exp.hooks;\n      }\n\n      if ((_b = configWithDefaultValues.exp.ios) === null || _b === void 0 ? void 0 : _b.config) {\n        delete configWithDefaultValues.exp.ios.config;\n      }\n\n      if ((_c = configWithDefaultValues.exp.android) === null || _c === void 0 ? void 0 : _c.config) {\n        delete configWithDefaultValues.exp.android.config;\n      }\n    }\n\n    return configWithDefaultValues;\n  }\n\n  function getContextConfig(config) {\n    return ensureConfigHasDefaultValues({\n      projectRoot: projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: true,\n      paths: paths,\n      packageJsonPath: packageJsonPath\n    }).exp;\n  }\n\n  if (paths.dynamicConfigPath) {\n    var _getConfig_1$getDynam = getConfig_1.getDynamicConfig(paths.dynamicConfigPath, {\n      projectRoot: projectRoot,\n      staticConfigPath: paths.staticConfigPath,\n      packageJsonPath: packageJsonPath,\n      config: getContextConfig(staticConfig)\n    }),\n        exportedObjectType = _getConfig_1$getDynam.exportedObjectType,\n        rawDynamicConfig = _getConfig_1$getDynam.config;\n\n    var dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};\n    return fillAndReturnConfig(dynamicConfig, exportedObjectType);\n  }\n\n  return fillAndReturnConfig(staticConfig || {}, null);\n}\n\nexports.getConfig = getConfig;\n\nfunction getPackageJson(projectRoot) {\n  var _getPackageJsonAndPat3 = getPackageJsonAndPath(projectRoot),\n      _getPackageJsonAndPat4 = _slicedToArray(_getPackageJsonAndPat3, 1),\n      pkg = _getPackageJsonAndPat4[0];\n\n  return pkg;\n}\n\nexports.getPackageJson = getPackageJson;\n\nfunction getPackageJsonAndPath(projectRoot) {\n  var packageJsonPath = resolvePackageJson_1.getRootPackageJsonPath(projectRoot);\n  return [json_file_1.default.read(packageJsonPath), packageJsonPath];\n}\n\nfunction readConfigJson(projectRoot) {\n  var skipValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var skipNativeValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var paths = getConfigFilePaths(projectRoot);\n  var rawStaticConfig = paths.staticConfigPath ? getConfig_1.getStaticConfig(paths.staticConfigPath) : null;\n\n  var getConfigName = function getConfigName() {\n    if (paths.staticConfigPath) return \" `\" + path_1.default.basename(paths.staticConfigPath) + \"`\";\n    return '';\n  };\n\n  var outputRootConfig = rawStaticConfig;\n\n  if (outputRootConfig === null || typeof outputRootConfig !== 'object') {\n    if (skipValidation) {\n      outputRootConfig = {\n        expo: {}\n      };\n    } else {\n      throw new Errors_1.ConfigError(\"Project at path \" + path_1.default.resolve(projectRoot) + \" does not contain a valid Expo config\" + getConfigName(), 'NOT_OBJECT');\n    }\n  }\n\n  var exp = outputRootConfig.expo;\n\n  if (exp === null || typeof exp !== 'object') {\n    throw new Errors_1.ConfigError(\"Property 'expo' in\" + getConfigName() + \" for project at path \" + path_1.default.resolve(projectRoot) + \" is not an object. Please make sure\" + getConfigName() + \" includes a managed Expo app config like this: \" + APP_JSON_EXAMPLE, 'NO_EXPO');\n  }\n\n  exp = _extends({}, exp);\n\n  var _getPackageJsonAndPat5 = getPackageJsonAndPath(projectRoot),\n      _getPackageJsonAndPat6 = _slicedToArray(_getPackageJsonAndPat5, 2),\n      pkg = _getPackageJsonAndPat6[0],\n      packageJsonPath = _getPackageJsonAndPat6[1];\n\n  return _extends(_extends(_extends({}, ensureConfigHasDefaultValues({\n    projectRoot: projectRoot,\n    exp: exp,\n    pkg: pkg,\n    skipSDKVersionRequirement: skipNativeValidation,\n    paths: paths,\n    packageJsonPath: packageJsonPath\n  })), {\n    mods: null,\n    dynamicConfigPath: null,\n    dynamicConfigObjectType: null,\n    rootConfig: _extends({}, outputRootConfig)\n  }), paths);\n}\n\nexports.readConfigJson = readConfigJson;\n\nfunction readConfigJsonAsync(projectRoot) {\n  var skipValidation,\n      skipNativeValidation,\n      _args = arguments;\n  return _regeneratorRuntime.async(function readConfigJsonAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          skipValidation = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n          skipNativeValidation = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n          return _context.abrupt(\"return\", readConfigJson(projectRoot, skipValidation, skipNativeValidation));\n\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.readConfigJsonAsync = readConfigJsonAsync;\n\nfunction getConfigFilePaths(projectRoot) {\n  var customPaths = getCustomConfigFilePaths(projectRoot);\n\n  if (customPaths) {\n    return customPaths;\n  }\n\n  return {\n    dynamicConfigPath: getDynamicConfigFilePath(projectRoot),\n    staticConfigPath: getStaticConfigFilePath(projectRoot)\n  };\n}\n\nexports.getConfigFilePaths = getConfigFilePaths;\n\nfunction getCustomConfigFilePaths(projectRoot) {\n  if (!customConfigPaths[projectRoot]) {\n    return null;\n  }\n\n  if (isDynamicFilePath(customConfigPaths[projectRoot])) {\n    return {\n      dynamicConfigPath: customConfigPaths[projectRoot],\n      staticConfigPath: null\n    };\n  }\n\n  return {\n    staticConfigPath: customConfigPaths[projectRoot],\n    dynamicConfigPath: null\n  };\n}\n\nfunction getDynamicConfigFilePath(projectRoot) {\n  for (var _i = 0, _arr = ['app.config.ts', 'app.config.js']; _i < _arr.length; _i++) {\n    var fileName = _arr[_i];\n    var configPath = path_1.default.join(projectRoot, fileName);\n\n    if (fs_extra_1.default.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n\n  return null;\n}\n\nfunction getStaticConfigFilePath(projectRoot) {\n  for (var _i2 = 0, _arr2 = ['app.config.json', 'app.json']; _i2 < _arr2.length; _i2++) {\n    var fileName = _arr2[_i2];\n    var configPath = path_1.default.join(projectRoot, fileName);\n\n    if (fs_extra_1.default.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n\n  return null;\n}\n\nfunction findConfigFile(projectRoot) {\n  var configPath;\n\n  if (customConfigPaths[projectRoot]) {\n    configPath = customConfigPaths[projectRoot];\n    return {\n      configPath: configPath,\n      configName: path_1.default.basename(configPath),\n      configNamespace: 'expo'\n    };\n  } else {\n    configPath = path_1.default.join(projectRoot, 'app.config.json');\n\n    if (!fs_extra_1.default.existsSync(configPath)) {\n      configPath = path_1.default.join(projectRoot, 'app.json');\n    }\n  }\n\n  return {\n    configPath: configPath,\n    configName: path_1.default.basename(configPath),\n    configNamespace: 'expo'\n  };\n}\n\nexports.findConfigFile = findConfigFile;\n\nfunction configFilename(projectRoot) {\n  return findConfigFile(projectRoot).configName;\n}\n\nexports.configFilename = configFilename;\n\nfunction readExpRcAsync(projectRoot) {\n  var expRcPath;\n  return _regeneratorRuntime.async(function readExpRcAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          expRcPath = path_1.default.join(projectRoot, '.exprc');\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(json_file_1.default.readAsync(expRcPath, {\n            json5: true,\n            cantReadFileDefault: {}\n          }));\n\n        case 3:\n          return _context2.abrupt(\"return\", _context2.sent);\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.readExpRcAsync = readExpRcAsync;\nvar customConfigPaths = {};\n\nfunction resetCustomConfigPaths() {\n  for (var _i3 = 0, _Object$keys = Object.keys(customConfigPaths); _i3 < _Object$keys.length; _i3++) {\n    var key = _Object$keys[_i3];\n    delete customConfigPaths[key];\n  }\n}\n\nexports.resetCustomConfigPaths = resetCustomConfigPaths;\n\nfunction setCustomConfigPath(projectRoot, configPath) {\n  customConfigPaths[projectRoot] = configPath;\n}\n\nexports.setCustomConfigPath = setCustomConfigPath;\n\nfunction modifyConfigAsync(projectRoot, modifications) {\n  var readOptions,\n      writeOptions,\n      config,\n      outputConfig,\n      _args3 = arguments;\n  return _regeneratorRuntime.async(function modifyConfigAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          readOptions = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n          writeOptions = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};\n          config = getConfig(projectRoot, readOptions);\n\n          if (!config.dynamicConfigPath) {\n            _context3.next = 7;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            type: 'warn',\n            message: \"Cannot automatically write to dynamic config at: \" + path_1.default.relative(projectRoot, config.dynamicConfigPath),\n            config: null\n          });\n\n        case 7:\n          if (!config.staticConfigPath) {\n            _context3.next = 13;\n            break;\n          }\n\n          if (config.rootConfig.expo) {\n            outputConfig = _extends(_extends({}, config.rootConfig), {\n              expo: _extends(_extends({}, config.rootConfig.expo), modifications)\n            });\n          } else {\n            outputConfig = _extends(_extends({}, config.rootConfig), modifications);\n          }\n\n          if (writeOptions.dryRun) {\n            _context3.next = 12;\n            break;\n          }\n\n          _context3.next = 12;\n          return _regeneratorRuntime.awrap(json_file_1.default.writeAsync(config.staticConfigPath, outputConfig, {\n            json5: false\n          }));\n\n        case 12:\n          return _context3.abrupt(\"return\", {\n            type: 'success',\n            config: outputConfig\n          });\n\n        case 13:\n          return _context3.abrupt(\"return\", {\n            type: 'fail',\n            message: 'No config exists',\n            config: null\n          });\n\n        case 14:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.modifyConfigAsync = modifyConfigAsync;\nvar APP_JSON_EXAMPLE = JSON.stringify({\n  expo: {\n    name: 'My app',\n    slug: 'my-app',\n    sdkVersion: '...'\n  }\n});\n\nfunction ensureConfigHasDefaultValues(_ref) {\n  var projectRoot = _ref.projectRoot,\n      exp = _ref.exp,\n      pkg = _ref.pkg,\n      paths = _ref.paths,\n      packageJsonPath = _ref.packageJsonPath,\n      _ref$skipSDKVersionRe = _ref.skipSDKVersionRequirement,\n      skipSDKVersionRequirement = _ref$skipSDKVersionRe === void 0 ? false : _ref$skipSDKVersionRe;\n\n  var _a, _b, _c;\n\n  if (!exp) {\n    exp = {};\n  }\n\n  exp = withInternal_1.withInternal(exp, _extends(_extends({\n    projectRoot: projectRoot\n  }, paths !== null && paths !== void 0 ? paths : {}), {\n    packageJsonPath: packageJsonPath\n  }));\n  var pkgName = typeof pkg.name === 'string' ? pkg.name : path_1.default.basename(projectRoot);\n  var pkgVersion = typeof pkg.version === 'string' ? pkg.version : '1.0.0';\n\n  var pkgWithDefaults = _extends(_extends({}, pkg), {\n    name: pkgName,\n    version: pkgVersion\n  });\n\n  var name = (_a = exp.name) !== null && _a !== void 0 ? _a : pkgName;\n  var slug = (_b = exp.slug) !== null && _b !== void 0 ? _b : slugify_1.default(name.toLowerCase());\n  var version = (_c = exp.version) !== null && _c !== void 0 ? _c : pkgVersion;\n  var description = exp.description;\n\n  if (!description && typeof pkg.description === 'string') {\n    description = pkg.description;\n  }\n\n  var expWithDefaults = _extends(_extends({}, exp), {\n    name: name,\n    slug: slug,\n    version: version,\n    description: description\n  });\n\n  var sdkVersion;\n\n  try {\n    sdkVersion = Project_1.getExpoSDKVersion(projectRoot, expWithDefaults);\n  } catch (error) {\n    if (!skipSDKVersionRequirement) throw error;\n  }\n\n  var platforms = exp.platforms;\n\n  if (!platforms) {\n    platforms = getSupportedPlatforms(projectRoot);\n  }\n\n  return {\n    exp: _extends(_extends({}, expWithDefaults), {\n      sdkVersion: sdkVersion,\n      platforms: platforms\n    }),\n    pkg: pkgWithDefaults\n  };\n}\n\nfunction writeConfigJsonAsync(projectRoot, options) {\n  var paths, _await$readConfigJson, exp, pkg, rootConfig, dynamicConfigObjectType, staticConfigPath;\n\n  return _regeneratorRuntime.async(function writeConfigJsonAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          paths = getConfigFilePaths(projectRoot);\n          _context4.next = 3;\n          return _regeneratorRuntime.awrap(readConfigJsonAsync(projectRoot));\n\n        case 3:\n          _await$readConfigJson = _context4.sent;\n          exp = _await$readConfigJson.exp;\n          pkg = _await$readConfigJson.pkg;\n          rootConfig = _await$readConfigJson.rootConfig;\n          dynamicConfigObjectType = _await$readConfigJson.dynamicConfigObjectType;\n          staticConfigPath = _await$readConfigJson.staticConfigPath;\n          exp = _extends(_extends({}, rootConfig.expo), options);\n          rootConfig = _extends(_extends({}, rootConfig), {\n            expo: exp\n          });\n\n          if (!paths.staticConfigPath) {\n            _context4.next = 16;\n            break;\n          }\n\n          _context4.next = 14;\n          return _regeneratorRuntime.awrap(json_file_1.default.writeAsync(paths.staticConfigPath, rootConfig, {\n            json5: false\n          }));\n\n        case 14:\n          _context4.next = 17;\n          break;\n\n        case 16:\n          console.log('Failed to write to config: ', options);\n\n        case 17:\n          return _context4.abrupt(\"return\", _extends({\n            exp: exp,\n            pkg: pkg,\n            rootConfig: rootConfig,\n            staticConfigPath: staticConfigPath,\n            dynamicConfigObjectType: dynamicConfigObjectType\n          }, paths));\n\n        case 18:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.writeConfigJsonAsync = writeConfigJsonAsync;\nvar DEFAULT_BUILD_PATH = \"web-build\";\n\nfunction getWebOutputPath() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _a, _b;\n\n  if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {\n    return process.env.WEBPACK_BUILD_OUTPUT_PATH;\n  }\n\n  var expo = config.expo || config || {};\n  return ((_b = (_a = expo === null || expo === void 0 ? void 0 : expo.web) === null || _a === void 0 ? void 0 : _a.build) === null || _b === void 0 ? void 0 : _b.output) || DEFAULT_BUILD_PATH;\n}\n\nexports.getWebOutputPath = getWebOutputPath;\n\nfunction getNameFromConfig() {\n  var exp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var appManifest = exp.expo || exp;\n  var _appManifest$web = appManifest.web,\n      web = _appManifest$web === void 0 ? {} : _appManifest$web;\n  var appName = exp.displayName || appManifest.displayName || appManifest.name;\n  var webName = web.name || appName;\n  return {\n    appName: appName,\n    webName: webName\n  };\n}\n\nexports.getNameFromConfig = getNameFromConfig;\n\nfunction getDefaultTarget(projectRoot) {\n  var _getConfig = getConfig(projectRoot, {\n    skipSDKVersionRequirement: true\n  }),\n      exp = _getConfig.exp;\n\n  if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && semver_1.default.lt(exp.sdkVersion, '37.0.0')) {\n    return 'managed';\n  }\n\n  return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';\n}\n\nexports.getDefaultTarget = getDefaultTarget;\n\nfunction isBareWorkflowProject(projectRoot) {\n  var _getPackageJsonAndPat7 = getPackageJsonAndPath(projectRoot),\n      _getPackageJsonAndPat8 = _slicedToArray(_getPackageJsonAndPat7, 1),\n      pkg = _getPackageJsonAndPat8[0];\n\n  if (pkg.dependencies && pkg.dependencies.expokit) {\n    return false;\n  }\n\n  var xcodeprojFiles = glob_1.sync('ios/**/*.xcodeproj', {\n    absolute: true,\n    cwd: projectRoot\n  });\n\n  if (xcodeprojFiles.length) {\n    return true;\n  }\n\n  var gradleFiles = glob_1.sync('android/**/*.gradle', {\n    absolute: true,\n    cwd: projectRoot\n  });\n\n  if (gradleFiles.length) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isDynamicFilePath(filePath) {\n  return !!filePath.match(/\\.[j|t]s$/);\n}\n\nfunction getProjectConfigDescription(projectRoot) {\n  var paths = getConfigFilePaths(projectRoot);\n  return getProjectConfigDescriptionWithPaths(projectRoot, paths);\n}\n\nexports.getProjectConfigDescription = getProjectConfigDescription;\n\nfunction getProjectConfigDescriptionWithPaths(projectRoot, projectConfig) {\n  if (projectConfig.dynamicConfigPath) {\n    var relativeDynamicConfigPath = path_1.default.relative(projectRoot, projectConfig.dynamicConfigPath);\n\n    if (projectConfig.staticConfigPath) {\n      return relativeDynamicConfigPath + \" or \" + path_1.default.relative(projectRoot, projectConfig.staticConfigPath);\n    }\n\n    return relativeDynamicConfigPath;\n  } else if (projectConfig.staticConfigPath) {\n    return path_1.default.relative(projectRoot, projectConfig.staticConfigPath);\n  }\n\n  return 'app.json';\n}\n\nexports.getProjectConfigDescriptionWithPaths = getProjectConfigDescriptionWithPaths;\n\n__export(require(\"./Config.types\"));\n\nvar isLegacyImportsEnabled_1 = require(\"./isLegacyImportsEnabled\");\n\nexports.isLegacyImportsEnabled = isLegacyImportsEnabled_1.isLegacyImportsEnabled;","map":{"version":3,"sources":["../src/Config.ts"],"names":[],"mappings":"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","sourcesContent":["import { ModConfig } from '@expo/config-plugins';\nimport JsonFile, { JSONObject } from '@expo/json-file';\nimport fs from 'fs-extra';\nimport { sync as globSync } from 'glob';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\nimport slugify from 'slugify';\n\nimport {\n  AppJSONConfig,\n  ConfigFilePaths,\n  ExpoConfig,\n  ExpRc,\n  GetConfigOptions,\n  PackageJSONConfig,\n  Platform,\n  ProjectConfig,\n  ProjectTarget,\n  WriteConfigOptions,\n} from './Config.types';\nimport { ConfigError } from './Errors';\nimport { getExpoSDKVersion } from './Project';\nimport { getDynamicConfig, getStaticConfig } from './getConfig';\nimport { withConfigPlugins } from './plugins/withConfigPlugins';\nimport { withInternal } from './plugins/withInternal';\nimport { getRootPackageJsonPath } from './resolvePackageJson';\n\ntype SplitConfigs = { expo: ExpoConfig; mods: ModConfig };\n\n/**\n * If a config has an `expo` object then that will be used as the config.\n * This method reduces out other top level values if an `expo` object exists.\n *\n * @param config Input config object to reduce\n */\nfunction reduceExpoObject(config?: any): SplitConfigs {\n  if (!config) return config === undefined ? null : config;\n\n  const { mods, ...expo } = config.expo ?? config;\n\n  return {\n    expo,\n    mods,\n  };\n}\n\n/**\n * Get all platforms that a project is currently capable of running.\n *\n * @param projectRoot\n * @param exp\n */\nfunction getSupportedPlatforms(projectRoot: string): Platform[] {\n  const platforms: Platform[] = [];\n  if (resolveFrom.silent(projectRoot, 'react-native')) {\n    platforms.push('ios', 'android');\n  }\n  if (resolveFrom.silent(projectRoot, 'react-native-web')) {\n    platforms.push('web');\n  }\n  return platforms;\n}\n\n/**\n * Evaluate the config for an Expo project.\n * If a function is exported from the `app.config.js` then a partial config will be passed as an argument.\n * The partial config is composed from any existing app.json, and certain fields from the `package.json` like name and description.\n *\n * If options.isPublicConfig is true, the Expo config will include only public-facing options (omitting private keys).\n * The resulting config should be suitable for hosting or embedding in a publicly readable location.\n *\n * **Example**\n * ```js\n * module.exports = function({ config }) {\n *   // mutate the config before returning it.\n *   config.slug = 'new slug'\n *   return { expo: config };\n * }\n *\n * **Supports**\n * - `app.config.ts`\n * - `app.config.js`\n * - `app.config.json`\n * - `app.json`\n *\n * @param projectRoot the root folder containing all of your application code\n * @param options enforce criteria for a project config\n */\nexport function getConfig(projectRoot: string, options: GetConfigOptions = {}): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n  // For legacy reasons, always return an object.\n  const rootConfig = (rawStaticConfig || {}) as AppJSONConfig;\n  const staticConfig = reduceExpoObject(rawStaticConfig) || {};\n\n  // Can only change the package.json location if an app.json or app.config.json exists\n  const [packageJson, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  function fillAndReturnConfig(config: SplitConfigs, dynamicConfigObjectType: string | null) {\n    const configWithDefaultValues = {\n      ...ensureConfigHasDefaultValues({\n        projectRoot,\n        exp: config.expo,\n        pkg: packageJson,\n        skipSDKVersionRequirement: options.skipSDKVersionRequirement,\n        paths,\n        packageJsonPath,\n      }),\n      mods: config.mods,\n      dynamicConfigObjectType,\n      rootConfig,\n      dynamicConfigPath: paths.dynamicConfigPath,\n      staticConfigPath: paths.staticConfigPath,\n    };\n\n    if (options.isModdedConfig) {\n      // @ts-ignore: Add the mods back to the object.\n      configWithDefaultValues.exp.mods = config.mods ?? null;\n    }\n\n    // Apply static json plugins, should be done after _internal\n    configWithDefaultValues.exp = withConfigPlugins(configWithDefaultValues.exp);\n\n    if (!options.isModdedConfig) {\n      // @ts-ignore: Delete mods added by static plugins when they won't have a chance to be evaluated\n      delete configWithDefaultValues.exp.mods;\n    }\n\n    if (options.isPublicConfig) {\n      // Remove internal values with references to user's file paths from the public config.\n      delete configWithDefaultValues.exp._internal;\n\n      if (configWithDefaultValues.exp.hooks) {\n        delete configWithDefaultValues.exp.hooks;\n      }\n      if (configWithDefaultValues.exp.ios?.config) {\n        delete configWithDefaultValues.exp.ios.config;\n      }\n      if (configWithDefaultValues.exp.android?.config) {\n        delete configWithDefaultValues.exp.android.config;\n      }\n    }\n\n    return configWithDefaultValues;\n  }\n\n  // Fill in the static config\n  function getContextConfig(config: SplitConfigs) {\n    return ensureConfigHasDefaultValues({\n      projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: true,\n      paths,\n      packageJsonPath,\n    }).exp;\n  }\n\n  if (paths.dynamicConfigPath) {\n    // No app.config.json or app.json but app.config.js\n    const { exportedObjectType, config: rawDynamicConfig } = getDynamicConfig(\n      paths.dynamicConfigPath,\n      {\n        projectRoot,\n        staticConfigPath: paths.staticConfigPath,\n        packageJsonPath,\n        config: getContextConfig(staticConfig),\n      }\n    );\n    // Allow for the app.config.js to `export default null;`\n    // Use `dynamicConfigPath` to detect if a dynamic config exists.\n    const dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};\n    return fillAndReturnConfig(dynamicConfig, exportedObjectType);\n  }\n\n  // No app.config.js but json or no config\n  return fillAndReturnConfig(staticConfig || {}, null);\n}\n\nexport function getPackageJson(projectRoot: string): PackageJSONConfig {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n  return pkg;\n}\n\nfunction getPackageJsonAndPath(projectRoot: string): [PackageJSONConfig, string] {\n  const packageJsonPath = getRootPackageJsonPath(projectRoot);\n  return [JsonFile.read(packageJsonPath), packageJsonPath];\n}\n\nexport function readConfigJson(\n  projectRoot: string,\n  skipValidation: boolean = false,\n  skipNativeValidation: boolean = false\n): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n\n  const getConfigName = (): string => {\n    if (paths.staticConfigPath) return ` \\`${path.basename(paths.staticConfigPath)}\\``;\n    return '';\n  };\n\n  let outputRootConfig = rawStaticConfig as JSONObject | null;\n  if (outputRootConfig === null || typeof outputRootConfig !== 'object') {\n    if (skipValidation) {\n      outputRootConfig = { expo: {} };\n    } else {\n      throw new ConfigError(\n        `Project at path ${path.resolve(\n          projectRoot\n        )} does not contain a valid Expo config${getConfigName()}`,\n        'NOT_OBJECT'\n      );\n    }\n  }\n  let exp = outputRootConfig.expo as Partial<ExpoConfig>;\n  if (exp === null || typeof exp !== 'object') {\n    throw new ConfigError(\n      `Property 'expo' in${getConfigName()} for project at path ${path.resolve(\n        projectRoot\n      )} is not an object. Please make sure${getConfigName()} includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`,\n      'NO_EXPO'\n    );\n  }\n\n  exp = { ...exp };\n\n  const [pkg, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  return {\n    ...ensureConfigHasDefaultValues({\n      projectRoot,\n      exp,\n      pkg,\n      skipSDKVersionRequirement: skipNativeValidation,\n      paths,\n      packageJsonPath,\n    }),\n    mods: null,\n    dynamicConfigPath: null,\n    dynamicConfigObjectType: null,\n    rootConfig: { ...outputRootConfig } as AppJSONConfig,\n    ...paths,\n  };\n}\n\nexport async function readConfigJsonAsync(\n  projectRoot: string,\n  skipValidation: boolean = false,\n  skipNativeValidation: boolean = false\n): Promise<ProjectConfig> {\n  return readConfigJson(projectRoot, skipValidation, skipNativeValidation);\n}\n\n/**\n * Get the static and dynamic config paths for a project. Also accounts for custom paths.\n *\n * @param projectRoot\n */\nexport function getConfigFilePaths(projectRoot: string): ConfigFilePaths {\n  const customPaths = getCustomConfigFilePaths(projectRoot);\n  if (customPaths) {\n    return customPaths;\n  }\n\n  return {\n    dynamicConfigPath: getDynamicConfigFilePath(projectRoot),\n    staticConfigPath: getStaticConfigFilePath(projectRoot),\n  };\n}\n\nfunction getCustomConfigFilePaths(projectRoot: string): ConfigFilePaths | null {\n  if (!customConfigPaths[projectRoot]) {\n    return null;\n  }\n  // If the user picks a custom config path, we will only use that and skip searching for a secondary config.\n  if (isDynamicFilePath(customConfigPaths[projectRoot])) {\n    return {\n      dynamicConfigPath: customConfigPaths[projectRoot],\n      staticConfigPath: null,\n    };\n  }\n  // Anything that's not js or ts will be treated as json.\n  return { staticConfigPath: customConfigPaths[projectRoot], dynamicConfigPath: null };\n}\n\nfunction getDynamicConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.ts', 'app.config.js']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\nfunction getStaticConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.json', 'app.json']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\n// TODO: This should account for dynamic configs\nexport function findConfigFile(\n  projectRoot: string\n): { configPath: string; configName: string; configNamespace: 'expo' } {\n  let configPath: string;\n  // Check for a custom config path first.\n  if (customConfigPaths[projectRoot]) {\n    configPath = customConfigPaths[projectRoot];\n    // We shouldn't verify if the file exists because\n    // the user manually specified that this path should be used.\n    return {\n      configPath,\n      configName: path.basename(configPath),\n      configNamespace: 'expo',\n    };\n  } else {\n    // app.config.json takes higher priority over app.json\n    configPath = path.join(projectRoot, 'app.config.json');\n    if (!fs.existsSync(configPath)) {\n      configPath = path.join(projectRoot, 'app.json');\n    }\n  }\n\n  return {\n    configPath,\n    configName: path.basename(configPath),\n    configNamespace: 'expo',\n  };\n}\n\n// TODO: deprecate\nexport function configFilename(projectRoot: string): string {\n  return findConfigFile(projectRoot).configName;\n}\n\nexport async function readExpRcAsync(projectRoot: string): Promise<ExpRc> {\n  const expRcPath = path.join(projectRoot, '.exprc');\n  return await JsonFile.readAsync(expRcPath, { json5: true, cantReadFileDefault: {} });\n}\n\nconst customConfigPaths: { [projectRoot: string]: string } = {};\n\nexport function resetCustomConfigPaths(): void {\n  for (const key of Object.keys(customConfigPaths)) {\n    delete customConfigPaths[key];\n  }\n}\n\nexport function setCustomConfigPath(projectRoot: string, configPath: string): void {\n  customConfigPaths[projectRoot] = configPath;\n}\n\n/**\n * Attempt to modify an Expo project config.\n * This will only fully work if the project is using static configs only.\n * Otherwise 'warn' | 'fail' will return with a message about why the config couldn't be updated.\n * The potentially modified config object will be returned for testing purposes.\n *\n * @param projectRoot\n * @param modifications modifications to make to an existing config\n * @param readOptions options for reading the current config file\n * @param writeOptions If true, the static config file will not be rewritten\n */\nexport async function modifyConfigAsync(\n  projectRoot: string,\n  modifications: Partial<ExpoConfig>,\n  readOptions: GetConfigOptions = {},\n  writeOptions: WriteConfigOptions = {}\n): Promise<{\n  type: 'success' | 'warn' | 'fail';\n  message?: string;\n  config: ExpoConfig | AppJSONConfig | null;\n}> {\n  const config = getConfig(projectRoot, readOptions);\n  if (config.dynamicConfigPath) {\n    // We cannot automatically write to a dynamic config.\n    /* Currently we should just use the safest approach possible, informing the user that they'll need to manually modify their dynamic config.\n\n    if (config.staticConfigPath) {\n      // Both a dynamic and a static config exist.\n      if (config.dynamicConfigObjectType === 'function') {\n        // The dynamic config exports a function, this means it possibly extends the static config.\n      } else {\n        // Dynamic config ignores the static config, there isn't a reason to automatically write to it.\n        // Instead we should warn the user to add values to their dynamic config.\n      }\n    }\n    */\n    return {\n      type: 'warn',\n      message: `Cannot automatically write to dynamic config at: ${path.relative(\n        projectRoot,\n        config.dynamicConfigPath\n      )}`,\n      config: null,\n    };\n  } else if (config.staticConfigPath) {\n    // Static with no dynamic config, this means we can append to the config automatically.\n    let outputConfig: ExpoConfig | AppJSONConfig;\n    // If the config has an expo object (app.json) then append the options to that object.\n    if (config.rootConfig.expo) {\n      outputConfig = {\n        ...config.rootConfig,\n        expo: { ...config.rootConfig.expo, ...modifications },\n      };\n    } else {\n      // Otherwise (app.config.json) just add the config modification to the top most level.\n      outputConfig = { ...config.rootConfig, ...modifications };\n    }\n    if (!writeOptions.dryRun) {\n      await JsonFile.writeAsync(config.staticConfigPath, outputConfig, { json5: false });\n    }\n    return { type: 'success', config: outputConfig };\n  }\n\n  return { type: 'fail', message: 'No config exists', config: null };\n}\n\nconst APP_JSON_EXAMPLE = JSON.stringify({\n  expo: {\n    name: 'My app',\n    slug: 'my-app',\n    sdkVersion: '...',\n  },\n});\n\nfunction ensureConfigHasDefaultValues({\n  projectRoot,\n  exp,\n  pkg,\n  paths,\n  packageJsonPath,\n  skipSDKVersionRequirement = false,\n}: {\n  projectRoot: string;\n  exp: Partial<ExpoConfig> | null;\n  pkg: JSONObject;\n  skipSDKVersionRequirement?: boolean;\n  paths?: ConfigFilePaths;\n  packageJsonPath?: string;\n}): { exp: ExpoConfig; pkg: PackageJSONConfig } {\n  if (!exp) {\n    exp = {};\n  }\n  exp = withInternal(exp as any, {\n    projectRoot,\n    ...(paths ?? {}),\n    packageJsonPath,\n  });\n  // Defaults for package.json fields\n  const pkgName = typeof pkg.name === 'string' ? pkg.name : path.basename(projectRoot);\n  const pkgVersion = typeof pkg.version === 'string' ? pkg.version : '1.0.0';\n\n  const pkgWithDefaults = { ...pkg, name: pkgName, version: pkgVersion };\n\n  // Defaults for app.json/app.config.js fields\n  const name = exp.name ?? pkgName;\n  const slug = exp.slug ?? slugify(name.toLowerCase());\n  const version = exp.version ?? pkgVersion;\n  let description = exp.description;\n  if (!description && typeof pkg.description === 'string') {\n    description = pkg.description;\n  }\n\n  const expWithDefaults = { ...exp, name, slug, version, description };\n\n  let sdkVersion;\n  try {\n    sdkVersion = getExpoSDKVersion(projectRoot, expWithDefaults);\n  } catch (error) {\n    if (!skipSDKVersionRequirement) throw error;\n  }\n\n  let platforms = exp.platforms;\n  if (!platforms) {\n    platforms = getSupportedPlatforms(projectRoot);\n  }\n\n  return {\n    exp: { ...expWithDefaults, sdkVersion, platforms },\n    pkg: pkgWithDefaults,\n  };\n}\n\nexport async function writeConfigJsonAsync(\n  projectRoot: string,\n  options: object\n): Promise<ProjectConfig> {\n  const paths = getConfigFilePaths(projectRoot);\n  let {\n    exp,\n    pkg,\n    rootConfig,\n    dynamicConfigObjectType,\n    staticConfigPath,\n  } = await readConfigJsonAsync(projectRoot);\n  exp = { ...rootConfig.expo, ...options };\n  rootConfig = { ...rootConfig, expo: exp };\n\n  if (paths.staticConfigPath) {\n    await JsonFile.writeAsync(paths.staticConfigPath, rootConfig, { json5: false });\n  } else {\n    console.log('Failed to write to config: ', options);\n  }\n\n  return {\n    exp,\n    pkg,\n    rootConfig,\n    staticConfigPath,\n    dynamicConfigObjectType,\n    ...paths,\n  };\n}\nconst DEFAULT_BUILD_PATH = `web-build`;\n\nexport function getWebOutputPath(config: { [key: string]: any } = {}): string {\n  if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {\n    return process.env.WEBPACK_BUILD_OUTPUT_PATH;\n  }\n  const expo = config.expo || config || {};\n  return expo?.web?.build?.output || DEFAULT_BUILD_PATH;\n}\n\nexport function getNameFromConfig(\n  exp: Record<string, any> = {}\n): { appName?: string; webName?: string } {\n  // For RN CLI support\n  const appManifest = exp.expo || exp;\n  const { web = {} } = appManifest;\n\n  // rn-cli apps use a displayName value as well.\n  const appName = exp.displayName || appManifest.displayName || appManifest.name;\n  const webName = web.name || appName;\n\n  return {\n    appName,\n    webName,\n  };\n}\n\nexport function getDefaultTarget(projectRoot: string): ProjectTarget {\n  const { exp } = getConfig(projectRoot, { skipSDKVersionRequirement: true });\n  // before SDK 37, always default to managed to preserve previous behavior\n  if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && semver.lt(exp.sdkVersion, '37.0.0')) {\n    return 'managed';\n  }\n  return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';\n}\n\nfunction isBareWorkflowProject(projectRoot: string): boolean {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n\n  if (pkg.dependencies && pkg.dependencies.expokit) {\n    return false;\n  }\n\n  const xcodeprojFiles = globSync('ios/**/*.xcodeproj', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (xcodeprojFiles.length) {\n    return true;\n  }\n  const gradleFiles = globSync('android/**/*.gradle', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (gradleFiles.length) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * true if the file is .js or .ts\n *\n * @param filePath\n */\nfunction isDynamicFilePath(filePath: string): boolean {\n  return !!filePath.match(/\\.[j|t]s$/);\n}\n\n/**\n * Return a useful name describing the project config.\n * - dynamic: app.config.js\n * - static: app.json\n * - custom path app config relative to root folder\n * - both: app.config.js or app.json\n */\nexport function getProjectConfigDescription(projectRoot: string): string {\n  const paths = getConfigFilePaths(projectRoot);\n  return getProjectConfigDescriptionWithPaths(projectRoot, paths);\n}\n\n/**\n * Returns a string describing the configurations used for the given project root.\n * Will return null if no config is found.\n *\n * @param projectRoot\n * @param projectConfig\n */\nexport function getProjectConfigDescriptionWithPaths(\n  projectRoot: string,\n  projectConfig: ConfigFilePaths\n): string {\n  if (projectConfig.dynamicConfigPath) {\n    const relativeDynamicConfigPath = path.relative(projectRoot, projectConfig.dynamicConfigPath);\n    if (projectConfig.staticConfigPath) {\n      return `${relativeDynamicConfigPath} or ${path.relative(\n        projectRoot,\n        projectConfig.staticConfigPath\n      )}`;\n    }\n    return relativeDynamicConfigPath;\n  } else if (projectConfig.staticConfigPath) {\n    return path.relative(projectRoot, projectConfig.staticConfigPath);\n  }\n  // If a config doesn't exist, our tooling will generate a static app.json\n  return 'app.json';\n}\n\nexport * from './Config.types';\n\nexport { isLegacyImportsEnabled } from './isLegacyImportsEnabled';\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}