{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _url() {\n  var data = _interopRequireDefault(require(\"url\"));\n\n  _url = function _url() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ws() {\n  var data = require(\"ws\");\n\n  _ws = function _ws() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cliTools() {\n  var data = require(\"@react-native-community/cli-tools\");\n\n  _cliTools = function _cliTools() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar PROTOCOL_VERSION = 2;\n\nfunction parseMessage(data, binary) {\n  if (binary) {\n    _cliTools().logger.error('Expected text message, got binary!');\n\n    return undefined;\n  }\n\n  try {\n    var message = JSON.parse(data);\n\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n\n    _cliTools().logger.error(\"Received message had wrong protocol version: \" + message.version);\n  } catch (e) {\n    _cliTools().logger.error(\"Failed to parse the message as JSON:\\n\" + data);\n  }\n\n  return undefined;\n}\n\nfunction isBroadcast(message) {\n  return typeof message.method === 'string' && message.id === undefined && message.target === undefined;\n}\n\nfunction isRequest(message) {\n  return typeof message.method === 'string' && typeof message.target === 'string';\n}\n\nfunction isResponse(message) {\n  return typeof message.id === 'object' && typeof message.id.requestId !== 'undefined' && typeof message.id.clientId === 'string' && (message.result !== undefined || message.error !== undefined);\n}\n\nfunction attachToServer(server, path) {\n  var wss = new (_ws().Server)({\n    server: server,\n    path: path\n  });\n  var clients = new Map();\n  var nextClientId = 0;\n\n  function getClientWs(clientId) {\n    var clientWs = clients.get(clientId);\n\n    if (clientWs === undefined) {\n      throw new Error(\"could not find id \\\"\" + clientId + \"\\\" while forwarding request\");\n    }\n\n    return clientWs;\n  }\n\n  function handleSendBroadcast(broadcasterId, message) {\n    var forwarded = {\n      version: PROTOCOL_VERSION,\n      method: message.method,\n      params: message.params\n    };\n\n    if (clients.size === 0) {\n      _cliTools().logger.warn(\"No apps connected. Sending \\\"\" + message.method + \"\\\" to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB.\");\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(clients), _step; !(_step = _iterator()).done;) {\n      var _ref = _step.value;\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var otherId = _ref2[0];\n      var otherWs = _ref2[1];\n\n      if (otherId !== broadcasterId) {\n        try {\n          otherWs.send(JSON.stringify(forwarded));\n        } catch (e) {\n          _cliTools().logger.error(\"Failed to send broadcast to client: '\" + otherId + \"' \" + (\"due to:\\n \" + e.toString()));\n        }\n      }\n    }\n  }\n\n  wss.on('connection', function (clientWs) {\n    var clientId = \"client#\" + nextClientId++;\n\n    function handleCaughtError(message, error) {\n      var errorMessage = {\n        id: message.id,\n        method: message.method,\n        target: message.target,\n        error: message.error === undefined ? 'undefined' : 'defined',\n        params: message.params === undefined ? 'undefined' : 'defined',\n        result: message.result === undefined ? 'undefined' : 'defined'\n      };\n\n      if (message.id === undefined) {\n        _cliTools().logger.error(\"Handling message from \" + clientId + \" failed with:\\n\" + error + \"\\n\" + (\"message:\\n\" + JSON.stringify(errorMessage)));\n      } else {\n        try {\n          clientWs.send(JSON.stringify({\n            version: PROTOCOL_VERSION,\n            error: error,\n            id: message.id\n          }));\n        } catch (e) {\n          _cliTools().logger.error(\"Failed to reply to \" + clientId + \" with error:\\n\" + error + (\"\\nmessage:\\n\" + JSON.stringify(errorMessage)) + (\"\\ndue to error: \" + e.toString()));\n        }\n      }\n    }\n\n    function handleServerRequest(message) {\n      var result = null;\n\n      switch (message.method) {\n        case 'getid':\n          result = clientId;\n          break;\n\n        case 'getpeers':\n          result = {};\n          clients.forEach(function (otherWs, otherId) {\n            if (clientId !== otherId) {\n              result[otherId] = _url().default.parse(otherWs.upgradeReq.url, true).query;\n            }\n          });\n          break;\n\n        default:\n          throw new Error(\"unknown method: \" + message.method);\n      }\n\n      clientWs.send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result: result,\n        id: message.id\n      }));\n    }\n\n    function forwardRequest(message) {\n      getClientWs(message.target).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        method: message.method,\n        params: message.params,\n        id: message.id === undefined ? undefined : {\n          requestId: message.id,\n          clientId: clientId\n        }\n      }));\n    }\n\n    function forwardResponse(message) {\n      if (!message.id) {\n        return;\n      }\n\n      getClientWs(message.id.clientId).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result: message.result,\n        error: message.error,\n        id: message.id.requestId\n      }));\n    }\n\n    clients.set(clientId, clientWs);\n\n    var onCloseHandler = function onCloseHandler() {\n      clientWs.onmessage = null;\n      clients.delete(clientId);\n    };\n\n    clientWs.onclose = onCloseHandler;\n    clientWs.onerror = onCloseHandler;\n\n    clientWs.onmessage = function (event) {\n      var message = parseMessage(event.data, event.binary);\n\n      if (message === undefined) {\n        _cliTools().logger.error('Received message not matching protocol');\n\n        return;\n      }\n\n      try {\n        if (isBroadcast(message)) {\n          handleSendBroadcast(clientId, message);\n        } else if (isRequest(message)) {\n          if (message.target === 'server') {\n            handleServerRequest(message);\n          } else {\n            forwardRequest(message);\n          }\n        } else if (isResponse(message)) {\n          forwardResponse(message);\n        } else {\n          throw new Error('Invalid message, did not match the protocol');\n        }\n      } catch (e) {\n        handleCaughtError(message, e.toString());\n      }\n    };\n  });\n  return {\n    broadcast: function broadcast(method, params) {\n      handleSendBroadcast(null, {\n        method: method,\n        params: params\n      });\n    }\n  };\n}\n\nvar _default = {\n  attachToServer: attachToServer,\n  parseMessage: parseMessage\n};\nexports.default = _default;","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/@react-native-community/cli-server-api/build/websocket/messageSocketServer.js"],"names":["Object","defineProperty","exports","value","default","_url","data","_interopRequireDefault","require","_ws","_cliTools","obj","__esModule","PROTOCOL_VERSION","parseMessage","binary","logger","error","undefined","message","JSON","parse","version","e","isBroadcast","method","id","target","isRequest","isResponse","requestId","clientId","result","attachToServer","server","path","wss","Server","clients","Map","nextClientId","getClientWs","clientWs","get","Error","handleSendBroadcast","broadcasterId","forwarded","params","size","warn","otherId","otherWs","send","stringify","toString","on","handleCaughtError","errorMessage","handleServerRequest","forEach","upgradeReq","url","query","forwardRequest","forwardResponse","set","onCloseHandler","onmessage","delete","onclose","onerror","event","broadcast","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _url() {\n  const data = _interopRequireDefault(require(\"url\"));\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ws() {\n  const data = require(\"ws\");\n\n  _ws = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cliTools() {\n  const data = require(\"@react-native-community/cli-tools\");\n\n  _cliTools = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst PROTOCOL_VERSION = 2;\n\nfunction parseMessage(data, binary) {\n  if (binary) {\n    _cliTools().logger.error('Expected text message, got binary!');\n\n    return undefined;\n  }\n\n  try {\n    const message = JSON.parse(data);\n\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n\n    _cliTools().logger.error(`Received message had wrong protocol version: ${message.version}`);\n  } catch (e) {\n    _cliTools().logger.error(`Failed to parse the message as JSON:\\n${data}`);\n  }\n\n  return undefined;\n}\n\nfunction isBroadcast(message) {\n  return typeof message.method === 'string' && message.id === undefined && message.target === undefined;\n}\n\nfunction isRequest(message) {\n  return typeof message.method === 'string' && typeof message.target === 'string';\n}\n\nfunction isResponse(message) {\n  return typeof message.id === 'object' && typeof message.id.requestId !== 'undefined' && typeof message.id.clientId === 'string' && (message.result !== undefined || message.error !== undefined);\n}\n\nfunction attachToServer(server, path) {\n  const wss = new (_ws().Server)({\n    server,\n    path\n  });\n  const clients = new Map();\n  let nextClientId = 0;\n\n  function getClientWs(clientId) {\n    const clientWs = clients.get(clientId);\n\n    if (clientWs === undefined) {\n      throw new Error(`could not find id \"${clientId}\" while forwarding request`);\n    }\n\n    return clientWs;\n  }\n\n  function handleSendBroadcast(broadcasterId, message) {\n    const forwarded = {\n      version: PROTOCOL_VERSION,\n      method: message.method,\n      params: message.params\n    };\n\n    if (clients.size === 0) {\n      _cliTools().logger.warn(`No apps connected. Sending \"${message.method}\" to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB.`);\n    }\n\n    for (const [otherId, otherWs] of clients) {\n      if (otherId !== broadcasterId) {\n        try {\n          otherWs.send(JSON.stringify(forwarded));\n        } catch (e) {\n          _cliTools().logger.error(`Failed to send broadcast to client: '${otherId}' ` + `due to:\\n ${e.toString()}`);\n        }\n      }\n    }\n  }\n\n  wss.on('connection', clientWs => {\n    const clientId = `client#${nextClientId++}`;\n\n    function handleCaughtError(message, error) {\n      const errorMessage = {\n        id: message.id,\n        method: message.method,\n        target: message.target,\n        error: message.error === undefined ? 'undefined' : 'defined',\n        params: message.params === undefined ? 'undefined' : 'defined',\n        result: message.result === undefined ? 'undefined' : 'defined'\n      };\n\n      if (message.id === undefined) {\n        _cliTools().logger.error(`Handling message from ${clientId} failed with:\\n${error}\\n` + `message:\\n${JSON.stringify(errorMessage)}`);\n      } else {\n        try {\n          clientWs.send(JSON.stringify({\n            version: PROTOCOL_VERSION,\n            error,\n            id: message.id\n          }));\n        } catch (e) {\n          _cliTools().logger.error(`Failed to reply to ${clientId} with error:\\n${error}` + `\\nmessage:\\n${JSON.stringify(errorMessage)}` + `\\ndue to error: ${e.toString()}`);\n        }\n      }\n    }\n\n    function handleServerRequest(message) {\n      let result = null;\n\n      switch (message.method) {\n        case 'getid':\n          result = clientId;\n          break;\n\n        case 'getpeers':\n          result = {};\n          clients.forEach((otherWs, otherId) => {\n            if (clientId !== otherId) {\n              result[otherId] = _url().default.parse(otherWs.upgradeReq.url, true).query;\n            }\n          });\n          break;\n\n        default:\n          throw new Error(`unknown method: ${message.method}`);\n      }\n\n      clientWs.send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result,\n        id: message.id\n      }));\n    }\n\n    function forwardRequest(message) {\n      getClientWs(message.target).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        method: message.method,\n        params: message.params,\n        id: message.id === undefined ? undefined : {\n          requestId: message.id,\n          clientId\n        }\n      }));\n    }\n\n    function forwardResponse(message) {\n      if (!message.id) {\n        return;\n      }\n\n      getClientWs(message.id.clientId).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result: message.result,\n        error: message.error,\n        id: message.id.requestId\n      }));\n    }\n\n    clients.set(clientId, clientWs);\n\n    const onCloseHandler = () => {\n      // @ts-ignore\n      clientWs.onmessage = null;\n      clients.delete(clientId);\n    };\n\n    clientWs.onclose = onCloseHandler;\n    clientWs.onerror = onCloseHandler;\n\n    clientWs.onmessage = event => {\n      const message = parseMessage(event.data, event.binary);\n\n      if (message === undefined) {\n        _cliTools().logger.error('Received message not matching protocol');\n\n        return;\n      }\n\n      try {\n        if (isBroadcast(message)) {\n          handleSendBroadcast(clientId, message);\n        } else if (isRequest(message)) {\n          if (message.target === 'server') {\n            handleServerRequest(message);\n          } else {\n            forwardRequest(message);\n          }\n        } else if (isResponse(message)) {\n          forwardResponse(message);\n        } else {\n          throw new Error('Invalid message, did not match the protocol');\n        }\n      } catch (e) {\n        handleCaughtError(message, e.toString());\n      }\n    };\n  });\n  return {\n    broadcast: (method, params) => {\n      handleSendBroadcast(null, {\n        method,\n        params\n      });\n    }\n  };\n}\n\nvar _default = {\n  attachToServer,\n  parseMessage\n};\nexports.default = _default;\n\n//# sourceMappingURL=messageSocketServer.js.map"]},"metadata":{},"sourceType":"script"}