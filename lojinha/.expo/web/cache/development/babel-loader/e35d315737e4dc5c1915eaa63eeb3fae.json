{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport fs from 'fs';\nimport yargs from 'yargs';\nimport { Command } from \"./Command\";\nimport { Event } from \"./Event\";\nimport { Graph } from \"./Graph\";\nimport { Property } from \"./Property\";\nimport { PropsType, Type } from \"./Type\";\nimport { HeaderWriter } from \"./HeaderWriter\";\nimport { ImplementationWriter } from \"./ImplementationWriter\";\n\nvar proto = require('devtools-protocol/json/js_protocol.json');\n\nfunction parseDomains(domainObjs, ignoreExperimental) {\n  var desc = {\n    types: [],\n    commands: [],\n    events: []\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(domainObjs), _step; !(_step = _iterator()).done;) {\n    var obj = _step.value;\n    var domain = obj.domain;\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(obj.types || []), _step2; !(_step2 = _iterator2()).done;) {\n      var typeObj = _step2.value;\n      var type = Type.create(domain, typeObj, ignoreExperimental);\n\n      if (type) {\n        desc.types.push(type);\n      }\n    }\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(obj.commands || []), _step3; !(_step3 = _iterator3()).done;) {\n      var commandObj = _step3.value;\n      var command = Command.create(domain, commandObj, ignoreExperimental);\n\n      if (command) {\n        desc.commands.push(command);\n      }\n    }\n\n    for (var _iterator4 = _createForOfIteratorHelperLoose(obj.events || []), _step4; !(_step4 = _iterator4()).done;) {\n      var eventObj = _step4.value;\n      var event = Event.create(domain, eventObj, ignoreExperimental);\n\n      if (event) {\n        desc.events.push(event);\n      }\n    }\n  }\n\n  return desc;\n}\n\nfunction buildGraph(desc) {\n  var graph = new Graph();\n  var types = desc.types;\n  var commands = desc.commands;\n  var events = desc.events;\n\n  var maybeAddPropEdges = function maybeAddPropEdges(nodeId, props) {\n    if (props) {\n      for (var _iterator5 = _createForOfIteratorHelperLoose(props), _step5; !(_step5 = _iterator5()).done;) {\n        var prop = _step5.value;\n        var refId = prop.getRefDebuggerName();\n        prop.recursive = refId && refId === nodeId;\n\n        if (refId && refId !== nodeId) {\n          graph.addEdge(nodeId, refId);\n        }\n      }\n    }\n  };\n\n  for (var _iterator6 = _createForOfIteratorHelperLoose(types), _step6; !(_step6 = _iterator6()).done;) {\n    var type = _step6.value;\n    graph.addNode(type.getDebuggerName());\n\n    if (type instanceof PropsType) {\n      maybeAddPropEdges(type.getDebuggerName(), type.properties);\n    }\n  }\n\n  for (var _iterator7 = _createForOfIteratorHelperLoose(commands), _step7; !(_step7 = _iterator7()).done;) {\n    var command = _step7.value;\n    graph.addNode(command.getDebuggerName());\n    maybeAddPropEdges(command.getDebuggerName(), command.parameters);\n    maybeAddPropEdges(command.getDebuggerName(), command.returns);\n  }\n\n  for (var _iterator8 = _createForOfIteratorHelperLoose(events), _step8; !(_step8 = _iterator8()).done;) {\n    var event = _step8.value;\n    graph.addNode(event.getDebuggerName());\n    maybeAddPropEdges(event.getDebuggerName(), event.parameters);\n  }\n\n  return graph;\n}\n\nfunction parseRoots(desc, rootsPath) {\n  var roots = [];\n\n  if (rootsPath) {\n    var buf = fs.readFileSync(rootsPath);\n\n    for (var _iterator9 = _createForOfIteratorHelperLoose(buf.toString().split('\\n')), _step9; !(_step9 = _iterator9()).done;) {\n      var line = _step9.value;\n      line = line.trim();\n\n      if (!line.match(/\\s*#/) && line.length > 0) {\n        roots.push(line);\n      }\n    }\n  } else {\n    for (var _iterator10 = _createForOfIteratorHelperLoose(desc.types), _step10; !(_step10 = _iterator10()).done;) {\n      var type = _step10.value;\n      roots.push(type.getDebuggerName());\n    }\n\n    for (var _iterator11 = _createForOfIteratorHelperLoose(desc.commands), _step11; !(_step11 = _iterator11()).done;) {\n      var command = _step11.value;\n      roots.push(command.getDebuggerName());\n    }\n\n    for (var _iterator12 = _createForOfIteratorHelperLoose(desc.events), _step12; !(_step12 = _iterator12()).done;) {\n      var event = _step12.value;\n      roots.push(event.getDebuggerName());\n    }\n  }\n\n  return roots;\n}\n\nfunction filterReachableFromRoots(desc, graph, roots) {\n  var topoSortedIds = graph.traverse(roots);\n  var typeMap = new Map();\n\n  for (var _iterator13 = _createForOfIteratorHelperLoose(desc.types), _step13; !(_step13 = _iterator13()).done;) {\n    var type = _step13.value;\n    typeMap.set(type.getDebuggerName(), type);\n  }\n\n  var types = [];\n\n  for (var _iterator14 = _createForOfIteratorHelperLoose(topoSortedIds), _step14; !(_step14 = _iterator14()).done;) {\n    var id = _step14.value;\n\n    var _type = typeMap.get(id);\n\n    if (_type) {\n      types.push(_type);\n    }\n  }\n\n  var ids = new Set(topoSortedIds);\n  var commands = desc.commands.filter(function (cmd) {\n    return ids.has(cmd.getDebuggerName());\n  });\n  var events = desc.events.filter(function (event) {\n    return ids.has(event.getDebuggerName());\n  });\n\n  var comparator = function comparator(a, b) {\n    var id1 = a.getDebuggerName();\n    var id2 = b.getDebuggerName();\n    return id1 < id2 ? -1 : id1 > id2 ? 1 : 0;\n  };\n\n  commands.sort(comparator);\n  events.sort(comparator);\n  return {\n    types: types,\n    commands: commands,\n    events: events\n  };\n}\n\nfunction main() {\n  var args = yargs.usage('Usage: msggen <header_path> <cpp_path>').alias('h', 'help').help('h').boolean('e').alias('e', 'ignore-experimental').describe('e', 'ignore experimental commands, props, and types').alias('r', 'roots').describe('r', 'path to a file listing root types, events, and commands').nargs('r', 1).demandCommand(2, 2).argv;\n  var ignoreExperimental = !!args.e;\n\n  var _args$_ = _slicedToArray(args._, 2),\n      headerPath = _args$_[0],\n      implPath = _args$_[1];\n\n  var headerStream = fs.createWriteStream(headerPath);\n  var implStream = fs.createWriteStream(implPath);\n  var desc = parseDomains(proto.domains, ignoreExperimental);\n  var graph = buildGraph(desc);\n  var roots = parseRoots(desc, String(args.roots));\n  var reachable = filterReachableFromRoots(desc, graph, roots);\n  var hw = new HeaderWriter(headerStream, reachable.types, reachable.commands, reachable.events);\n  hw.write();\n  var iw = new ImplementationWriter(implStream, reachable.types, reachable.commands, reachable.events);\n  iw.write();\n}\n\nmain();","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/ReactCommon/hermes/inspector/tools/msggen/src/index.js"],"names":["fs","yargs","Command","Event","Graph","Property","PropsType","Type","HeaderWriter","ImplementationWriter","proto","require","parseDomains","domainObjs","ignoreExperimental","desc","types","commands","events","obj","domain","typeObj","type","create","push","commandObj","command","eventObj","event","buildGraph","graph","maybeAddPropEdges","nodeId","props","prop","refId","getRefDebuggerName","recursive","addEdge","addNode","getDebuggerName","properties","parameters","returns","parseRoots","rootsPath","roots","buf","readFileSync","toString","split","line","trim","match","length","filterReachableFromRoots","topoSortedIds","traverse","typeMap","Map","set","id","get","ids","Set","filter","cmd","has","comparator","a","b","id1","id2","sort","main","args","usage","alias","help","boolean","describe","nargs","demandCommand","argv","e","_","headerPath","implPath","headerStream","createWriteStream","implStream","domains","String","reachable","hw","write","iw"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport fs from 'fs';\n\nimport yargs from 'yargs';\n\nimport {Command} from './Command';\nimport {Event} from './Event';\nimport {Graph} from './Graph';\nimport {Property} from './Property';\nimport {PropsType, Type} from './Type';\n\nimport {HeaderWriter} from './HeaderWriter';\nimport {ImplementationWriter} from './ImplementationWriter';\n\n// $FlowFixMe: this isn't a module, just a JSON file.\nconst proto = require('devtools-protocol/json/js_protocol.json');\n\ntype Descriptor = {|\n  types: Array<Type>,\n  commands: Array<Command>,\n  events: Array<Event>,\n|};\n\nfunction parseDomains(\n  domainObjs: Array<any>,\n  ignoreExperimental: boolean,\n): Descriptor {\n  const desc = {\n    types: [],\n    commands: [],\n    events: [],\n  };\n\n  for (const obj of domainObjs) {\n    const domain = obj.domain;\n\n    for (const typeObj of obj.types || []) {\n      const type = Type.create(domain, typeObj, ignoreExperimental);\n      if (type) {\n        desc.types.push(type);\n      }\n    }\n\n    for (const commandObj of obj.commands || []) {\n      const command = Command.create(domain, commandObj, ignoreExperimental);\n      if (command) {\n        desc.commands.push(command);\n      }\n    }\n\n    for (const eventObj of obj.events || []) {\n      const event = Event.create(domain, eventObj, ignoreExperimental);\n      if (event) {\n        desc.events.push(event);\n      }\n    }\n  }\n\n  return desc;\n}\n\nfunction buildGraph(desc: Descriptor): Graph {\n  const graph = new Graph();\n\n  const types = desc.types;\n  const commands = desc.commands;\n  const events = desc.events;\n\n  const maybeAddPropEdges = function(nodeId: string, props: ?Array<Property>) {\n    if (props) {\n      for (const prop of props) {\n        const refId = prop.getRefDebuggerName();\n        (prop: Object).recursive = refId && refId === nodeId;\n        if (refId && refId !== nodeId) {\n          // Don't add edges for recursive properties.\n          graph.addEdge(nodeId, refId);\n        }\n      }\n    }\n  };\n\n  for (const type of types) {\n    graph.addNode(type.getDebuggerName());\n\n    if (type instanceof PropsType) {\n      maybeAddPropEdges(type.getDebuggerName(), type.properties);\n    }\n  }\n\n  for (const command of commands) {\n    graph.addNode(command.getDebuggerName());\n\n    maybeAddPropEdges(command.getDebuggerName(), command.parameters);\n    maybeAddPropEdges(command.getDebuggerName(), command.returns);\n  }\n\n  for (const event of events) {\n    graph.addNode(event.getDebuggerName());\n\n    maybeAddPropEdges(event.getDebuggerName(), event.parameters);\n  }\n\n  return graph;\n}\n\nfunction parseRoots(desc: Descriptor, rootsPath: ?string): Array<string> {\n  const roots = [];\n\n  if (rootsPath) {\n    const buf = fs.readFileSync(rootsPath);\n    for (let line of buf.toString().split('\\n')) {\n      line = line.trim();\n\n      // ignore comments and blank lines\n      if (!line.match(/\\s*#/) && line.length > 0) {\n        roots.push(line);\n      }\n    }\n  } else {\n    for (const type of desc.types) {\n      roots.push(type.getDebuggerName());\n    }\n    for (const command of desc.commands) {\n      roots.push(command.getDebuggerName());\n    }\n    for (const event of desc.events) {\n      roots.push(event.getDebuggerName());\n    }\n  }\n\n  return roots;\n}\n\n// only include types, commands, events that can be reached from the given\n// root messages\nfunction filterReachableFromRoots(\n  desc: Descriptor,\n  graph: Graph,\n  roots: Array<string>,\n): Descriptor {\n  const topoSortedIds = graph.traverse(roots);\n\n  // Types can include other types by value, so they need to be topologically\n  // sorted in the header.\n  const typeMap: Map<string, Type> = new Map();\n  for (const type of desc.types) {\n    typeMap.set(type.getDebuggerName(), type);\n  }\n\n  const types = [];\n  for (const id of topoSortedIds) {\n    const type = typeMap.get(id);\n    if (type) {\n      types.push(type);\n    }\n  }\n\n  // Commands and events don't depend on each other, so just emit them in the\n  // order we got them from the JSON file.\n  const ids = new Set(topoSortedIds);\n  const commands = desc.commands.filter(cmd => ids.has(cmd.getDebuggerName()));\n  const events = desc.events.filter(event => ids.has(event.getDebuggerName()));\n\n  // Sort commands and events so the code is easier to read. Types have to be\n  // topologically sorted as explained above.\n  const comparator = (a, b) => {\n    const id1 = a.getDebuggerName();\n    const id2 = b.getDebuggerName();\n    return id1 < id2 ? -1 : id1 > id2 ? 1 : 0;\n  };\n  commands.sort(comparator);\n  events.sort(comparator);\n\n  return {types, commands, events};\n}\n\nfunction main() {\n  const args = yargs\n    .usage('Usage: msggen <header_path> <cpp_path>')\n    .alias('h', 'help')\n    .help('h')\n    .boolean('e')\n    .alias('e', 'ignore-experimental')\n    .describe('e', 'ignore experimental commands, props, and types')\n    .alias('r', 'roots')\n    .describe('r', 'path to a file listing root types, events, and commands')\n    .nargs('r', 1)\n    .demandCommand(2, 2).argv;\n\n  const ignoreExperimental = !!args.e;\n  const [headerPath, implPath] = args._;\n\n  const headerStream = fs.createWriteStream(headerPath);\n  const implStream = fs.createWriteStream(implPath);\n\n  const desc = parseDomains(proto.domains, ignoreExperimental);\n  const graph = buildGraph(desc);\n  const roots = parseRoots(desc, String(args.roots));\n\n  const reachable = filterReachableFromRoots(desc, graph, roots);\n\n  const hw = new HeaderWriter(\n    headerStream,\n    reachable.types,\n    reachable.commands,\n    reachable.events,\n  );\n  hw.write();\n\n  const iw = new ImplementationWriter(\n    implStream,\n    reachable.types,\n    reachable.commands,\n    reachable.events,\n  );\n  iw.write();\n}\n\nmain();\n"]},"metadata":{},"sourceType":"module"}