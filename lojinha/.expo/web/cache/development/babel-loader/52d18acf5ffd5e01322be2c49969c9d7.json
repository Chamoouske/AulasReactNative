{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path = __importStar(require(\"path\"));\n\nvar xcode_1 = __importDefault(require(\"xcode\"));\n\nvar pbxFile_1 = __importDefault(require(\"xcode/lib/pbxFile\"));\n\nvar errors_1 = require(\"../../utils/errors\");\n\nvar warnings_1 = require(\"../../utils/warnings\");\n\nvar Paths = __importStar(require(\"../Paths\"));\n\nfunction getProjectName(projectRoot) {\n  var sourceRoot = Paths.getSourceRoot(projectRoot);\n  return path.basename(sourceRoot);\n}\n\nexports.getProjectName = getProjectName;\n\nfunction sanitizedName(name) {\n  return name.replace(/[\\W_]+/g, '').normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n}\n\nfunction getHackyProjectName(projectRoot, config) {\n  try {\n    return getProjectName(projectRoot);\n  } catch (_a) {\n    var projectName = config.name;\n    errors_1.assert(projectName, 'Your project needs a name in app.json/app.config.js.');\n    return sanitizedName(projectName);\n  }\n}\n\nexports.getHackyProjectName = getHackyProjectName;\n\nfunction addResourceFileToGroup(filepath, groupName, project) {\n  var group = pbxGroupByPath(project, groupName);\n\n  if (!group) {\n    throw Error(\"Xcode PBXGroup with name \\\"\" + groupName + \"\\\" could not be found in the Xcode project.\");\n  }\n\n  var file = new pbxFile_1.default(filepath);\n  var conflictingFile = group.children.find(function (child) {\n    return child.comment === file.basename;\n  });\n\n  if (conflictingFile) {\n    warnings_1.addWarningIOS('ios-xcode-project', \"Skipped adding duplicate file \\\"\" + filepath + \"\\\" to PBXGroup named \\\"\" + groupName + \"\\\"\");\n    return project;\n  }\n\n  file.uuid = project.generateUuid();\n  file.fileRef = project.generateUuid();\n  project.addToPbxFileReferenceSection(file);\n  project.addToPbxBuildFileSection(file);\n  project.addToPbxResourcesBuildPhase(file);\n  group.children.push({\n    value: file.fileRef,\n    comment: file.basename\n  });\n  return project;\n}\n\nexports.addResourceFileToGroup = addResourceFileToGroup;\n\nfunction getApplicationNativeTarget(_ref) {\n  var project = _ref.project,\n      projectName = _ref.projectName;\n  var applicationNativeTarget = project.getTarget('com.apple.product-type.application');\n  errors_1.assert(applicationNativeTarget, \"Couldn't locate application PBXNativeTarget in '.xcodeproj' file.\");\n  errors_1.assert(String(applicationNativeTarget.target.name) === projectName, \"Application native target name mismatch. Expected \" + projectName + \", but found \" + applicationNativeTarget.target.name + \".\");\n  return applicationNativeTarget;\n}\n\nexports.getApplicationNativeTarget = getApplicationNativeTarget;\n\nfunction addFramework(_ref2) {\n  var project = _ref2.project,\n      projectName = _ref2.projectName,\n      framework = _ref2.framework;\n  var target = getApplicationNativeTarget({\n    project: project,\n    projectName: projectName\n  });\n  return project.addFramework(framework, {\n    target: target.uuid\n  });\n}\n\nexports.addFramework = addFramework;\n\nfunction splitPath(path) {\n  return path.split('/');\n}\n\nvar findGroup = function findGroup(group, name) {\n  if (!group) {\n    return undefined;\n  }\n\n  return group.children.find(function (group) {\n    return group.comment === name;\n  });\n};\n\nfunction findGroupInsideGroup(project, group, name) {\n  var _a;\n\n  var foundGroup = findGroup(group, name);\n\n  if (foundGroup) {\n    return (_a = project.getPBXGroupByKey(foundGroup.value)) !== null && _a !== void 0 ? _a : null;\n  }\n\n  return null;\n}\n\nfunction pbxGroupByPath(project, path) {\n  var _project$getFirstProj = project.getFirstProject(),\n      firstProject = _project$getFirstProj.firstProject;\n\n  var group = project.getPBXGroupByKey(firstProject.mainGroup);\n  var components = splitPath(path);\n\n  for (var _iterator = _createForOfIteratorHelperLoose(components), _step; !(_step = _iterator()).done;) {\n    var name = _step.value;\n    var nextGroup = findGroupInsideGroup(project, group, name);\n\n    if (nextGroup) {\n      group = nextGroup;\n    } else {\n      return null;\n    }\n  }\n\n  return group !== null && group !== void 0 ? group : null;\n}\n\nfunction ensureGroupRecursively(project, filepath) {\n  var components = splitPath(filepath);\n\n  var hasChild = function hasChild(group, name) {\n    return group.children.find(function (_ref3) {\n      var comment = _ref3.comment;\n      return comment === name;\n    });\n  };\n\n  var _project$getFirstProj2 = project.getFirstProject(),\n      firstProject = _project$getFirstProj2.firstProject;\n\n  var topMostGroup = project.getPBXGroupByKey(firstProject.mainGroup);\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(components), _step2; !(_step2 = _iterator2()).done;) {\n    var pathComponent = _step2.value;\n\n    if (topMostGroup && !hasChild(topMostGroup, pathComponent)) {\n      topMostGroup.children.push({\n        comment: pathComponent,\n        value: project.pbxCreateGroup(pathComponent, '\"\"')\n      });\n    }\n\n    topMostGroup = project.pbxGroupByName(pathComponent);\n  }\n\n  return topMostGroup !== null && topMostGroup !== void 0 ? topMostGroup : null;\n}\n\nexports.ensureGroupRecursively = ensureGroupRecursively;\n\nfunction getPbxproj(projectRoot) {\n  var projectPath = Paths.getPBXProjectPath(projectRoot);\n  var project = xcode_1.default.project(projectPath);\n  project.parseSync();\n  return project;\n}\n\nexports.getPbxproj = getPbxproj;\n\nfunction getProductName(project) {\n  var _a, _b;\n\n  var productName = project.productName;\n\n  if (productName === '$(TARGET_NAME)') {\n    var targetName = (_b = (_a = project.getFirstTarget()) === null || _a === void 0 ? void 0 : _a.firstTarget) === null || _b === void 0 ? void 0 : _b.productName;\n    productName = targetName !== null && targetName !== void 0 ? targetName : project.productName;\n  }\n\n  return productName;\n}\n\nexports.getProductName = getProductName;\n\nfunction getProjectSection(project) {\n  return project.pbxProjectSection();\n}\n\nexports.getProjectSection = getProjectSection;\n\nfunction getNativeTargets(project) {\n  var section = project.pbxNativeTargetSection();\n  return Object.entries(section).filter(isNotComment);\n}\n\nexports.getNativeTargets = getNativeTargets;\n\nfunction findFirstNativeTarget(project) {\n  var targets = Object.values(getProjectSection(project))[0].targets;\n  var target = targets[0].value;\n  var nativeTargets = getNativeTargets(project);\n  return nativeTargets.find(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 1),\n        key = _ref5[0];\n\n    return key === target;\n  });\n}\n\nexports.findFirstNativeTarget = findFirstNativeTarget;\n\nfunction findNativeTargetByName(project, targetName) {\n  var nativeTargets = getNativeTargets(project);\n  return nativeTargets.find(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        i = _ref7[1];\n\n    return i.name === targetName || i.name === \"\\\"\" + targetName + \"\\\"\";\n  });\n}\n\nexports.findNativeTargetByName = findNativeTargetByName;\n\nfunction getXCConfigurationListEntries(project) {\n  var lists = project.pbxXCConfigurationList();\n  return Object.entries(lists).filter(isNotComment);\n}\n\nexports.getXCConfigurationListEntries = getXCConfigurationListEntries;\n\nfunction getBuildConfigurationForId(project, configurationListId) {\n  var configurationListEntries = getXCConfigurationListEntries(project);\n\n  var _configurationListEnt = configurationListEntries.find(function (_ref8) {\n    var _ref9 = _slicedToArray(_ref8, 1),\n        key = _ref9[0];\n\n    return key === configurationListId;\n  }),\n      _configurationListEnt2 = _slicedToArray(_configurationListEnt, 2),\n      configurationList = _configurationListEnt2[1];\n\n  var buildConfigurations = configurationList.buildConfigurations.map(function (i) {\n    return i.value;\n  });\n  return Object.entries(project.pbxXCBuildConfigurationSection()).filter(isNotComment).filter(isBuildConfig).filter(isNotTestHost).filter(function (_ref10) {\n    var _ref11 = _slicedToArray(_ref10, 1),\n        key = _ref11[0];\n\n    return buildConfigurations.includes(key);\n  });\n}\n\nexports.getBuildConfigurationForId = getBuildConfigurationForId;\n\nfunction isBuildConfig(_ref12) {\n  var _ref13 = _slicedToArray(_ref12, 2),\n      sectionItem = _ref13[1];\n\n  return sectionItem.isa === 'XCBuildConfiguration';\n}\n\nexports.isBuildConfig = isBuildConfig;\n\nfunction isNotTestHost(_ref14) {\n  var _ref15 = _slicedToArray(_ref14, 2),\n      sectionItem = _ref15[1];\n\n  return !sectionItem.buildSettings.TEST_HOST;\n}\n\nexports.isNotTestHost = isNotTestHost;\n\nfunction isNotComment(_ref16) {\n  var _ref17 = _slicedToArray(_ref16, 1),\n      key = _ref17[0];\n\n  return !key.endsWith(\"_comment\");\n}\n\nexports.isNotComment = isNotComment;","map":{"version":3,"sources":["../../../src/ios/utils/Xcodeproj.ts"],"names":[],"mappings":"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","sourcesContent":["import { ExpoConfig } from '@expo/config-types';\nimport * as path from 'path';\nimport xcode, {\n  PBXGroup,\n  PBXNativeTarget,\n  PBXProject,\n  UUID,\n  XCBuildConfiguration,\n  XCConfigurationList,\n  XcodeProject,\n} from 'xcode';\nimport pbxFile from 'xcode/lib/pbxFile';\n\nimport { assert } from '../../utils/errors';\nimport { addWarningIOS } from '../../utils/warnings';\nimport * as Paths from '../Paths';\n\nexport type ProjectSectionEntry = [string, PBXProject];\n\nexport type NativeTargetSection = Record<string, PBXNativeTarget>;\n\nexport type NativeTargetSectionEntry = [string, PBXNativeTarget];\n\nexport type ConfigurationLists = Record<string, XCConfigurationList>;\n\nexport type ConfigurationListEntry = [string, XCConfigurationList];\n\nexport type ConfigurationSectionEntry = [string, XCBuildConfiguration];\n\nexport function getProjectName(projectRoot: string) {\n  const sourceRoot = Paths.getSourceRoot(projectRoot);\n  return path.basename(sourceRoot);\n}\n\n// TODO: come up with a better solution for using app.json expo.name in various places\nfunction sanitizedName(name: string) {\n  return name\n    .replace(/[\\W_]+/g, '')\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '');\n}\n\n// TODO: it's silly and kind of fragile that we look at app config to determine\n// the ios project paths. Overall this function needs to be revamped, just a\n// placeholder for now! Make this more robust when we support applying config\n// at any time (currently it's only applied on eject).\nexport function getHackyProjectName(projectRoot: string, config: ExpoConfig): string {\n  // Attempt to get the current ios folder name (apply).\n  try {\n    return getProjectName(projectRoot);\n  } catch {\n    // If no iOS project exists then create a new one (eject).\n    const projectName = config.name;\n    assert(projectName, 'Your project needs a name in app.json/app.config.js.');\n    return sanitizedName(projectName);\n  }\n}\n\n// TODO(brentvatne): I couldn't figure out how to do this with an existing\n// higher level function exposed by the xcode library, but we should find out how to do\n// that and replace this with it\nexport function addResourceFileToGroup(\n  filepath: string,\n  groupName: string,\n  project: XcodeProject\n): XcodeProject {\n  const group = pbxGroupByPath(project, groupName);\n  if (!group) {\n    throw Error(`Xcode PBXGroup with name \"${groupName}\" could not be found in the Xcode project.`);\n  }\n  const file = new pbxFile(filepath);\n\n  const conflictingFile = group.children.find(child => child.comment === file.basename);\n  if (conflictingFile) {\n    // This can happen when a file like the GoogleService-Info.plist needs to be added and the eject command is run twice.\n    // Not much we can do here since it might be a conflicting file.\n    addWarningIOS(\n      'ios-xcode-project',\n      `Skipped adding duplicate file \"${filepath}\" to PBXGroup named \"${groupName}\"`\n    );\n    return project;\n  }\n\n  file.uuid = project.generateUuid();\n  file.fileRef = project.generateUuid();\n  project.addToPbxFileReferenceSection(file);\n  project.addToPbxBuildFileSection(file);\n  project.addToPbxResourcesBuildPhase(file);\n\n  group.children.push({\n    value: file.fileRef,\n    comment: file.basename,\n  });\n  return project;\n}\n\nexport function getApplicationNativeTarget({\n  project,\n  projectName,\n}: {\n  project: XcodeProject;\n  projectName: string;\n}) {\n  const applicationNativeTarget = project.getTarget('com.apple.product-type.application');\n  assert(\n    applicationNativeTarget,\n    `Couldn't locate application PBXNativeTarget in '.xcodeproj' file.`\n  );\n  assert(\n    String(applicationNativeTarget.target.name) === projectName,\n    `Application native target name mismatch. Expected ${projectName}, but found ${applicationNativeTarget.target.name}.`\n  );\n  return applicationNativeTarget;\n}\n\n/**\n * Add a framework to the default app native target.\n *\n * @param projectName Name of the PBX project.\n * @param framework String ending in `.framework`, i.e. `StoreKit.framework`\n */\nexport function addFramework({\n  project,\n  projectName,\n  framework,\n}: {\n  project: XcodeProject;\n  projectName: string;\n  framework: string;\n}) {\n  const target = getApplicationNativeTarget({ project, projectName });\n  return project.addFramework(framework, { target: target.uuid });\n}\n\nfunction splitPath(path: string): string[] {\n  // TODO: Should we account for other platforms that may not use `/`\n  return path.split('/');\n}\n\nconst findGroup = (\n  group: PBXGroup | undefined,\n  name: string\n):\n  | {\n      value: UUID;\n      comment?: string;\n    }\n  | undefined => {\n  if (!group) {\n    return undefined;\n  }\n\n  return group.children.find(group => group.comment === name);\n};\n\nfunction findGroupInsideGroup(\n  project: XcodeProject,\n  group: PBXGroup | undefined,\n  name: string\n): null | PBXGroup {\n  const foundGroup = findGroup(group, name);\n  if (foundGroup) {\n    return project.getPBXGroupByKey(foundGroup.value) ?? null;\n  }\n  return null;\n}\n\nfunction pbxGroupByPath(project: XcodeProject, path: string): null | PBXGroup {\n  const { firstProject } = project.getFirstProject();\n\n  let group = project.getPBXGroupByKey(firstProject.mainGroup);\n\n  const components = splitPath(path);\n  for (const name of components) {\n    const nextGroup = findGroupInsideGroup(project, group, name);\n    if (nextGroup) {\n      group = nextGroup;\n    } else {\n      return null;\n    }\n  }\n\n  return group ?? null;\n}\n\nexport function ensureGroupRecursively(project: XcodeProject, filepath: string): PBXGroup | null {\n  const components = splitPath(filepath);\n  const hasChild = (group: PBXGroup, name: string) =>\n    group.children.find(({ comment }) => comment === name);\n  const { firstProject } = project.getFirstProject();\n\n  let topMostGroup = project.getPBXGroupByKey(firstProject.mainGroup);\n\n  for (const pathComponent of components) {\n    if (topMostGroup && !hasChild(topMostGroup, pathComponent)) {\n      topMostGroup.children.push({\n        comment: pathComponent,\n        value: project.pbxCreateGroup(pathComponent, '\"\"'),\n      });\n    }\n    topMostGroup = project.pbxGroupByName(pathComponent);\n  }\n  return topMostGroup ?? null;\n}\n\n/**\n * Get the pbxproj for the given path\n */\nexport function getPbxproj(projectRoot: string): XcodeProject {\n  const projectPath = Paths.getPBXProjectPath(projectRoot);\n  const project = xcode.project(projectPath);\n  project.parseSync();\n  return project;\n}\n\n/**\n * Get the productName for a project, if the name is using a variable `$(TARGET_NAME)`, then attempt to get the value of that variable.\n *\n * @param project\n */\nexport function getProductName(project: XcodeProject): string {\n  let productName = project.productName;\n\n  if (productName === '$(TARGET_NAME)') {\n    const targetName = project.getFirstTarget()?.firstTarget?.productName;\n    productName = targetName ?? project.productName;\n  }\n\n  return productName;\n}\n\nexport function getProjectSection(project: XcodeProject) {\n  return project.pbxProjectSection();\n}\n\nexport function getNativeTargets(project: XcodeProject): NativeTargetSectionEntry[] {\n  const section = project.pbxNativeTargetSection();\n  return Object.entries(section).filter(isNotComment);\n}\n\nexport function findFirstNativeTarget(project: XcodeProject): NativeTargetSectionEntry {\n  const { targets } = Object.values(getProjectSection(project))[0];\n  const target = targets[0].value;\n  const nativeTargets = getNativeTargets(project);\n  return nativeTargets.find(([key]) => key === target) as NativeTargetSectionEntry;\n}\n\nexport function findNativeTargetByName(\n  project: XcodeProject,\n  targetName: string\n): NativeTargetSectionEntry {\n  const nativeTargets = getNativeTargets(project);\n  return nativeTargets.find(\n    ([, i]) => i.name === targetName || i.name === `\"${targetName}\"`\n  ) as NativeTargetSectionEntry;\n}\n\nexport function getXCConfigurationListEntries(project: XcodeProject): ConfigurationListEntry[] {\n  const lists = project.pbxXCConfigurationList();\n  return Object.entries(lists).filter(isNotComment);\n}\n\nexport function getBuildConfigurationForId(\n  project: XcodeProject,\n  configurationListId: string\n): ConfigurationSectionEntry[] {\n  const configurationListEntries = getXCConfigurationListEntries(project);\n  const [, configurationList] = configurationListEntries.find(\n    ([key]) => key === configurationListId\n  ) as ConfigurationListEntry;\n\n  const buildConfigurations = configurationList.buildConfigurations.map(i => i.value);\n\n  return Object.entries(project.pbxXCBuildConfigurationSection())\n    .filter(isNotComment)\n    .filter(isBuildConfig)\n    .filter(isNotTestHost)\n    .filter(([key]: ConfigurationSectionEntry) => buildConfigurations.includes(key));\n}\n\nexport function isBuildConfig([, sectionItem]: ConfigurationSectionEntry): boolean {\n  return sectionItem.isa === 'XCBuildConfiguration';\n}\n\nexport function isNotTestHost([, sectionItem]: ConfigurationSectionEntry): boolean {\n  return !sectionItem.buildSettings.TEST_HOST;\n}\n\nexport function isNotComment([key]:\n  | ConfigurationSectionEntry\n  | ProjectSectionEntry\n  | ConfigurationListEntry\n  | NativeTargetSectionEntry): boolean {\n  return !key.endsWith(`_comment`);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}