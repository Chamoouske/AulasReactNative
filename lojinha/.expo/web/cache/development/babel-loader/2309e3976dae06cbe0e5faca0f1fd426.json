{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar UnexpectedError = function (_Error) {\n  _inherits(UnexpectedError, _Error);\n\n  var _super = _createSuper(UnexpectedError);\n\n  function UnexpectedError(message) {\n    var _this;\n\n    _classCallCheck(this, UnexpectedError);\n\n    _this = _super.call(this, message + \"\\nPlease report this as an issue on https://github.com/expo/expo-cli/issues\");\n    _this.name = 'UnexpectedError';\n    return _this;\n  }\n\n  return UnexpectedError;\n}(_wrapNativeSuper(Error));\n\nexports.UnexpectedError = UnexpectedError;\n\nvar PluginError = function (_Error2) {\n  _inherits(PluginError, _Error2);\n\n  var _super2 = _createSuper(PluginError);\n\n  function PluginError(message, code, cause) {\n    var _this2;\n\n    _classCallCheck(this, PluginError);\n\n    _this2 = _super2.call(this, cause ? message + \"\\n\\u2514\\u2500 Cause: \" + cause.name + \": \" + cause.message : message);\n    _this2.code = code;\n    _this2.cause = cause;\n    _this2.name = 'PluginError';\n    _this2.isPluginError = true;\n    return _this2;\n  }\n\n  return PluginError;\n}(_wrapNativeSuper(Error));\n\nexports.PluginError = PluginError;\n\nfunction assert(value, message) {\n  return assert_1.default(value, message);\n}\n\nexports.assert = assert;","map":{"version":3,"sources":["../../src/utils/errors.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;IAEa,e;;;;;AAGX,2BAAY,OAAZ,EAA2B;AAAA;;AAAA;;AACzB,8BAAS,OAAT;AAHO,UAAA,IAAA,GAAO,iBAAP;AAEkB;AAE1B;;;mBALkC,K;;AAArC,OAAA,CAAA,eAAA,GAAA,eAAA;;IAaa,W;;;;;AAIX,uBAAY,OAAZ,EAAoC,IAApC,EAAkE,KAAlE,EAA+E;AAAA;;AAAA;;AAC7E,gCAAM,KAAK,GAAM,OAAN,8BAA4B,KAAK,CAAC,IAAlC,UAA2C,KAAK,CAAC,OAAjD,GAA6D,OAAxE;AADkC,WAAA,IAAA,GAAA,IAAA;AAA8B,WAAA,KAAA,GAAA,KAAA;AAHzD,WAAA,IAAA,GAAO,aAAP;AACA,WAAA,aAAA,GAAgB,IAAhB;AAEsE;AAE9E;;;mBAN8B,K;;AAAjC,OAAA,CAAA,WAAA,GAAA,WAAA;;AASA,SAAgB,MAAhB,CAAuB,KAAvB,EAAmC,OAAnC,EAA2D;AAEzD,SAAO,QAAA,CAAA,OAAA,CAAW,KAAX,EAAkB,OAAlB,CAAP;AACD;;AAHD,OAAA,CAAA,MAAA,GAAA,MAAA","sourcesContent":["import nodeAssert from 'assert';\n\nexport class UnexpectedError extends Error {\n  readonly name = 'UnexpectedError';\n\n  constructor(message: string) {\n    super(`${message}\\nPlease report this as an issue on https://github.com/expo/expo-cli/issues`);\n  }\n}\n\nexport type PluginErrorCode = 'INVALID_PLUGIN_TYPE';\n\n/**\n * Based on `JsonFileError` from `@expo/json-file`\n */\nexport class PluginError extends Error {\n  readonly name = 'PluginError';\n  readonly isPluginError = true;\n\n  constructor(message: string, public code: PluginErrorCode, public cause?: Error) {\n    super(cause ? `${message}\\n└─ Cause: ${cause.name}: ${cause.message}` : message);\n  }\n}\n\nexport function assert(value: any, message?: string | Error): asserts value {\n  // TODO: Upgrade node? TypeScript isn't properly asserting values without this wrapper.\n  return nodeAssert(value, message);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}