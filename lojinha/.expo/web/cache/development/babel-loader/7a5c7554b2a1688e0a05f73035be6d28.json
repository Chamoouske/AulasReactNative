{"ast":null,"code":"'use strict';\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar nullthrows = require('nullthrows');\n\nvar _require = require(\"./CppHelpers.js\"),\n    getCppTypeForAnnotation = _require.getCppTypeForAnnotation,\n    toSafeCppString = _require.toSafeCppString,\n    generateEventStructName = _require.generateEventStructName;\n\nvar template = \"\\n/**\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n#pragma once\\n\\n#include <react/components/view/ViewEventEmitter.h>\\n\\nnamespace facebook {\\nnamespace react {\\n\\n::_COMPONENT_EMITTERS_::\\n\\n} // namespace react\\n} // namespace facebook\\n\";\nvar componentTemplate = \"\\nclass ::_CLASSNAME_::EventEmitter : public ViewEventEmitter {\\n public:\\n  using ViewEventEmitter::ViewEventEmitter;\\n\\n  ::_STRUCTS_::\\n\\n  ::_EVENTS_::\\n};\\n\".trim();\nvar structTemplate = \"\\n  struct ::_STRUCT_NAME_:: {\\n    ::_FIELDS_::\\n  };\\n\".trim();\nvar enumTemplate = \"enum class ::_ENUM_NAME_:: {\\n  ::_VALUES_::\\n};\\n\\nstatic char const *toString(const ::_ENUM_NAME_:: value) {\\n  switch (value) {\\n    ::_TO_CASES_::\\n  }\\n}\\n\".trim();\n\nfunction indent(nice, spaces) {\n  return nice.split('\\n').map(function (line, index) {\n    if (line.length === 0 || index === 0) {\n      return line;\n    }\n\n    var emptySpaces = new Array(spaces + 1).join(' ');\n    return emptySpaces + line;\n  }).join('\\n');\n}\n\nfunction getNativeTypeFromAnnotation(componentName, eventProperty, nameParts) {\n  var type = eventProperty.type;\n\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n    case 'FloatTypeAnnotation':\n      return getCppTypeForAnnotation(type);\n\n    case 'StringEnumTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n\n    case 'ObjectTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n\n    default:\n      type;\n      throw new Error(\"Received invalid event property type \" + type);\n  }\n}\n\nfunction generateEnum(structs, options, nameParts) {\n  var structName = generateEventStructName(nameParts);\n  var fields = options.map(function (option, index) {\n    return \"\" + toSafeCppString(option.name);\n  }).join(',\\n  ');\n  var toCases = options.map(function (option) {\n    return \"case \" + structName + \"::\" + toSafeCppString(option.name) + \": return \\\"\" + option.name + \"\\\";\";\n  }).join('\\n' + '    ');\n  structs.set(structName, enumTemplate.replace(/::_ENUM_NAME_::/g, structName).replace('::_VALUES_::', fields).replace('::_TO_CASES_::', toCases));\n}\n\nfunction generateStruct(structs, componentName, nameParts, properties) {\n  var structNameParts = nameParts;\n  var structName = generateEventStructName(structNameParts);\n  var fields = properties.map(function (property) {\n    return getNativeTypeFromAnnotation(componentName, property, structNameParts) + \" \" + property.name + \";\";\n  }).join('\\n' + '  ');\n  properties.forEach(function (property) {\n    var name = property.name;\n\n    switch (property.type) {\n      case 'BooleanTypeAnnotation':\n      case 'StringTypeAnnotation':\n      case 'Int32TypeAnnotation':\n      case 'DoubleTypeAnnotation':\n      case 'FloatTypeAnnotation':\n        return;\n\n      case 'ObjectTypeAnnotation':\n        generateStruct(structs, componentName, nameParts.concat([name]), nullthrows(property.properties));\n        return;\n\n      case 'StringEnumTypeAnnotation':\n        generateEnum(structs, property.options, nameParts.concat([name]));\n        return;\n\n      default:\n        property;\n        throw new Error(\"Received invalid event property type \" + property.type);\n    }\n  });\n  structs.set(structName, structTemplate.replace('::_STRUCT_NAME_::', structName).replace('::_FIELDS_::', fields));\n}\n\nfunction generateStructs(componentName, component) {\n  var structs = new Map();\n  component.events.forEach(function (event) {\n    if (event.typeAnnotation.argument) {\n      generateStruct(structs, componentName, [event.name], event.typeAnnotation.argument.properties);\n    }\n  });\n  return Array.from(structs.values()).join('\\n\\n');\n}\n\nfunction generateEvent(componentName, event) {\n  if (event.typeAnnotation.argument) {\n    var structName = generateEventStructName([event.name]);\n    return \"void \" + event.name + \"(\" + structName + \" value) const;\";\n  }\n\n  return \"void \" + event.name + \"() const;\";\n}\n\nfunction generateEvents(componentName, component) {\n  return component.events.map(function (event) {\n    return generateEvent(componentName, event);\n  }).join('\\n\\n' + '  ');\n}\n\nmodule.exports = {\n  generate: function generate(libraryName, schema, moduleSpecName) {\n    var moduleComponents = Object.keys(schema.modules).map(function (moduleName) {\n      var components = schema.modules[moduleName].components;\n\n      if (components == null) {\n        return null;\n      }\n\n      return components;\n    }).filter(Boolean).reduce(function (acc, components) {\n      return _extends(acc, components);\n    }, {});\n    var moduleComponentsWithEvents = Object.keys(moduleComponents).filter(function (componentName) {\n      return moduleComponents[componentName].events.length > 0;\n    });\n    var fileName = 'EventEmitters.h';\n    var componentEmitters = moduleComponentsWithEvents.length > 0 ? Object.keys(moduleComponents).map(function (componentName) {\n      var component = moduleComponents[componentName];\n      var replacedTemplate = componentTemplate.replace(/::_CLASSNAME_::/g, componentName).replace('::_STRUCTS_::', indent(generateStructs(componentName, component), 2)).replace('::_EVENTS_::', generateEvents(componentName, component)).trim();\n      return replacedTemplate;\n    }).join('\\n') : '';\n    var replacedTemplate = template.replace(/::_COMPONENT_EMITTERS_::/g, componentEmitters);\n    return new Map([[fileName, replacedTemplate]]);\n  }\n};","map":{"version":3,"sources":["/home/chamoouske/Aulas/ReactNative/RandomWord/node_modules/react-native/packages/react-native-codegen/src/generators/components/GenerateEventEmitterH.js"],"names":["nullthrows","require","getCppTypeForAnnotation","toSafeCppString","generateEventStructName","template","componentTemplate","trim","structTemplate","enumTemplate","indent","nice","spaces","split","map","line","index","length","emptySpaces","Array","join","getNativeTypeFromAnnotation","componentName","eventProperty","nameParts","type","concat","name","Error","generateEnum","structs","options","structName","fields","option","toCases","set","replace","generateStruct","properties","structNameParts","property","forEach","generateStructs","component","Map","events","event","typeAnnotation","argument","from","values","generateEvent","generateEvents","module","exports","generate","libraryName","schema","moduleSpecName","moduleComponents","Object","keys","modules","moduleName","components","filter","Boolean","reduce","acc","moduleComponentsWithEvents","fileName","componentEmitters","replacedTemplate"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nconst nullthrows = require('nullthrows');\n\nconst {\n  getCppTypeForAnnotation,\n  toSafeCppString,\n  generateEventStructName,\n} = require('./CppHelpers.js');\n\nimport type {\n  ComponentShape,\n  EventTypeShape,\n  ObjectPropertyType,\n  SchemaType,\n} from '../../CodegenSchema';\n\n// File path -> contents\ntype FilesOutput = Map<string, string>;\ntype StructsMap = Map<string, string>;\n\ntype ComponentCollection = $ReadOnly<{\n  [component: string]: ComponentShape,\n  ...,\n}>;\n\nconst template = `\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <react/components/view/ViewEventEmitter.h>\n\nnamespace facebook {\nnamespace react {\n\n::_COMPONENT_EMITTERS_::\n\n} // namespace react\n} // namespace facebook\n`;\n\nconst componentTemplate = `\nclass ::_CLASSNAME_::EventEmitter : public ViewEventEmitter {\n public:\n  using ViewEventEmitter::ViewEventEmitter;\n\n  ::_STRUCTS_::\n\n  ::_EVENTS_::\n};\n`.trim();\n\nconst structTemplate = `\n  struct ::_STRUCT_NAME_:: {\n    ::_FIELDS_::\n  };\n`.trim();\n\nconst enumTemplate = `enum class ::_ENUM_NAME_:: {\n  ::_VALUES_::\n};\n\nstatic char const *toString(const ::_ENUM_NAME_:: value) {\n  switch (value) {\n    ::_TO_CASES_::\n  }\n}\n`.trim();\n\nfunction indent(nice: string, spaces: number) {\n  return nice\n    .split('\\n')\n    .map((line, index) => {\n      if (line.length === 0 || index === 0) {\n        return line;\n      }\n      const emptySpaces = new Array(spaces + 1).join(' ');\n      return emptySpaces + line;\n    })\n    .join('\\n');\n}\n\nfunction getNativeTypeFromAnnotation(\n  componentName: string,\n  eventProperty: ObjectPropertyType,\n  nameParts: $ReadOnlyArray<string>,\n): string {\n  const type = eventProperty.type;\n\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n    case 'FloatTypeAnnotation':\n      return getCppTypeForAnnotation(type);\n    case 'StringEnumTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n    case 'ObjectTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n    default:\n      (type: empty);\n      throw new Error(`Received invalid event property type ${type}`);\n  }\n}\nfunction generateEnum(structs, options, nameParts) {\n  const structName = generateEventStructName(nameParts);\n  const fields = options\n    .map((option, index) => `${toSafeCppString(option.name)}`)\n    .join(',\\n  ');\n\n  const toCases = options\n    .map(\n      option =>\n        `case ${structName}::${toSafeCppString(option.name)}: return \"${\n          option.name\n        }\";`,\n    )\n    .join('\\n' + '    ');\n\n  structs.set(\n    structName,\n    enumTemplate\n      .replace(/::_ENUM_NAME_::/g, structName)\n      .replace('::_VALUES_::', fields)\n      .replace('::_TO_CASES_::', toCases),\n  );\n}\n\nfunction generateStruct(\n  structs: StructsMap,\n  componentName: string,\n  nameParts: $ReadOnlyArray<string>,\n  properties: $ReadOnlyArray<ObjectPropertyType>,\n): void {\n  const structNameParts = nameParts;\n  const structName = generateEventStructName(structNameParts);\n\n  const fields = properties\n    .map(property => {\n      return `${getNativeTypeFromAnnotation(\n        componentName,\n        property,\n        structNameParts,\n      )} ${property.name};`;\n    })\n    .join('\\n' + '  ');\n\n  properties.forEach((property: ObjectPropertyType) => {\n    const name = property.name;\n    switch (property.type) {\n      case 'BooleanTypeAnnotation':\n      case 'StringTypeAnnotation':\n      case 'Int32TypeAnnotation':\n      case 'DoubleTypeAnnotation':\n      case 'FloatTypeAnnotation':\n        return;\n      case 'ObjectTypeAnnotation':\n        generateStruct(\n          structs,\n          componentName,\n          nameParts.concat([name]),\n          nullthrows(property.properties),\n        );\n        return;\n      case 'StringEnumTypeAnnotation':\n        generateEnum(structs, property.options, nameParts.concat([name]));\n        return;\n      default:\n        (property: empty);\n        throw new Error(\n          `Received invalid event property type ${property.type}`,\n        );\n    }\n  });\n\n  structs.set(\n    structName,\n    structTemplate\n      .replace('::_STRUCT_NAME_::', structName)\n      .replace('::_FIELDS_::', fields),\n  );\n}\n\nfunction generateStructs(componentName: string, component): string {\n  const structs: StructsMap = new Map();\n\n  component.events.forEach(event => {\n    if (event.typeAnnotation.argument) {\n      generateStruct(\n        structs,\n        componentName,\n        [event.name],\n        event.typeAnnotation.argument.properties,\n      );\n    }\n  });\n\n  return Array.from(structs.values()).join('\\n\\n');\n}\n\nfunction generateEvent(componentName: string, event: EventTypeShape): string {\n  if (event.typeAnnotation.argument) {\n    const structName = generateEventStructName([event.name]);\n\n    return `void ${event.name}(${structName} value) const;`;\n  }\n\n  return `void ${event.name}() const;`;\n}\nfunction generateEvents(componentName: string, component): string {\n  return component.events\n    .map(event => generateEvent(componentName, event))\n    .join('\\n\\n' + '  ');\n}\n\nmodule.exports = {\n  generate(\n    libraryName: string,\n    schema: SchemaType,\n    moduleSpecName: string,\n  ): FilesOutput {\n    const moduleComponents: ComponentCollection = Object.keys(schema.modules)\n      .map(moduleName => {\n        const components = schema.modules[moduleName].components;\n        // No components in this module\n        if (components == null) {\n          return null;\n        }\n\n        return components;\n      })\n      .filter(Boolean)\n      .reduce((acc, components) => Object.assign(acc, components), {});\n\n    const moduleComponentsWithEvents = Object.keys(moduleComponents).filter(\n      componentName => moduleComponents[componentName].events.length > 0,\n    );\n\n    const fileName = 'EventEmitters.h';\n\n    const componentEmitters =\n      moduleComponentsWithEvents.length > 0\n        ? Object.keys(moduleComponents)\n            .map(componentName => {\n              const component = moduleComponents[componentName];\n\n              const replacedTemplate = componentTemplate\n                .replace(/::_CLASSNAME_::/g, componentName)\n                .replace(\n                  '::_STRUCTS_::',\n                  indent(generateStructs(componentName, component), 2),\n                )\n                .replace(\n                  '::_EVENTS_::',\n                  generateEvents(componentName, component),\n                )\n                .trim();\n\n              return replacedTemplate;\n            })\n            .join('\\n')\n        : '';\n\n    const replacedTemplate = template.replace(\n      /::_COMPONENT_EMITTERS_::/g,\n      componentEmitters,\n    );\n\n    return new Map([[fileName, replacedTemplate]]);\n  },\n};\n"]},"metadata":{},"sourceType":"script"}